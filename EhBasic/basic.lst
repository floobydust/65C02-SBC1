  Sun Mar  3 2019 22:47                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;
     2                        ; Enhanced BASIC for the C02 Pocket SBC, Version 2.22p4C
     3                        ; Original version/source by Lee Davison w/updates to Version 2.22
     4                        ; Patches and updates by Klaus Dorman Version 2.22p4
     5                        ; "C" is appended to define CMOS instructions/addressing modes used
     6                        ; Modified source code to assemble with WDC Tools package
     7                        ; Changes by K. E. Maier - July-November 2018
     8                        ;   minor changes and cleanup as of 13th November 2018
     9                        ;
    10                        ;	Assembler/Linker directives for WDC Tools
    11                        ;
    12                        	PL	66	;Page Length
    13                        	PW	132	;Page Width (# of char/line)
    14                        	CHIP	W65C02S	;Enable WDC 65C02 instructions/addressing modes
    15                        	INCLIST	ON ;Include listing file
    16                        	PASS1	OFF	;Set ON when used for debug
    17                        ;
    18                        ; Code changes include:
    19                        ;		Use ROM based CHRGET/CHRGOT routine with Page Zero pointer
    20                        ;		All Page zero usage is from the bottom ($00) up ($AF is max available)
    21                        ;		CMOS opcodes/addressing modes are used! tested with WDC65C02 only!
    22                        ;		Version renamed to Ver 2.22p4C (concurrency with Klaus' patched version)
    23                        ;	The following functions and all associated code (interrupt related)
    24                        ;	 have been removed as they aren't needed with the C02 Pocket SBC:
    25                        ;	- IRQ 
    26                        ; - RETIRQ
    27                        ;	- NMI
    28                        ; - RETNMI
    29                        ;	- OFF
    30                        ;
    31                        ; An EXIT primary command has been added
    32                        ;   The EXIT command performs a JMP to the C02Monitor Warm start vector
    33                        ;   EhBasic can be re-entered via Warm start unless pages zero/four are changed
    34                        ;
    35                        ; 2.00      new revision numbers start here
    36                        ; 2.01      fixed LCASE$() and UCASE$()
    37                        ; 2.02      new get value routine done
    38                        ; 2.03      changed RND() to galoise method
    39                        ; 2.04      fixed SPC()
    40                        ; 2.05      new get value routine fixed
    41                        ; 2.06      changed USR() code
    42                        ; 2.07      fixed STR$()
    43                        ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
    44                        ; 2.09      fixed RND()
    45                        ; 2.10      integrated missed changes from an earlier version
    46                        ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    47                        ; 2.21      fixed IF .. THEN RETURN to not cause error
    48                        ; 2.22      fixed RND() breaking the get byte routine
    49                        ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
    50                        ;              (bugsnquirks.txt notes 2, 4 and 5)
    51                        ;              tabs converted to spaces, tabwidth=6
    52                        ; 2.22p2    fixed can't continue error on 1st statement after direct mode
    53                        ;              changed INPUT to throw "break in line ##" on empty line input
    54                        ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
    55                        ;              fix provided by github user mgcaret
    56                        ;              fixed string compare of equal strings in direct mode returns FALSE
    57                        ; 2.22p4    fixed FALSE stored to a variable after a string compare 
  Sun Mar  3 2019 22:47                                                                                                    Page 2


    58                        ;                 is > 0 and < 1E-16
    59                        ;              added additional stack floor protection for background interrupts
    60                        ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
    61                        ; 2.22p4C   Port to C02 Pocket SBC - SCC2691 UART Console, 32KB RAM / 32KB ROM, 6MHz CPU
    62                        ;
    63             00000000   ZPSTART  	.EQU	$00		; Start of zero page workspace
    64                        ;
    65             00000000   LAB_WARM 	.EQU ZPSTART	; $00=BASIC warm start entry point
    66             00000001   Wrmjpl 		.EQU LAB_WARM+1	; BASIC warm start vector jump low byte
    67             00000002   Wrmjph 		.EQU LAB_WARM+2	; BASIC warm start vector jump high byte
    68                        
    69             00000003   Usrjmp		.EQU Wrmjph+1	; USR function JMP address
    70             00000004   Usrjpl		.EQU Usrjmp+1	; USR function JMP vector low byte
    71             00000005   Usrjph		.EQU Usrjmp+2	; USR function JMP vector high byte
    72                        
    73             00000006   Nullct		.EQU Usrjph+1	; nulls output after each line
    74             00000007   TPos			.EQU Nullct+1	; BASIC terminal position byte
    75             00000008   TWidth		.EQU TPos+1	; BASIC terminal width byte
    76             00000009   Iclim			.EQU TWidth+1	; input column limit
    77             0000000A   Itempl		.EQU Iclim+1	; temporary integer low byte
    78             0000000B   Itemph		.EQU Itempl+1	; temporary integer high byte
    79                        
    80             0000000A   nums_1		.EQU Itempl	; number to bin/hex string convert MSB
    81             0000000B   nums_2		.EQU nums_1+1	; number to bin/hex string convert
    82             0000000C   nums_3		.EQU nums_1+2	; number to bin/hex string convert LSB
    83                        
    84             0000000D   Srchc			.EQU nums_3+1	; search character
    85             0000000D   Temp3			.EQU Srchc		; temp byte used in number routines
    86             0000000E   Scnquo		.EQU Srchc+1	; scan-between-quotes flag
    87             0000000E   Asrch			.EQU Scnquo	; alt search character
    88                        
    89             0000000D   XOAw_l		.EQU Srchc		; eXclusive OR, OR and AND word low byte
    90             0000000E   XOAw_h		.EQU Scnquo	; eXclusive OR, OR and AND word high byte
    91                        
    92             0000000F   Ibptr			.EQU Scnquo+1	; input buffer pointer
    93             0000000F   Dimcnt		.EQU Ibptr		; # of dimensions
    94             0000000F   Tindx			.EQU Ibptr		; token index
    95                        
    96             00000010   Defdim		.EQU Ibptr+1	; default DIM flag
    97             00000011   Dtypef		.EQU Defdim+1	; data type flag, $FF=string, $00=numeric
    98             00000012   Oquote		.EQU Dtypef+1	; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
    99             00000012   Gclctd		.EQU Oquote	; garbage collected flag
   100             00000013   Sufnxf		.EQU Gclctd+1	; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
   101             00000014   Imode			.EQU Sufnxf+1	; input mode flag, $00=INPUT, $80=READ
   102                        
   103             00000015   Cflag			.EQU Imode+1	; comparison evaluation flag
   104                        
   105             00000016   TabSiz		.EQU Cflag+1	; TAB step size (was input flag)
   106                        
   107             00000017   next_s		.EQU TabSiz+1	; next descriptor stack address
   108                        
   109                        ; these two bytes form a word pointer to the item
   110                        ; currently on top of the descriptor stack
   111                        
   112             00000018   last_sl		.EQU next_s+1	; last descriptor stack address low byte
   113             00000019   last_sh		.EQU last_sl+1	; last descriptor stack address high byte (always $00)
   114                        
   115             0000001A   des_sk		.EQU last_sh+1	; descriptor stack start address (temp strings)
   116                        
   117             00000023   ut1_pl		.EQU des_sk+9	; utility pointer 1 low byte
   118             00000024   ut1_ph		.EQU ut1_pl+1	; utility pointer 1 high byte
   119             00000025   ut2_pl		.EQU ut1_ph+1	; utility pointer 2 low byte
   120             00000026   ut2_ph		.EQU ut2_pl+1	; utility pointer 2 high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 3


   121                        
   122             00000023   Temp_2		.EQU ut1_pl	; temp byte for block move	
   123                        
   124             00000027   FACt_1		.EQU ut2_ph+1	; FAC temp mantissa1
   125             00000028   FACt_2		.EQU FACt_1+1	; FAC temp mantissa2
   126             00000029   FACt_3		.EQU FACt_2+1	; FAC temp mantissa3
   127                        
   128             00000028   dims_l		.EQU FACt_2	; array dimension size low byte
   129             00000029   dims_h		.EQU FACt_3	; array dimension size high byte
   130                        
   131             0000002A   TempB			.EQU FACt_1+3	; temp page 0 byte
   132                        
   133             0000002B   Smeml			.EQU TempB+1	; start of mem low byte		(Start-of-Basic)
   134             0000002C   Smemh			.EQU Smeml+1	; start of mem high byte	(Start-of-Basic)
   135             0000002D   Svarl			.EQU Smemh+1	; start of vars low byte	(Start-of-Variables)
   136             0000002E   Svarh			.EQU Svarl+1	; start of vars high byte	(Start-of-Variables)
   137             0000002F   Sarryl		.EQU Svarh+1	; var mem end low byte		(Start-of-Arrays)
   138             00000030   Sarryh		.EQU Sarryl+1	; var mem end high byte		(Start-of-Arrays)
   139             00000031   Earryl		.EQU Sarryh+1	; array mem end low byte	(End-of-Arrays)
   140             00000032   Earryh		.EQU Earryl+1	; array mem end high byte	(End-of-Arrays)
   141             00000033   Sstorl		.EQU Earryh+1	; string storage low byte	(String storage (moving down))
   142             00000034   Sstorh		.EQU Sstorl+1	; string storage high byte	(String storage (moving down))
   143             00000035   Sutill		.EQU Sstorh+1	; string utility ptr low byte
   144             00000036   Sutilh		.EQU Sutill+1	; string utility ptr high byte
   145             00000037   Ememl			.EQU Sutilh+1	; end of mem low byte		(Limit-of-memory)
   146             00000038   Ememh			.EQU Ememl+1	; end of mem high byte		(Limit-of-memory)
   147             00000039   Clinel		.EQU Ememh+1	; current line low byte		(Basic line number)
   148             0000003A   Clineh		.EQU Clinel+1	; current line high byte	(Basic line number)
   149             0000003B   Blinel		.EQU Clineh+1	; break line low byte		(Previous Basic line number)
   150             0000003C   Blineh		.EQU Blinel+1	; break line high byte		(Previous Basic line number)
   151                        
   152             0000003D   Cpntrl		.EQU Blineh+1	; continue pointer low byte
   153             0000003E   Cpntrh		.EQU Cpntrl+1	; continue pointer high byte
   154                        
   155             0000003F   Dlinel		.EQU Cpntrh+1	; current DATA line low byte
   156             00000040   Dlineh		.EQU Dlinel+1	; current DATA line high byte
   157                        
   158             00000041   Dptrl			.EQU Dlineh+1	; DATA pointer low byte
   159             00000042   Dptrh			.EQU Dptrl+1	; DATA pointer high byte
   160                        
   161             00000043   Rdptrl		.EQU Dptrh+1	; read pointer low byte
   162             00000044   Rdptrh		.EQU Rdptrl+1	; read pointer high byte
   163                        
   164             00000045   Varnm1		.EQU Rdptrh+1	; current var name 1st byte
   165             00000046   Varnm2		.EQU Varnm1+1	; current var name 2nd byte
   166                        
   167             00000047   Cvaral		.EQU Varnm2+1	; current var address low byte
   168             00000048   Cvarah		.EQU Cvaral+1	; current var address high byte
   169                        
   170             00000049   Frnxtl		.EQU Cvarah+1	; var pointer for FOR/NEXT low byte
   171             0000004A   Frnxth		.EQU Frnxtl+1	; var pointer for FOR/NEXT high byte
   172                        
   173             00000049   Tidx1			.EQU Frnxtl	; temp line index
   174                        
   175             00000049   Lvarpl		.EQU Frnxtl	; let var pointer low byte
   176             0000004A   Lvarph		.EQU Frnxth	; let var pointer high byte
   177                        
   178             0000004B   prstk			.EQU Frnxtl+2	; precedence stacked flag
   179                        
   180             0000004D   comp_f		.EQU prstk+2	; compare function flag, bits 0,1 and 2 used
   181                        				; bit 2 set if >
   182                        				; bit 1 set if =
   183                        				; bit 0 set if <
  Sun Mar  3 2019 22:47                                                                                                    Page 4


   184                        
   185             0000004E   func_l		.EQU comp_f+1	; function pointer low byte
   186             0000004F   func_h		.EQU func_l+1	; function pointer high byte
   187                        
   188             0000004E   garb_l		.EQU func_l	; garbage collection working pointer low byte
   189             0000004F   garb_h		.EQU func_h	; garbage collection working pointer high byte
   190                        
   191             00000050   des_2l		.EQU func_h+1	; string descriptor_2 pointer low byte
   192             00000051   des_2h		.EQU des_2l+1	; string descriptor_2 pointer high byte
   193                        
   194             00000052   g_step		.EQU des_2l+2	; garbage collect step size
   195                        
   196             00000053   Fnxjmp		.EQU g_step+1	; jump vector for functions
   197             00000054   Fnxjpl		.EQU Fnxjmp+1	; functions jump vector low byte
   198             00000055   Fnxjph		.EQU Fnxjmp+2	; functions jump vector high byte
   199                        
   200             00000054   g_indx		.EQU Fnxjpl	; garbage collect temp index
   201                        
   202             00000055   FAC2_r		.EQU Fnxjmp+2	; FAC2 rounding byte
   203                        
   204             00000056   Adatal		.EQU FAC2_r+1	; array data pointer low byte
   205             00000057   Adatah		.EQU Adatal+1	; array data pointer high  byte
   206                        
   207             00000056   Nbendl		.EQU Adatal	; new block end pointer low byte
   208             00000057   Nbendh		.EQU Adatah	; new block end pointer high  byte
   209                        
   210             00000058   Obendl		.EQU Adatah+1	; old block end pointer low byte
   211             00000059   Obendh		.EQU Obendl+1	; old block end pointer high  byte
   212                        
   213             0000005A   numexp		.EQU Obendh+1	; string to float number exponent count
   214             0000005B   expcnt		.EQU numexp+1	; string to float exponent count
   215                        
   216             0000005A   numbit		.EQU numexp	; bit count for array element calculations
   217                        
   218             0000005C   numdpf		.EQU expcnt+1	; string to float decimal point flag
   219             0000005D   expneg		.EQU numdpf+1	; string to float eval exponent -ve flag
   220                        
   221             0000005C   Astrtl		.EQU numdpf	; array start pointer low byte
   222             0000005D   Astrth		.EQU expneg	; array start pointer high  byte
   223                        
   224             0000005C   Histrl		.EQU numdpf	; highest string low byte
   225             0000005D   Histrh		.EQU expneg	; highest string high  byte
   226                        
   227             0000005C   Baslnl		.EQU numdpf	; BASIC search line pointer low byte
   228             0000005D   Baslnh		.EQU expneg	; BASIC search line pointer high  byte
   229                        
   230             0000005C   Fvar_l		.EQU numdpf	; find/found variable pointer low byte
   231             0000005D   Fvar_h		.EQU expneg	; find/found variable pointer high  byte
   232                        
   233             0000005C   Ostrtl		.EQU numdpf	; old block start pointer low byte
   234             0000005D   Ostrth		.EQU expneg	; old block start pointer high  byte
   235                        
   236             0000005C   Vrschl		.EQU numdpf	; variable search pointer low byte
   237             0000005D   Vrschh		.EQU expneg	; variable search pointer high  byte
   238                        
   239             0000005E   FAC1_e		.EQU expneg+1	; FAC1 exponent
   240             0000005F   FAC1_1		.EQU FAC1_e+1	; FAC1 mantissa1
   241             00000060   FAC1_2		.EQU FAC1_e+2	; FAC1 mantissa2
   242             00000061   FAC1_3		.EQU FAC1_e+3	; FAC1 mantissa3
   243             00000062   FAC1_s		.EQU FAC1_e+4	; FAC1 sign (b7)
   244                        
   245             0000005E   str_ln		.EQU FAC1_e	; string length
   246             0000005F   str_pl		.EQU FAC1_1	; string pointer low byte
  Sun Mar  3 2019 22:47                                                                                                    Page 5


   247             00000060   str_ph		.EQU FAC1_2	; string pointer high byte
   248                        
   249             00000060   des_pl		.EQU FAC1_2	; string descriptor pointer low byte
   250             00000061   des_ph		.EQU FAC1_3	; string descriptor pointer high byte
   251                        
   252             00000061   mids_l		.EQU FAC1_3	; MID$ string temp length byte
   253                        
   254             00000063   negnum		.EQU FAC1_e+5	; string to float eval -ve flag
   255             00000063   numcon		.EQU negnum	; series evaluation constant count
   256                        
   257             00000064   FAC1_o		.EQU negnum+1	; FAC1 overflow byte
   258                        
   259             00000065   FAC2_e		.EQU FAC1_o+1	; FAC2 exponent
   260             00000066   FAC2_1		.EQU FAC2_e+1	; FAC2 mantissa1
   261             00000067   FAC2_2		.EQU FAC2_e+2	; FAC2 mantissa2
   262             00000068   FAC2_3		.EQU FAC2_e+3	; FAC2 mantissa3
   263             00000069   FAC2_s		.EQU FAC2_e+4	; FAC2 sign (b7)
   264                        
   265             0000006A   FAC_sc		.EQU FAC2_e+5	; FAC sign comparison, Acc#1 vs #2
   266             0000006B   FAC1_r		.EQU FAC_sc+1	; FAC1 rounding byte
   267                        
   268             0000006A   ssptr_l		.EQU FAC_sc	; string start pointer low byte
   269             0000006B   ssptr_h		.EQU FAC1_r	; string start pointer high byte
   270                        
   271             0000006A   sdescr		.EQU FAC_sc	; string descriptor pointer
   272                        
   273             0000006C   csidx			.EQU FAC1_r+1	; line crunch save index
   274             0000006C   Asptl			.EQU csidx		; array size/pointer low byte
   275             0000006D   Aspth			.EQU csidx+1	; array size/pointer high byte
   276                        
   277             0000006C   Btmpl			.EQU Asptl		; BASIC pointer temp low byte
   278             0000006D   Btmph			.EQU Aspth		; BASIC pointer temp low byte
   279                        
   280             0000006C   Cptrl			.EQU Asptl		; BASIC pointer temp low byte
   281             0000006D   Cptrh			.EQU Aspth		; BASIC pointer temp low byte
   282                        
   283             0000006C   Sendl			.EQU Asptl		; BASIC pointer temp low byte
   284             0000006D   Sendh			.EQU Aspth		; BASIC pointer temp low byte
   285                        ;
   286                        ; CHRGET/CHRGOT routine now located in ROM
   287                        ; The two pointers below are accessed via ROM
   288                        ; Reduces Page zero usage by quite a bit with a minor performance penalty
   289                        ; CMOS addressing mode used, saves memory and execution time
   290                        ;
   291             0000006E   Bpntrl		.EQU Sendh+1	; BASIC execute (get byte) pointer low byte
   292             0000006F   Bpntrh		.EQU Bpntrl+1	; BASIC execute (get byte) pointer high byte
   293                        
   294             00000070   Rbyte4		.EQU Bpntrh+1	; extra PRNG byte
   295                        
   296             00000071   Rbyte1		.EQU Rbyte4+1  ; most significant PRNG byte
   297             00000072   Rbyte2		.EQU Rbyte4+2  ; middle PRNG byte
   298             00000073   Rbyte3		.EQU Rbyte4+3  ; least significant PRNG byte
   299                        
   300             00000074   Decss				.EQU Rbyte3+1	; number to decimal string start
   301             00000075   Decssp1			.EQU Decss+1	; number to decimal string start
   302             00000085   ZPLastByte	.EQU Decss+17
   303                        
   304                        ; Note:	C02BIOS uses Page Zero locations from $E0 - $FF
   305                        ;				C02Monitor uses Page Zero locations from $B0 - $DF
   306                        
   307                        ; token values needed for BASIC
   308                        
   309                        ; primary command tokens (can start a statement)
  Sun Mar  3 2019 22:47                                                                                                    Page 6


   310                        
   311             00000080   TK_END            .EQU $80             ; END token
   312             00000081   TK_FOR            .EQU TK_END+1        ; FOR token
   313             00000082   TK_NEXT           .EQU TK_FOR+1        ; NEXT token
   314             00000083   TK_DATA           .EQU TK_NEXT+1       ; DATA token
   315             00000084   TK_INPUT          .EQU TK_DATA+1       ; INPUT token
   316             00000085   TK_DIM            .EQU TK_INPUT+1      ; DIM token
   317             00000086   TK_READ           .EQU TK_DIM+1        ; READ token
   318             00000087   TK_LET            .EQU TK_READ+1       ; LET token
   319             00000088   TK_DEC            .EQU TK_LET+1        ; DEC token
   320             00000089   TK_GOTO           .EQU TK_DEC+1        ; GOTO token
   321             0000008A   TK_RUN            .EQU TK_GOTO+1       ; RUN token
   322             0000008B   TK_IF             .EQU TK_RUN+1        ; IF token
   323             0000008C   TK_RESTORE        .EQU TK_IF+1         ; RESTORE token
   324             0000008D   TK_GOSUB          .EQU TK_RESTORE+1    ; GOSUB token
   325             0000008E   TK_RETURN         .EQU TK_GOSUB+1      ; RETURN token
   326             0000008F   TK_REM            .EQU TK_RETURN+1     ; REM token
   327             00000090   TK_STOP           .EQU TK_REM+1        ; STOP token
   328             00000091   TK_ON             .EQU TK_STOP+1       ; ON token
   329             00000092   TK_NULL           .EQU TK_ON+1         ; NULL token
   330             00000093   TK_INC            .EQU TK_NULL+1       ; INC token
   331             00000094   TK_WAIT           .EQU TK_INC+1        ; WAIT token
   332             00000095   TK_LOAD           .EQU TK_WAIT+1       ; LOAD token
   333             00000096   TK_SAVE           .EQU TK_LOAD+1       ; SAVE token
   334             00000097   TK_DEF            .EQU TK_SAVE+1       ; DEF token
   335             00000098   TK_POKE           .EQU TK_DEF+1        ; POKE token
   336             00000099   TK_DOKE           .EQU TK_POKE+1       ; DOKE token
   337             0000009A   TK_CALL           .EQU TK_DOKE+1       ; CALL token
   338             0000009B   TK_DO             .EQU TK_CALL+1       ; DO token
   339             0000009C   TK_LOOP           .EQU TK_DO+1         ; LOOP token
   340             0000009D   TK_PRINT          .EQU TK_LOOP+1       ; PRINT token
   341             0000009E   TK_CONT           .EQU TK_PRINT+1      ; CONT token
   342             0000009F   TK_LIST           .EQU TK_CONT+1       ; LIST token
   343             000000A0   TK_CLEAR          .EQU TK_LIST+1       ; CLEAR token
   344             000000A1   TK_NEW            .EQU TK_CLEAR+1      ; NEW token
   345             000000A2   TK_WIDTH          .EQU TK_NEW+1        ; WIDTH token
   346             000000A3   TK_GET            .EQU TK_WIDTH+1      ; GET token
   347             000000A4   TK_SWAP           .EQU TK_GET+1        ; SWAP token
   348             000000A5   TK_BITSET         .EQU TK_SWAP+1       ; BITSET token
   349             000000A6   TK_BITCLR         .EQU TK_BITSET+1     ; BITCLR token
   350             000000A7   TK_EXIT           .EQU TK_BITCLR+1     ; EXIT token
   351                        
   352                        ; secondary command tokens, can't start a statement
   353                        
   354             000000A8   TK_TAB            .EQU TK_EXIT+1       ; TAB token
   355             000000A9   TK_ELSE           .EQU TK_TAB+1        ; ELSE token
   356             000000AA   TK_TO             .EQU TK_ELSE+1       ; TO token
   357             000000AB   TK_FN             .EQU TK_TO+1         ; FN token
   358             000000AC   TK_SPC            .EQU TK_FN+1         ; SPC token
   359             000000AD   TK_THEN           .EQU TK_SPC+1        ; THEN token
   360             000000AE   TK_NOT            .EQU TK_THEN+1       ; NOT token
   361             000000AF   TK_STEP           .EQU TK_NOT+1        ; STEP token
   362             000000B0   TK_UNTIL          .EQU TK_STEP+1       ; UNTIL token
   363             000000B1   TK_WHILE          .EQU TK_UNTIL+1      ; WHILE token
   364                        
   365                        ; operator tokens
   366                        
   367             000000B2   TK_PLUS           .EQU TK_WHILE+1      ; + token
   368             000000B3   TK_MINUS          .EQU TK_PLUS+1       ; - token
   369             000000B4   TK_MUL            .EQU TK_MINUS+1      ; * token
   370             000000B5   TK_DIV            .EQU TK_MUL+1        ; / token
   371             000000B6   TK_POWER          .EQU TK_DIV+1        ; ^ token
   372             000000B7   TK_AND            .EQU TK_POWER+1      ; AND token
  Sun Mar  3 2019 22:47                                                                                                    Page 7


   373             000000B8   TK_EOR            .EQU TK_AND+1        ; EOR token
   374             000000B9   TK_OR             .EQU TK_EOR+1        ; OR token
   375             000000BA   TK_RSHIFT         .EQU TK_OR+1         ; RSHIFT token
   376             000000BB   TK_LSHIFT         .EQU TK_RSHIFT+1     ; LSHIFT token
   377             000000BC   TK_GT             .EQU TK_LSHIFT+1     ; > token
   378             000000BD   TK_EQUAL          .EQU TK_GT+1         ; = token
   379             000000BE   TK_LT             .EQU TK_EQUAL+1      ; < token
   380                        
   381                        ; function tokens
   382                        
   383             000000BF   TK_SGN            .EQU TK_LT+1         ; SGN token
   384             000000C0   TK_INT            .EQU TK_SGN+1        ; INT token
   385             000000C1   TK_ABS            .EQU TK_INT+1        ; ABS token
   386             000000C2   TK_USR            .EQU TK_ABS+1        ; USR token
   387             000000C3   TK_FRE            .EQU TK_USR+1        ; FRE token
   388             000000C4   TK_POS            .EQU TK_FRE+1        ; POS token
   389             000000C5   TK_SQR            .EQU TK_POS+1        ; SQR token
   390             000000C6   TK_RND            .EQU TK_SQR+1        ; RND token
   391             000000C7   TK_LOG            .EQU TK_RND+1        ; LOG token
   392             000000C8   TK_EXP            .EQU TK_LOG+1        ; EXP token
   393             000000C9   TK_COS            .EQU TK_EXP+1        ; COS token
   394             000000CA   TK_SIN            .EQU TK_COS+1        ; SIN token
   395             000000CB   TK_TAN            .EQU TK_SIN+1        ; TAN token
   396             000000CC   TK_ATN            .EQU TK_TAN+1        ; ATN token
   397             000000CD   TK_PEEK           .EQU TK_ATN+1        ; PEEK token
   398             000000CE   TK_DEEK           .EQU TK_PEEK+1       ; DEEK token
   399             000000CF   TK_SADD           .EQU TK_DEEK+1       ; SADD token
   400             000000D0   TK_LEN            .EQU TK_SADD+1       ; LEN token
   401             000000D1   TK_STRS           .EQU TK_LEN+1        ; STR$ token
   402             000000D2   TK_VAL            .EQU TK_STRS+1       ; VAL token
   403             000000D3   TK_ASC            .EQU TK_VAL+1        ; ASC token
   404             000000D4   TK_UCASES         .EQU TK_ASC+1        ; UCASE$ token
   405             000000D5   TK_LCASES         .EQU TK_UCASES+1     ; LCASE$ token
   406             000000D6   TK_CHRS           .EQU TK_LCASES+1     ; CHR$ token
   407             000000D7   TK_HEXS           .EQU TK_CHRS+1       ; HEX$ token
   408             000000D8   TK_BINS           .EQU TK_HEXS+1       ; BIN$ token
   409             000000D9   TK_BITTST         .EQU TK_BINS+1       ; BITTST token
   410             000000DA   TK_MAX            .EQU TK_BITTST+1     ; MAX token
   411             000000DB   TK_MIN            .EQU TK_MAX+1        ; MIN token
   412             000000DC   TK_PI             .EQU TK_MIN+1        ; PI token
   413             000000DD   TK_TWOPI          .EQU TK_PI+1         ; TWOPI token
   414             000000DE   TK_VPTR           .EQU TK_TWOPI+1      ; VARPTR token
   415             000000DF   TK_LEFTS          .EQU TK_VPTR+1       ; LEFT$ token
   416             000000E0   TK_RIGHTS         .EQU TK_LEFTS+1      ; RIGHT$ token
   417             000000E1   TK_MIDS           .EQU TK_RIGHTS+1     ; MID$ token
   418                        
   419                        ; offsets from a base of X or Y
   420                        
   421             00000000   PLUS_0            .EQU $00       ; X or Y plus 0
   422             00000001   PLUS_1            .EQU $01       ; X or Y plus 1
   423             00000002   PLUS_2            .EQU $02       ; X or Y plus 2
   424             00000003   PLUS_3            .EQU $03       ; X or Y plus 3
   425                        
   426             00000014   STACK_RES         .EQU #20       ; reserved stack space
   427                        
   428             00000100   LAB_STAK          .EQU $0100     ; stack bottom, no offset
   429                        
   430             000001FE   LAB_SKFE          .EQU LAB_STAK+$FE
   431                                                         ; flushed stack address
   432             000001FF   LAB_SKFF          .EQU LAB_STAK+$FF
   433                                                         ; flushed stack address
   434                        
   435                        ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
  Sun Mar  3 2019 22:47                                                                                                    Page 8


   436                        ; the input buffer must not cross a page boundary and must not overlap with
   437                        ; program RAM pages!
   438                        
   439             00000400   Ibuffs            .EQU $0400     ;Start of input buffer
   440             0000047E   Ibuffe            .EQU $0400+$7E ; end of input buffer (127 bytes)
   441                        
   442             0000047F   ccflag            .EQU Ibuffe+1  ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   443             00000480   ccbyte            .EQU ccflag+1  ; BASIC CTRL-C byte
   444             00000481   ccnull            .EQU ccbyte+1  ; BASIC CTRL-C byte timeout
   445                        
   446             00000482   VEC_CC            .EQU ccnull+1  ; ctrl c check vector
   447                        
   448             00000484   VEC_IN            .EQU VEC_CC+2  ; input vector
   449             00000486   VEC_OUT           .EQU VEC_IN+2  ; output vector
   450             00000488   VEC_LD            .EQU VEC_OUT+2 ; load vector
   451             0000048A   VEC_SV            .EQU VEC_LD+2  ; save vector
   452             0000048C   VEC_EXIT          .EQU VEC_SV+2  ; exit vector
   453                        
   454             00000800   Ram_base          .EQU $0800     ; start of user RAM (1st 2KB used/reserved)
   455             00008000   Ram_top           .EQU $8000     ; end of user RAM+1 ($8000 is start of ROM)
   456                        
   457                        ; The start address can be changed, noting the BIOS/Monitor locations
   458                        
   459                              .ORG    $B000	             ; Start of Basic in ROM
   460                                                         ; C02Monitor starts at $E000
   461                                                         ; C02BIOS starts at $F800
   462                        
   463                        ; BASIC cold start entry point
   464                        
   465                        ; new page $04 initialisation, copy ROM data to RAM
   466                        ; consists of the vectors Input/Output/Load/Save/Exit
   467                        ; and Control-C flags, pointers
   468                        
   469                        LAB_COLD
   470 00:B000: A2 0E              LDX   #PG4_TABE-PG4_TABS-1 ; byte count-1
   471                        LAB_2D13
   472 00:B002: BD D2 CF           LDA   PG4_TABS,X           ; get byte
   473 00:B005: 9D 7F 04           STA   ccflag,X             ; store in page 4
   474 00:B008: CA                 DEX                        ; decrement count
   475 00:B009: 10 F7              BPL   LAB_2D13             ; loop if not done
   476                        
   477 00:B00B: 9A                 TXS                        ; reset stack pointer (X Reg = $FF from above)
   478 00:B00C: 86 3A              STX   Clineh               ; set current line high byte (set immediate mode)
   479                        
   480 00:B00E: A9 4C              LDA   #$4C                 ; code for JMP
   481 00:B010: 85 53              STA   Fnxjmp               ; save for jump vector for functions
   482                        
   483                        ; copy block from StrTab to $0000 - $0012
   484                        
   485                        LAB_GMEM
   486 00:B012: A2 0B              LDX   #EndTab-StrTab-1  ; set byte count-1
   487                        TabLoop
   488 00:B014: BD E1 CF           LDA   StrTab,X          ; get byte from table
   489 00:B017: 95 00              STA   PLUS_0,X          ; save byte in page zero
   490 00:B019: CA                 DEX                     ; decrement count
   491 00:B01A: 10 F8              BPL   TabLoop           ; loop until done
   492                        
   493                        ; set-up start values
   494                        
   495 00:B01C: 64 64              STZ   FAC1_o            ; clear FAC1 overflow byte
   496 00:B01E: 64 19              STZ   last_sh           ; clear descriptor stack top item pointer high byte
   497                        
   498 00:B020: A9 0E              LDA   #$0E              ; set default tab size
  Sun Mar  3 2019 22:47                                                                                                    Page 9


   499 00:B022: 85 16              STA   TabSiz            ; save it
   500 00:B024: A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
   501 00:B026: 85 52              STA   g_step            ; save it
   502 00:B028: A2 1A              LDX   #des_sk           ; descriptor stack start
   503 00:B02A: 86 17              STX   next_s            ; set descriptor stack pointer
   504                        
   505                              ; bypass user memory prompt, just test, show and go
   506                              ; we get here with Itempl/h = Ram_base
   507                        
   508                        LAB_2D93
   509 00:B02C: A9 00              LDA   #$00              ; get all bits off
   510 00:B02E: 92 0A              STA   (Itempl)          ; clear tested memory byte
   511                        
   512 00:B030: E6 0A              INC   Itempl            ; increment temporary integer low byte
   513 00:B032: D0 08              BNE   LAB_2D99          ; branch if no overflow
   514                        
   515 00:B034: E6 0B              INC   Itemph            ; increment temporary integer high byte
   516 00:B036: A5 0B              LDA   Itemph            ; get high byte
   517 00:B038: C9 80              CMP   #>Ram_top         ; compare with top of RAM+1
   518 00:B03A: F0 0F              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
   519                        
   520                        LAB_2D99
   521 00:B03C: A9 55              LDA   #$55              ; set test byte
   522 00:B03E: 92 0A              STA   (Itempl)          ; save via temporary integer
   523 00:B040: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   524 00:B042: D0 07              BNE   LAB_2DB6          ; branch if fail
   525                        
   526 00:B044: 0A                 ASL                     ; shift test byte left (now $AA)
   527 00:B045: 92 0A              STA   (Itempl)          ; save via temporary integer
   528 00:B047: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   529 00:B049: F0 E1              BEQ   LAB_2D93          ; if ok go do next byte
   530                        
   531                        LAB_2DB6
   532 00:B04B: A5 0A              LDA   Itempl            ; get temporary integer low byte
   533 00:B04D: A4 0B              LDY   Itemph            ; get temporary integer high byte ($00)
   534                        
   535                        MEM_OK
   536 00:B04F: 85 37              STA   Ememl             ; set end of mem low byte
   537 00:B051: 84 38              STY   Ememh             ; set end of mem high byte
   538 00:B053: 85 33              STA   Sstorl            ; set bottom of string space low byte
   539 00:B055: 84 34              STY   Sstorh            ; set bottom of string space high byte
   540                        
   541 00:B057: A0 00              LDY   #<Ram_base        ; set start addr low byte
   542 00:B059: A2 08              LDX   #>Ram_base        ; set start addr high byte
   543 00:B05B: 84 2B              STY   Smeml             ; save start of mem low byte
   544 00:B05D: 86 2C              STX   Smemh             ; save start of mem high byte
   545                        
   546 00:B05F: 98                 TYA                     ; clear A ($00)
   547 00:B060: 91 2B              STA   (Smeml),Y         ; clear first byte
   548 00:B062: E6 2B              INC   Smeml             ; increment start of mem low byte
   549                        
   550                        LAB_2E05
   551 00:B064: 20 2E B8           JSR   LAB_CRLF          ; print CR/LF
   552 00:B067: 20 1B B3           JSR   LAB_1463          ; do "NEW" and "CLEAR"
   553 00:B06A: A5 37              LDA   Ememl             ; get end of mem low byte
   554 00:B06C: 38                 SEC                     ; set carry for subtract
   555 00:B06D: E5 2B              SBC   Smeml             ; subtract start of mem low byte
   556 00:B06F: AA                 TAX                     ; copy to X
   557 00:B070: A5 38              LDA   Ememh             ; get end of mem high byte
   558 00:B072: E5 2C              SBC   Smemh             ; subtract start of mem high byte
   559 00:B074: 20 EB C9           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
   560 00:B077: A9 ED              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
   561 00:B079: A0 CF              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
  Sun Mar  3 2019 22:47                                                                                                    Page 10


   562 00:B07B: 20 6F B8           JSR   LAB_18C3          ; print null terminated string from memory
   563 00:B07E: A9 24              LDA   #<LAB_1274        ; warm start vector low byte
   564 00:B080: A0 B1              LDY   #>LAB_1274        ; warm start vector high byte
   565 00:B082: 85 01              STA   Wrmjpl            ; save warm start vector low byte
   566 00:B084: 84 02              STY   Wrmjph            ; save warm start vector high byte
   567 00:B086: 6C 01 00           JMP   (Wrmjpl)          ; jump to warm start
   568                        
   569                        ; open up space in memory
   570                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   571                        
   572                        ; Nbendl,Nbendh - new block end address (A/Y)
   573                        ; Obendl,Obendh - old block end address
   574                        ; Ostrtl,Ostrth - old block start address
   575                        
   576                        ; returns with ..
   577                        
   578                        ; Nbendl,Nbendh - new block start address (high byte - $100)
   579                        ; Obendl,Obendh - old block start address (high byte - $100)
   580                        ; Ostrtl,Ostrth - old block start address (unchanged)
   581                        
   582                        LAB_11CF
   583 00:B089: 20 D6 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
   584                                                      ; addr to check is in AY (low/high)
   585 00:B08C: 85 31              STA   Earryl            ; save new array mem end low byte
   586 00:B08E: 84 32              STY   Earryh            ; save new array mem end high byte
   587                        
   588                        ; open up space in memory
   589                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   590                        ; don't set array end
   591                        
   592                        LAB_11D6
   593 00:B090: 38                 SEC                     ; set carry for subtract
   594 00:B091: A5 58              LDA   Obendl            ; get block end low byte
   595 00:B093: E5 5C              SBC   Ostrtl            ; subtract block start low byte
   596 00:B095: A8                 TAY                     ; copy MOD(block length/$100) byte to Y
   597 00:B096: A5 59              LDA   Obendh            ; get block end high byte
   598 00:B098: E5 5D              SBC   Ostrth            ; subtract block start high byte
   599 00:B09A: AA                 TAX                     ; copy block length high byte to X
   600 00:B09B: E8                 INX                     ; +1 to allow for count=0 exit
   601 00:B09C: 98                 TYA                     ; copy block length low byte to A
   602 00:B09D: F0 24              BEQ   LAB_120A          ; branch if length low byte=0
   603                        
   604                                                      ; block is (X-1)*256+Y bytes, do the Y bytes first
   605 00:B09F: 38                 SEC                     ; set carry for add + 1, two's complement
   606 00:B0A0: 49 FF              EOR   #$FF              ; invert low byte for subtract
   607 00:B0A2: 65 58              ADC   Obendl            ; add block end low byte
   608 00:B0A4: 85 58              STA   Obendl            ; save corrected old block end low byte
   609 00:B0A6: B0 03              BCS   LAB_11F3          ; branch if no underflow
   610 00:B0A8: C6 59              DEC   Obendh            ; else decrement block end high byte
   611 00:B0AA: 38                 SEC                     ; set carry for add + 1, two's complement
   612                        LAB_11F3
   613 00:B0AB: 98                 TYA                     ; get MOD(block length/$100) byte
   614 00:B0AC: 49 FF              EOR   #$FF              ; invert low byte for subtract
   615 00:B0AE: 65 56              ADC   Nbendl            ; add destination end low byte
   616 00:B0B0: 85 56              STA   Nbendl            ; save modified new block end low byte
   617 00:B0B2: B0 08              BCS   LAB_1203          ; branch if no underflow
   618 00:B0B4: C6 57              DEC   Nbendh            ; else decrement block end high byte
   619 00:B0B6: 80 04              BRA   LAB_1203          ; branch always
   620                        
   621                        LAB_11FF
   622 00:B0B8: B1 58              LDA   (Obendl),Y        ; get byte from source
   623 00:B0BA: 91 56              STA   (Nbendl),Y        ; copy byte to destination
   624                        LAB_1203
  Sun Mar  3 2019 22:47                                                                                                    Page 11


   625 00:B0BC: 88                 DEY                     ; decrement index
   626 00:B0BD: D0 F9              BNE   LAB_11FF          ; loop until Y=0
   627                                                      ; now do Y=0 indexed byte
   628 00:B0BF: B1 58              LDA   (Obendl),Y        ; get byte from source
   629 00:B0C1: 91 56              STA   (Nbendl),Y        ; save byte to destination
   630                        LAB_120A
   631 00:B0C3: C6 59              DEC   Obendh            ; decrement source pointer high byte
   632 00:B0C5: C6 57              DEC   Nbendh            ; decrement destination pointer high byte
   633 00:B0C7: CA                 DEX                     ; decrement block count
   634 00:B0C8: D0 F2              BNE   LAB_1203          ; loop until count = $0
   635 00:B0CA: 60                 RTS
   636                        
   637                        ; check room on stack for A bytes
   638                        ; stack too deep? do OM error
   639                        
   640                        LAB_1212                      ; patched for stack floor
   641 00:B0CB: 18                 CLC                     ; prep ADC
   642 00:B0CC: 69 14              ADC   #STACK_RES        ; stack pointer lower limit before interrupts
   643 00:B0CE: 85 2A              STA   TempB             ; save result in temp byte
   644 00:B0D0: BA                 TSX                     ; copy stack
   645 00:B0D1: E4 2A              CPX   TempB             ; compare new "limit" with stack
   646 00:B0D3: 90 2F              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
   647 00:B0D5: 60                 RTS
   648                        
   649                        ; check available memory, "Out of memory" error if no room
   650                        ; addr to check is in AY (low/high)
   651                        
   652                        LAB_121F
   653 00:B0D6: C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
   654 00:B0D8: 90 29              BCC   LAB_124B          ; if less then exit (is ok)
   655                        
   656 00:B0DA: D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
   657                        
   658                                                      ; high byte was =, now do low byte
   659 00:B0DC: C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
   660 00:B0DE: 90 23              BCC   LAB_124B          ; if less then exit (is ok)
   661                        
   662                                                      ; addr is > string storage ptr (oops!)
   663                        LAB_1229
   664 00:B0E0: 48                 PHA                     ; push addr low byte
   665 00:B0E1: A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
   666 00:B0E3: 98                 TYA                     ; copy addr high byte (to push on stack)
   667                        
   668                                                      ; save misc numeric work area
   669                        LAB_122D
   670 00:B0E4: 48                 PHA                     ; push byte
   671 00:B0E5: B5 55              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
   672 00:B0E7: CA                 DEX                     ; decrement index
   673 00:B0E8: 10 FA              BPL   LAB_122D          ; loop until all done
   674                        
   675 00:B0EA: 20 6A C1           JSR   LAB_GARB          ; garbage collection routine
   676                        
   677                                                      ; restore misc numeric work area
   678 00:B0ED: A2 00              LDX   #$00              ; clear the index to restore bytes
   679                        LAB_1238
   680 00:B0EF: 68                 PLA                     ; pop byte
   681 00:B0F0: 95 56              STA   Adatal,X          ; save byte to Adatal to expneg
   682 00:B0F2: E8                 INX                     ; increment index
   683 00:B0F3: E0 08              CPX   #$08              ; compare with end + 1
   684 00:B0F5: 30 F8              BMI   LAB_1238          ; loop if more to do
   685                        
   686 00:B0F7: 7A                 PLY                     ; pop addr high byte
   687 00:B0F8: 68                 PLA                     ; pop addr low byte
  Sun Mar  3 2019 22:47                                                                                                    Page 12


   688 00:B0F9: C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
   689 00:B0FB: 90 06              BCC   LAB_124B          ; if less then exit (is ok)
   690                        
   691 00:B0FD: D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
   692                        
   693                                                      ; high byte was =, now do low byte
   694 00:B0FF: C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
   695 00:B101: B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
   696                                                      ; ok exit, carry clear
   697                        LAB_124B
   698 00:B103: 60                 RTS
   699                        
   700                        ; do "Out of memory" error then warm start
   701                        
   702                        LAB_OMER
   703 00:B104: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
   704                        
   705                        ; do error #X, then warm start
   706                        
   707                        LAB_XERR
   708 00:B106: 20 2E B8           JSR   LAB_CRLF          ; print CR/LF
   709                        
   710 00:B109: BD 20 D5           LDA   LAB_BAER,X        ; get error message pointer low byte
   711 00:B10C: BC 21 D5           LDY   LAB_BAER+1,X      ; get error message pointer high byte
   712 00:B10F: 20 6F B8           JSR   LAB_18C3          ; print null terminated string from memory
   713                        
   714 00:B112: 20 54 B3           JSR   LAB_1491          ; flush stack and clear continue flag
   715 00:B115: A9 5D              LDA   #<LAB_EMSG        ; point to " Error" low addr
   716 00:B117: A0 D6              LDY   #>LAB_EMSG        ; point to " Error" high addr
   717                        LAB_1269
   718 00:B119: 20 6F B8           JSR   LAB_18C3          ; print null terminated string from memory
   719 00:B11C: A4 3A              LDY   Clineh            ; get current line high byte
   720 00:B11E: C8                 INY                     ; increment it
   721 00:B11F: F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
   722                        
   723                                                      ; else print line number
   724 00:B121: 20 E0 C9           JSR   LAB_2953          ; print " in line [LINE #]"
   725                        
   726                        ; BASIC warm start entry point
   727                        ; wait for Basic command
   728                        
   729                        LAB_1274
   730 00:B124: A9 6E              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
   731 00:B126: A0 D6              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
   732                        
   733 00:B128: 20 6F B8           JSR   LAB_18C3          ; go do print string
   734                        
   735                        ; wait for Basic command (no "Ready")
   736                        
   737                        LAB_127D
   738 00:B12B: 20 12 B2           JSR   LAB_1357          ; call for BASIC input
   739                        LAB_1280
   740 00:B12E: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
   741 00:B130: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
   742 00:B132: 20 AB CF           JSR   LAB_GBYT          ; scan memory
   743 00:B135: F0 F4              BEQ   LAB_127D          ; loop while null
   744                        
   745                        ; got to interpret input line now ..
   746                        
   747 00:B137: A2 FF              LDX   #$FF              ; current line to null value
   748 00:B139: 86 3A              STX   Clineh            ; set current line high byte
   749 00:B13B: 90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
   750                        
  Sun Mar  3 2019 22:47                                                                                                    Page 13


   751                                                      ; no line number .. immediate mode
   752 00:B13D: 20 43 B2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   753 00:B140: 4C B5 B4           JMP   LAB_15F6          ; go scan and interpret code
   754                        
   755                        ; handle new BASIC line
   756                        
   757                        LAB_1295
   758 00:B143: 20 FC B6           JSR   LAB_GFPN          ; get fixed-point number into temp integer
   759 00:B146: 20 43 B2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   760 00:B149: 84 0F              STY   Ibptr             ; save index pointer to end of crunched line
   761 00:B14B: 20 EF B2           JSR   LAB_SSLN          ; search BASIC for temp integer line number
   762 00:B14E: 90 44              BCC   LAB_12E6          ; branch if not found
   763                        
   764                                                      ; aroooogah! line # already exists! delete it
   765 00:B150: A0 01              LDY   #$01              ; set index to next line pointer high byte
   766 00:B152: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
   767 00:B154: 85 24              STA   ut1_ph            ; save it
   768 00:B156: A5 2D              LDA   Svarl             ; get start of vars low byte
   769 00:B158: 85 23              STA   ut1_pl            ; save it
   770 00:B15A: A5 5D              LDA   Baslnh            ; get found line pointer high byte
   771 00:B15C: 85 26              STA   ut2_ph            ; save it
   772 00:B15E: A5 5C              LDA   Baslnl            ; get found line pointer low byte
   773 00:B160: 88                 DEY                     ; decrement index
   774 00:B161: F1 5C              SBC   (Baslnl),Y        ; subtract next line pointer low byte
   775 00:B163: 18                 CLC                     ; clear carry for add
   776 00:B164: 65 2D              ADC   Svarl             ; add start of vars low byte
   777 00:B166: 85 2D              STA   Svarl             ; save new start of vars low byte
   778 00:B168: 85 25              STA   ut2_pl            ; save destination pointer low byte
   779 00:B16A: A5 2E              LDA   Svarh             ; get start of vars high byte
   780 00:B16C: 69 FF              ADC   #$FF              ; -1 + carry
   781 00:B16E: 85 2E              STA   Svarh             ; save start of vars high byte
   782 00:B170: E5 5D              SBC   Baslnh            ; subtract found line pointer high byte
   783 00:B172: AA                 TAX                     ; copy to block count
   784 00:B173: 38                 SEC                     ; set carry for subtract
   785 00:B174: A5 5C              LDA   Baslnl            ; get found line pointer low byte
   786 00:B176: E5 2D              SBC   Svarl             ; subtract start of vars low byte
   787 00:B178: A8                 TAY                     ; copy to bytes in first block count
   788 00:B179: B0 03              BCS   LAB_12D0          ; branch if overflow
   789                        
   790 00:B17B: E8                 INX                     ; increment block count (correct for =0 loop exit)
   791 00:B17C: C6 26              DEC   ut2_ph            ; decrement destination high byte
   792                        LAB_12D0
   793 00:B17E: 18                 CLC                     ; clear carry for add
   794 00:B17F: 65 23              ADC   ut1_pl            ; add source pointer low byte
   795 00:B181: 90 03              BCC   LAB_12D8          ; branch if no overflow
   796                        
   797 00:B183: C6 24              DEC   ut1_ph            ; else decrement source pointer high byte
   798 00:B185: 18                 CLC                     ; clear carry
   799                        
   800                                                      ; close up memory to delete old line
   801                        LAB_12D8
   802 00:B186: B1 23              LDA   (ut1_pl),Y        ; get byte from source
   803 00:B188: 91 25              STA   (ut2_pl),Y        ; copy to destination
   804 00:B18A: C8                 INY                     ; increment index
   805 00:B18B: D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
   806                        
   807 00:B18D: E6 24              INC   ut1_ph            ; increment source pointer high byte
   808 00:B18F: E6 26              INC   ut2_ph            ; increment destination pointer high byte
   809 00:B191: CA                 DEX                     ; decrement block count
   810 00:B192: D0 F2              BNE   LAB_12D8          ; loop until all done
   811                        
   812                                                      ; got new line in buffer and no existing same #
   813                        LAB_12E6
  Sun Mar  3 2019 22:47                                                                                                    Page 14


   814 00:B194: AD 00 04           LDA   Ibuffs            ; get byte from start of input buffer
   815 00:B197: F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
   816                        
   817                                                      ; got new line and it isn't empty line
   818 00:B199: A5 37              LDA   Ememl             ; get end of mem low byte
   819 00:B19B: A4 38              LDY   Ememh             ; get end of mem high byte
   820 00:B19D: 85 33              STA   Sstorl            ; set bottom of string space low byte
   821 00:B19F: 84 34              STY   Sstorh            ; set bottom of string space high byte
   822 00:B1A1: A5 2D              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
   823 00:B1A3: 85 58              STA   Obendl            ; save old block end low byte
   824 00:B1A5: A4 2E              LDY   Svarh             ; get start of vars high byte (end of BASIC)
   825 00:B1A7: 84 59              STY   Obendh            ; save old block end high byte
   826 00:B1A9: 65 0F              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
   827 00:B1AB: 90 01              BCC   LAB_1301          ; branch if no overflow from add
   828 00:B1AD: C8                 INY                     ; else increment high byte
   829                        LAB_1301
   830 00:B1AE: 85 56              STA   Nbendl            ; save new block end low byte (move to, low byte)
   831 00:B1B0: 84 57              STY   Nbendh            ; save new block end high byte
   832 00:B1B2: 20 89 B0           JSR   LAB_11CF          ; open up space in memory
   833                                                      ; old start pointer Ostrtl,Ostrth set by the find line call
   834 00:B1B5: A5 31              LDA   Earryl            ; get array mem end low byte
   835 00:B1B7: A4 32              LDY   Earryh            ; get array mem end high byte
   836 00:B1B9: 85 2D              STA   Svarl             ; save start of vars low byte
   837 00:B1BB: 84 2E              STY   Svarh             ; save start of vars high byte
   838 00:B1BD: A4 0F              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
   839 00:B1BF: 88                 DEY                     ; adjust for loop type
   840                        LAB_1311
   841 00:B1C0: B9 FC 03           LDA   Ibuffs-4,Y        ; get byte from crunched line
   842 00:B1C3: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   843 00:B1C5: 88                 DEY                     ; decrement count
   844 00:B1C6: C0 03              CPY   #$03              ; compare with first byte-1
   845 00:B1C8: D0 F6              BNE   LAB_1311          ; continue while count <> 3
   846                        
   847 00:B1CA: A5 0B              LDA   Itemph            ; get line # high byte
   848 00:B1CC: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   849 00:B1CE: 88                 DEY                     ; decrement count
   850 00:B1CF: A5 0A              LDA   Itempl            ; get line # low byte
   851 00:B1D1: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   852 00:B1D3: 88                 DEY                     ; decrement count
   853 00:B1D4: A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
   854                                                      ; byte then a zero already here would stop the chain rebuild
   855                                                      ; as it would think it was the [EOT] marker.
   856 00:B1D6: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   857                        
   858                        LAB_1319
   859 00:B1D8: 20 30 B3           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
   860 00:B1DB: A6 2B              LDX   Smeml             ; get start of mem low byte
   861 00:B1DD: A5 2C              LDA   Smemh             ; get start of mem high byte
   862 00:B1DF: A0 01              LDY   #$01              ; index to high byte of next line pointer
   863                        LAB_1325
   864 00:B1E1: 86 23              STX   ut1_pl            ; set line start pointer low byte
   865 00:B1E3: 85 24              STA   ut1_ph            ; set line start pointer high byte
   866 00:B1E5: B1 23              LDA   (ut1_pl),Y        ; get it
   867 00:B1E7: F0 18              BEQ   LAB_133E          ; exit if end of program
   868                        
   869                        ; rebuild chaining of Basic lines
   870                        
   871 00:B1E9: A0 04              LDY   #$04              ; point to first code byte of line
   872                                                      ; there is always 1 byte + [EOL] as null entries are deleted
   873                        LAB_1330
   874 00:B1EB: C8                 INY                     ; next code byte
   875 00:B1EC: B1 23              LDA   (ut1_pl),Y        ; get byte
   876 00:B1EE: D0 FB              BNE   LAB_1330          ; loop if not [EOL]
  Sun Mar  3 2019 22:47                                                                                                    Page 15


   877                        
   878 00:B1F0: 38                 SEC                     ; set carry for add + 1
   879 00:B1F1: 98                 TYA                     ; copy end index
   880 00:B1F2: 65 23              ADC   ut1_pl            ; add to line start pointer low byte
   881 00:B1F4: AA                 TAX                     ; copy to X
   882 00:B1F5: A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
   883 00:B1F7: 91 23              STA   (ut1_pl),Y        ; set next line pointer low byte
   884 00:B1F9: 98                 TYA                     ; clear A
   885 00:B1FA: 65 24              ADC   ut1_ph            ; add line start pointer high byte + carry
   886 00:B1FC: C8                 INY                     ; increment index to high byte
   887 00:B1FD: 91 23              STA   (ut1_pl),Y        ; save next line pointer low byte
   888 00:B1FF: 80 E0              BRA   LAB_1325          ; go do next line, branch always, carry clear
   889                        
   890                        LAB_133E
   891 00:B201: 4C 2B B1           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
   892                        
   893                        ; print "? " and get BASIC input
   894                        
   895                        LAB_INLN
   896 00:B204: 20 88 B8           JSR   LAB_18E3          ; print "?" character
   897 00:B207: 20 84 B8           JSR   LAB_18E0          ; print " "
   898 00:B20A: 80 06              BRA   LAB_1357          ; call for BASIC input and return
   899                        
   900                        ; receive line from keyboard
   901                        
   902                                                      ; $08 as delete key (BACKSPACE on standard keyboard)
   903                        LAB_134B
   904 00:B20C: 20 8A B8           JSR   LAB_PRNA          ; go print the character
   905 00:B20F: CA                 DEX                     ; decrement the buffer counter (delete)
   906 00:B210: 80 02              BRA   LAB_1359          ; branch over next instruction, save 1 clock cycle
   907                        
   908                        ; call for BASIC input (main entry point)
   909                        
   910                        LAB_1357
   911 00:B212: A2 00              LDX   #$00              ; clear BASIC line buffer pointer
   912                        LAB_1359
   913 00:B214: 20 C3 CF           JSR   V_INPT            ; call scan input device
   914 00:B217: 90 FB              BCC   LAB_1359          ; loop if no byte
   915                        
   916 00:B219: F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
   917                        
   918 00:B21B: C9 07              CMP   #$07              ; compare with [BELL]
   919 00:B21D: F0 10              BEQ   LAB_1378          ; branch if [BELL]
   920                        
   921 00:B21F: C9 0D              CMP   #$0D              ; compare with [CR]
   922 00:B221: F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
   923                        
   924 00:B223: E0 00              CPX   #$00              ; compare pointer with $00
   925 00:B225: D0 04              BNE   LAB_1374          ; branch if not empty
   926                        
   927                        ; next two lines ignore any non print character and [SPACE] if input buffer empty
   928                        
   929 00:B227: C9 21              CMP   #$21              ; compare with [SP]+1
   930 00:B229: 90 E9              BCC   LAB_1359          ; if < ignore character
   931                        
   932                        LAB_1374
   933 00:B22B: C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
   934 00:B22D: F0 DD              BEQ   LAB_134B          ; go delete last character
   935                        
   936                        LAB_1378
   937 00:B22F: E0 7E              CPX   #Ibuffe-Ibuffs    ; compare character count with max
   938 00:B231: B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
   939                        
  Sun Mar  3 2019 22:47                                                                                                    Page 16


   940 00:B233: 9D 00 04           STA   Ibuffs,X          ; else store in buffer
   941 00:B236: E8                 INX                     ; increment pointer
   942                        LAB_137F
   943 00:B237: 20 8A B8           JSR   LAB_PRNA          ; go print the character
   944 00:B23A: 80 D8              BRA   LAB_1359          ; always loop for next character
   945                        
   946                        LAB_1384
   947 00:B23C: 4C 27 B8           JMP   LAB_1866          ; do CR/LF exit to BASIC
   948                        
   949                        ; announce buffer full
   950                        
   951                        LAB_138E
   952 00:B23F: A9 07              LDA   #$07              ; [BELL] character into A
   953 00:B241: 80 F4              BRA   LAB_137F          ; go print the [BELL] but ignore input character
   954                                                      ; branch always
   955                        
   956                        ; crunch keywords into Basic tokens
   957                        ; position independent buffer version ..
   958                        ; faster, dictionary search version ....
   959                        
   960                        LAB_13A6
   961 00:B243: A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
   962 00:B245: 38                 SEC                     ; set carry for subtract
   963 00:B246: A5 6E              LDA   Bpntrl            ; get basic execute pointer low byte
   964 00:B248: E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
   965 00:B24A: AA                 TAX                     ; copy result to X (index past line # if any)
   966 00:B24B: 86 12              STX   Oquote            ; clear open quote/DATA flag
   967                        LAB_13AC
   968 00:B24D: BD 00 04           LDA   Ibuffs,X          ; get byte from input buffer
   969 00:B250: F0 51              BEQ   LAB_13EC          ; if null save byte then exit
   970                        
   971 00:B252: C9 5F              CMP   #'_'              ; compare with "_"
   972 00:B254: B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
   973                        
   974 00:B256: C9 3C              CMP   #'<'              ; compare with "<"
   975 00:B258: B0 0E              BCS   LAB_13CC          ; if >= go crunch now
   976                        
   977 00:B25A: C9 30              CMP   #'0'              ; compare with "0"
   978 00:B25C: B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
   979                        
   980 00:B25E: 85 0E              STA   Scnquo            ; save buffer byte as search character
   981 00:B260: C9 22              CMP   #$22              ; is it quote character?
   982 00:B262: F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
   983                        
   984 00:B264: C9 2A              CMP   #'*'              ; compare with "*"
   985 00:B266: 90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
   986                                                      ; else crunch now
   987                        LAB_13CC
   988 00:B268: 24 12              BIT   Oquote            ; get open quote/DATA token flag
   989 00:B26A: 70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
   990                                                      ; go save byte then continue crunching
   991 00:B26C: 86 2A              STX   TempB             ; save buffer read index
   992 00:B26E: 84 6C              STY   csidx             ; copy buffer save index
   993 00:B270: A0 A8              LDY   #<TAB_1STC        ; get keyword first character table low address
   994 00:B272: 84 25              STY   ut2_pl            ; save pointer low byte
   995 00:B274: A0 D1              LDY   #>TAB_1STC        ; get keyword first character table high address
   996 00:B276: 84 26              STY   ut2_ph            ; save pointer high byte
   997 00:B278: A0 00              LDY   #$00              ; clear table pointer
   998                        
   999                        LAB_13D0
  1000 00:B27A: D1 25              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
  1001 00:B27C: F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
  1002                        
  Sun Mar  3 2019 22:47                                                                                                    Page 17


  1003 00:B27E: 90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
  1004                                                      ; Y and save to crunched
  1005                        
  1006 00:B280: C8                 INY                     ; else increment pointer
  1007 00:B281: 80 F7              BRA   LAB_13D0          ; and loop (branch always)
  1008                        
  1009                        ; have matched first character of some keyword
  1010                        
  1011                        LAB_13D1
  1012 00:B283: 98                 TYA                     ; copy matching index
  1013 00:B284: 0A                 ASL                     ; *2 (bytes per pointer)
  1014 00:B285: AA                 TAX                     ; copy to new index
  1015 00:B286: BD C6 D1           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
  1016 00:B289: 85 25              STA   ut2_pl            ; save pointer low byte
  1017 00:B28B: BD C7 D1           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
  1018 00:B28E: 85 26              STA   ut2_ph            ; save pointer high byte
  1019 00:B290: A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
  1020 00:B292: A6 2A              LDX   TempB             ; restore buffer read index
  1021                        
  1022                        LAB_13D6
  1023 00:B294: C8                 INY                     ; next table byte
  1024 00:B295: B1 25              LDA   (ut2_pl),Y        ; get byte from table
  1025                        LAB_13D8
  1026 00:B297: 30 08              BMI   LAB_13EA          ; all bytes matched so go save token
  1027 00:B299: E8                 INX                     ; next buffer byte
  1028 00:B29A: DD 00 04           CMP   Ibuffs,X          ; compare with byte from input buffer
  1029 00:B29D: F0 F5              BEQ   LAB_13D6          ; go compare next if match
  1030 00:B29F: 80 2B              BRA   LAB_1417          ; branch if >< (not found keyword)
  1031                        
  1032                        LAB_13EA
  1033 00:B2A1: A4 6C              LDY   csidx             ; restore save index
  1034                                                      ; save crunched to output
  1035                        LAB_13EC
  1036 00:B2A3: E8                 INX                     ; increment buffer index (to next input byte)
  1037 00:B2A4: C8                 INY                     ; increment save index (to next output byte)
  1038 00:B2A5: 99 00 04           STA   Ibuffs,Y          ; save byte to output
  1039 00:B2A8: C9 00              CMP   #$00              ; set the flags, set carry
  1040 00:B2AA: F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
  1041                        
  1042                                                      ; A holds token or byte here
  1043 00:B2AC: E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
  1044 00:B2AE: F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
  1045                        
  1046                                                      ; A now holds token-$3A
  1047 00:B2B0: C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
  1048 00:B2B2: D0 02              BNE   LAB_1401          ; branch if not DATA
  1049                        
  1050                                                      ; token was : or DATA
  1051                        LAB_13FF
  1052 00:B2B4: 85 12              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
  1053                        LAB_1401
  1054 00:B2B6: 49 55              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
  1055 00:B2B8: D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
  1056 00:B2BA: 85 0E              STA   Asrch             ; else was REM so set search for [EOL]
  1057                                                      ; loop for REM, "..." etc.
  1058                        LAB_1408
  1059 00:B2BC: BD 00 04           LDA   Ibuffs,X          ; get byte from input buffer
  1060 00:B2BF: F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
  1061 00:B2C1: C5 0E              CMP   Asrch             ; compare with stored character
  1062 00:B2C3: F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
  1063                                                      ; entry for copy string in quotes, don't crunch
  1064                        LAB_1410
  1065 00:B2C5: C8                 INY                     ; increment buffer save index
  Sun Mar  3 2019 22:47                                                                                                    Page 18


  1066 00:B2C6: 99 00 04           STA   Ibuffs,Y          ; save byte to output
  1067 00:B2C9: E8                 INX                     ; increment buffer read index
  1068 00:B2CA: D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
  1069                                                      ; not found keyword this go
  1070                        LAB_1417
  1071 00:B2CC: A6 2A              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
  1072                        
  1073                                                      ; now find the end of this word in the table
  1074                        LAB_141B
  1075 00:B2CE: B1 25              LDA   (ut2_pl),Y        ; get table byte
  1076 00:B2D0: 08                 PHP                     ; save status
  1077 00:B2D1: C8                 INY                     ; increment table index
  1078 00:B2D2: 28                 PLP                     ; restore byte status
  1079 00:B2D3: 10 F9              BPL   LAB_141B          ; if not end of keyword go do next
  1080                        
  1081 00:B2D5: B1 25              LDA   (ut2_pl),Y        ; get byte from keyword table
  1082 00:B2D7: D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
  1083                        
  1084                                                      ; reached end of table with no match
  1085 00:B2D9: BD 00 04           LDA   Ibuffs,X          ; restore byte from input buffer
  1086 00:B2DC: 80 C3              BRA   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
  1087                                                      ; go save byte in output and continue crunching
  1088                                                      ; reached [EOL]
  1089                        LAB_142A
  1090 00:B2DE: C8                 INY                     ; increment pointer
  1091 00:B2DF: C8                 INY                     ; increment pointer (makes it next line pointer high byte)
  1092 00:B2E0: 99 00 04           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
  1093 00:B2E3: C8                 INY                     ; adjust for line copy
  1094 00:B2E4: C8                 INY                     ; adjust for line copy
  1095 00:B2E5: C8                 INY                     ; adjust for line copy
  1096 00:B2E6: A5 6E              LDA   Bpntrl            ; test for $00
  1097 00:B2E8: D0 02              BNE   LAB_142P          ; not $00
  1098 00:B2EA: C6 6F              DEC   Bpntrh            ; allow for increment when $xx00
  1099                        LAB_142P
  1100 00:B2EC: C6 6E              DEC   Bpntrl            ; allow for increment
  1101 00:B2EE: 60                 RTS
  1102                        
  1103                        ; search Basic for temp integer line number from start of mem
  1104                        
  1105                        LAB_SSLN
  1106 00:B2EF: A5 2B              LDA   Smeml             ; get start of mem low byte
  1107 00:B2F1: A6 2C              LDX   Smemh             ; get start of mem high byte
  1108                        
  1109                        ; search Basic for temp integer line number from AX
  1110                        ; returns carry set if found
  1111                        ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1112                        
  1113                        LAB_SHLN
  1114 00:B2F3: A0 01              LDY   #$01              ; set index
  1115 00:B2F5: 85 5C              STA   Baslnl            ; save low byte as current
  1116 00:B2F7: 86 5D              STX   Baslnh            ; save high byte as current
  1117 00:B2F9: B1 5C              LDA   (Baslnl),Y        ; get pointer high byte from addr
  1118 00:B2FB: F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
  1119                        
  1120 00:B2FD: A0 03              LDY   #$03              ; set index to line # high byte
  1121 00:B2FF: B1 5C              LDA   (Baslnl),Y        ; get line # high byte
  1122 00:B301: 88                 DEY                     ; decrement index (point to low byte)
  1123 00:B302: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1124 00:B304: D0 04              BNE   LAB_1455          ; if <> skip low byte check
  1125                        
  1126 00:B306: B1 5C              LDA   (Baslnl),Y        ; get line # low byte
  1127 00:B308: C5 0A              CMP   Itempl            ; compare with temporary integer low byte
  1128                        LAB_1455
  Sun Mar  3 2019 22:47                                                                                                    Page 19


  1129 00:B30A: B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
  1130                        
  1131                        LAB_1456
  1132 00:B30C: 88                 DEY                     ; decrement index to next line ptr high byte
  1133 00:B30D: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1134 00:B30F: AA                 TAX                     ; copy to X
  1135 00:B310: 88                 DEY                     ; decrement index to next line ptr low byte
  1136 00:B311: B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
  1137 00:B313: 80 DE              BRA   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
  1138                                                      ; (carry always clear)
  1139                        
  1140                        LAB_145E
  1141 00:B315: F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
  1142                        
  1143                        LAB_145F
  1144 00:B317: 18                 CLC                     ; clear found flag
  1145                        LAB_1460
  1146 00:B318: 60                 RTS
  1147                        
  1148                        ; perform NEW
  1149                        
  1150                        LAB_NEW
  1151 00:B319: D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
  1152                        
  1153                        LAB_1463
  1154 00:B31B: A9 00              LDA   #$00              ; clear A
  1155 00:B31D: A8                 TAY                     ; clear Y
  1156 00:B31E: 91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
  1157 00:B320: C8                 INY                     ; increment index
  1158 00:B321: 91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
  1159 00:B323: 18                 CLC                     ; clear carry
  1160 00:B324: A5 2B              LDA   Smeml             ; get start of mem low byte
  1161 00:B326: 69 02              ADC   #$02              ; calculate end of BASIC low byte
  1162 00:B328: 85 2D              STA   Svarl             ; save start of vars low byte
  1163 00:B32A: A5 2C              LDA   Smemh             ; get start of mem high byte
  1164 00:B32C: 69 00              ADC   #$00              ; add any carry
  1165 00:B32E: 85 2E              STA   Svarh             ; save start of vars high byte
  1166                        
  1167                        ; reset execution to start, clear vars and flush stack
  1168                        
  1169                        LAB_1477
  1170 00:B330: 18                 CLC                     ; clear carry
  1171 00:B331: A5 2B              LDA   Smeml             ; get start of mem low byte
  1172 00:B333: 69 FF              ADC   #$FF              ; -1
  1173 00:B335: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1174 00:B337: A5 2C              LDA   Smemh             ; get start of mem high byte
  1175 00:B339: 69 FF              ADC   #$FF              ; -1+carry
  1176 00:B33B: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1177                        
  1178                        ; "CLEAR" command gets here
  1179                        
  1180                        LAB_147A
  1181 00:B33D: A5 37              LDA   Ememl             ; get end of mem low byte
  1182 00:B33F: A4 38              LDY   Ememh             ; get end of mem high byte
  1183 00:B341: 85 33              STA   Sstorl            ; set bottom of string space low byte
  1184 00:B343: 84 34              STY   Sstorh            ; set bottom of string space high byte
  1185 00:B345: A5 2D              LDA   Svarl             ; get start of vars low byte
  1186 00:B347: A4 2E              LDY   Svarh             ; get start of vars high byte
  1187 00:B349: 85 2F              STA   Sarryl            ; save var mem end low byte
  1188 00:B34B: 84 30              STY   Sarryh            ; save var mem end high byte
  1189 00:B34D: 85 31              STA   Earryl            ; save array mem end low byte
  1190 00:B34F: 84 32              STY   Earryh            ; save array mem end high byte
  1191 00:B351: 20 FF B4           JSR   LAB_161A          ; perform RESTORE command
  Sun Mar  3 2019 22:47                                                                                                    Page 20


  1192                        
  1193                        ; flush stack and clear continue flag
  1194                        
  1195                        LAB_1491
  1196 00:B354: A2 1A              LDX   #des_sk           ; set descriptor stack pointer
  1197 00:B356: 86 17              STX   next_s            ; save descriptor stack pointer
  1198 00:B358: FA                 PLX                     ; pull return address low byte
  1199 00:B359: 68                 PLA                     ; pull return address high byte
  1200 00:B35A: 8E FE 01           STX   LAB_SKFE          ; save to cleared stack
  1201 00:B35D: 8D FF 01           STA   LAB_SKFF          ; save to cleared stack
  1202 00:B360: A2 FD              LDX   #$FD              ; new stack pointer
  1203 00:B362: 9A                 TXS                     ; reset stack
  1204 00:B363: 64 13              STZ   Sufnxf            ; clear subscript/FNX flag
  1205                        LAB_14A6
  1206 00:B365: 60                 RTS
  1207                        
  1208                        ; perform CLEAR
  1209                        
  1210                        LAB_CLEAR
  1211 00:B366: F0 D5              BEQ   LAB_147A          ; if no following token go do "CLEAR"
  1212                                                      ; else there was a following token (go do syntax error)
  1213 00:B368: 60                 RTS
  1214                        
  1215                        ; perform LIST [n][-m]
  1216                        ; bigger, faster version (a _lot_ faster)
  1217                        
  1218                        LAB_LIST
  1219 00:B369: 90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
  1220 00:B36B: F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
  1221                        
  1222 00:B36D: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  1223 00:B36F: D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
  1224                        
  1225                                                      ; LIST [[n][-m]]
  1226                                                      ; this bit sets the n , if present, as the start and end
  1227                        LAB_14BD
  1228 00:B371: 20 FC B6           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1229 00:B374: 20 EF B2           JSR   LAB_SSLN          ; search BASIC for temp integer line number
  1230                                                      ; (pointer in Baslnl/Baslnh)
  1231 00:B377: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1232 00:B37A: F0 0C              BEQ   LAB_14D4          ; branch if no more characters
  1233                        
  1234                                                      ; this bit checks the - is present
  1235 00:B37C: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  1236 00:B37E: D0 98              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
  1237                        
  1238                                                      ; LIST [n]-m
  1239                                                      ; the - was there so set m as the end value
  1240 00:B380: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1241 00:B383: 20 FC B6           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1242 00:B386: D0 90              BNE   LAB_1460          ; exit if not ok
  1243                        
  1244                        LAB_14D4
  1245 00:B388: A5 0A              LDA   Itempl            ; get temporary integer low byte
  1246 00:B38A: 05 0B              ORA   Itemph            ; OR temporary integer high byte
  1247 00:B38C: D0 06              BNE   LAB_14E2          ; branch if start set
  1248                        
  1249 00:B38E: A9 FF              LDA   #$FF              ; set for -1
  1250 00:B390: 85 0A              STA   Itempl            ; set temporary integer low byte
  1251 00:B392: 85 0B              STA   Itemph            ; set temporary integer high byte
  1252                        LAB_14E2
  1253 00:B394: A0 01              LDY   #$01              ; set index for line
  1254 00:B396: 84 12              STY   Oquote            ; clear open quote flag
  Sun Mar  3 2019 22:47                                                                                                    Page 21


  1255 00:B398: 20 2E B8           JSR   LAB_CRLF          ; print CR/LF
  1256 00:B39B: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1257                                                      ; pointer initially set by search at LAB_14BD
  1258 00:B39D: F0 3E              BEQ   LAB_152B          ; if null all done so exit
  1259 00:B39F: 20 D5 B4           JSR   LAB_1629          ; do CRTL-C check vector
  1260                        
  1261 00:B3A2: C8                 INY                     ; increment index for line
  1262 00:B3A3: B1 5C              LDA   (Baslnl),Y        ; get line # low byte
  1263 00:B3A5: AA                 TAX                     ; copy to X
  1264 00:B3A6: C8                 INY                     ; increment index
  1265 00:B3A7: B1 5C              LDA   (Baslnl),Y        ; get line # high byte
  1266 00:B3A9: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1267 00:B3AB: D0 04              BNE   LAB_14FF          ; branch if no high byte match
  1268                        
  1269 00:B3AD: E4 0A              CPX   Itempl            ; compare with temporary integer low byte
  1270 00:B3AF: F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
  1271                        
  1272                        LAB_14FF                      ; else ..
  1273 00:B3B1: B0 2A              BCS   LAB_152B          ; if greater all done so exit
  1274                        
  1275                        LAB_1501
  1276 00:B3B3: 84 49              STY   Tidx1             ; save index for line
  1277 00:B3B5: 20 EB C9           JSR   LAB_295E          ; print XA as unsigned integer
  1278 00:B3B8: A9 20              LDA   #$20              ; space is the next character
  1279                        LAB_1508
  1280 00:B3BA: A4 49              LDY   Tidx1             ; get index for line
  1281 00:B3BC: 29 7F              AND   #$7F              ; mask top out bit of character
  1282                        LAB_150C
  1283 00:B3BE: 20 8A B8           JSR   LAB_PRNA          ; go print the character
  1284 00:B3C1: C9 22              CMP   #$22              ; was it " character
  1285 00:B3C3: D0 06              BNE   LAB_1519          ; branch if not
  1286                                                      ; we are either entering or leaving a pair of quotes
  1287 00:B3C5: A5 12              LDA   Oquote            ; get open quote flag
  1288 00:B3C7: 49 FF              EOR   #$FF              ; toggle it
  1289 00:B3C9: 85 12              STA   Oquote            ; save it back
  1290                        LAB_1519
  1291 00:B3CB: C8                 INY                     ; increment index
  1292 00:B3CC: B1 5C              LDA   (Baslnl),Y        ; get next byte
  1293 00:B3CE: D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
  1294 00:B3D0: A8                 TAY                     ; else clear index
  1295 00:B3D1: B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
  1296 00:B3D3: AA                 TAX                     ; copy to X
  1297 00:B3D4: C8                 INY                     ; increment index
  1298 00:B3D5: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1299 00:B3D7: 86 5C              STX   Baslnl            ; set pointer to line low byte
  1300 00:B3D9: 85 5D              STA   Baslnh            ; set pointer to line high byte
  1301 00:B3DB: D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
  1302                                                      ; else ..
  1303                        LAB_152B
  1304 00:B3DD: 60                 RTS
  1305                        
  1306                        LAB_152E
  1307 00:B3DE: 10 DE              BPL   LAB_150C          ; just go print it if not token byte
  1308                                                      ; else was token byte so uncrunch it (maybe)
  1309 00:B3E0: 24 12              BIT   Oquote            ; test the open quote flag
  1310 00:B3E2: 30 DA              BMI   LAB_150C          ; just go print character if open quote set
  1311                        
  1312 00:B3E4: A2 D3              LDX   #>LAB_KEYT        ; get table address high byte
  1313 00:B3E6: 0A                 ASL                     ; *2
  1314 00:B3E7: 0A                 ASL                     ; *4
  1315 00:B3E8: 90 02              BCC   LAB_152F          ; branch if no carry
  1316                        
  1317 00:B3EA: E8                 INX                     ; else increment high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 22


  1318 00:B3EB: 18                 CLC                     ; clear carry for add
  1319                        LAB_152F
  1320 00:B3EC: 69 98              ADC   #<LAB_KEYT        ; add low byte
  1321 00:B3EE: 90 01              BCC   LAB_1530          ; branch if no carry
  1322 00:B3F0: E8                 INX                     ; else increment high byte
  1323                        
  1324                        LAB_1530
  1325 00:B3F1: 85 25              STA   ut2_pl            ; save table pointer low byte
  1326 00:B3F3: 86 26              STX   ut2_ph            ; save table pointer high byte
  1327 00:B3F5: 84 49              STY   Tidx1             ; save index for line
  1328 00:B3F7: A0 00              LDY   #$00              ; clear index
  1329 00:B3F9: B1 25              LDA   (ut2_pl),Y        ; get length
  1330 00:B3FB: AA                 TAX                     ; copy length
  1331 00:B3FC: C8                 INY                     ; increment index
  1332 00:B3FD: B1 25              LDA   (ut2_pl),Y        ; get 1st character
  1333 00:B3FF: CA                 DEX                     ; decrement length
  1334 00:B400: F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
  1335                        
  1336 00:B402: 20 8A B8           JSR   LAB_PRNA          ; go print the character
  1337 00:B405: C8                 INY                     ; increment index
  1338 00:B406: B1 25              LDA   (ut2_pl),Y        ; get keyword address low byte
  1339 00:B408: 48                 PHA                     ; save it for now
  1340 00:B409: C8                 INY                     ; increment index
  1341 00:B40A: B1 25              LDA   (ut2_pl),Y        ; get keyword address high byte
  1342 00:B40C: A0 00              LDY   #$00
  1343 00:B40E: 85 26              STA   ut2_ph            ; save keyword pointer high byte
  1344 00:B410: 68                 PLA                     ; pull low byte
  1345 00:B411: 85 25              STA   ut2_pl            ; save keyword pointer low byte
  1346                        LAB_1540
  1347 00:B413: B1 25              LDA   (ut2_pl),Y        ; get character
  1348 00:B415: CA                 DEX                     ; decrement character count
  1349 00:B416: F0 A2              BEQ   LAB_1508          ; if last character exit and print
  1350                        
  1351 00:B418: 20 8A B8           JSR   LAB_PRNA          ; go print the character
  1352 00:B41B: C8                 INY                     ; increment index
  1353 00:B41C: D0 F5              BNE   LAB_1540          ; loop for next character
  1354                        
  1355                        ; perform FOR
  1356                        
  1357                        LAB_FOR
  1358 00:B41E: A9 80              LDA   #$80              ; set FNX
  1359 00:B420: 85 13              STA   Sufnxf            ; set subscript/FNX flag
  1360 00:B422: 20 5A B7           JSR   LAB_LET           ; go do LET
  1361 00:B425: 68                 PLA                     ; pull return address
  1362 00:B426: 68                 PLA                     ; pull return address
  1363 00:B427: A9 10              LDA   #$10              ; we need 16d bytes !
  1364 00:B429: 20 CB B0           JSR   LAB_1212          ; check room on stack for A bytes
  1365 00:B42C: 20 50 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1366 00:B42F: 18                 CLC                     ; clear carry for add
  1367 00:B430: 98                 TYA                     ; copy index to A
  1368 00:B431: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1369 00:B433: 48                 PHA                     ; push onto stack
  1370 00:B434: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1371 00:B436: 69 00              ADC   #$00              ; add carry
  1372 00:B438: 48                 PHA                     ; push onto stack
  1373 00:B439: A5 3A              LDA   Clineh            ; get current line high byte
  1374 00:B43B: 48                 PHA                     ; push onto stack
  1375 00:B43C: A5 39              LDA   Clinel            ; get current line low byte
  1376 00:B43E: 48                 PHA                     ; push onto stack
  1377 00:B43F: A9 AA              LDA   #TK_TO            ; get "TO" token
  1378 00:B441: 20 88 BB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  1379 00:B444: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  1380 00:B447: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  Sun Mar  3 2019 22:47                                                                                                    Page 23


  1381                                                      ; else do type mismatch
  1382 00:B44A: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  1383 00:B44C: 09 7F              ORA   #$7F              ; set all non sign bits
  1384 00:B44E: 25 5F              AND   FAC1_1            ; and FAC1 mantissa1
  1385 00:B450: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  1386 00:B452: A9 5D              LDA   #<LAB_159F        ; set return address low byte
  1387 00:B454: A0 B4              LDY   #>LAB_159F        ; set return address high byte
  1388 00:B456: 85 23              STA   ut1_pl            ; save return address low byte
  1389 00:B458: 84 24              STY   ut1_ph            ; save return address high byte
  1390 00:B45A: 4C 1B BB           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
  1391                        
  1392                        LAB_159F
  1393 00:B45D: A9 7E              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
  1394 00:B45F: A0 D0              LDY   #>LAB_259C        ; set 1 pointer high addr
  1395 00:B461: 20 F2 C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  1396 00:B464: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1397 00:B467: C9 AF              CMP   #TK_STEP          ; compare with STEP token
  1398 00:B469: D0 06              BNE   LAB_15B3          ; jump if not "STEP"
  1399                        
  1400                                                      ; was step so ..
  1401 00:B46B: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1402 00:B46E: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1403                                                      ; else do type mismatch
  1404                        LAB_15B3
  1405 00:B471: 20 5E C8           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
  1406 00:B474: 85 62              STA   FAC1_s            ; set FAC1 sign (b7)
  1407                                                      ; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1408                                                      ; compare the FOR value and the TO value and return +1 if
  1409                                                      ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1410                                                      ; here (+/-1) is then compared to that result and if they
  1411                                                      ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1412                                                      ; the loop is done
  1413 00:B476: 20 10 BB           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
  1414 00:B479: A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  1415 00:B47B: 48                 PHA                     ; push on stack
  1416 00:B47C: A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  1417 00:B47E: 48                 PHA                     ; push on stack
  1418 00:B47F: A9 81              LDA   #TK_FOR           ; get FOR token
  1419 00:B481: 48                 PHA                     ; push on stack
  1420                        
  1421                        ; interpreter inner loop
  1422                        
  1423                        LAB_15C2
  1424 00:B482: 20 D5 B4           JSR   LAB_1629          ; do CRTL-C check vector
  1425 00:B485: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1426 00:B487: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  1427 00:B489: A6 3A              LDX   Clineh            ; continue line is $FFxx for immediate mode
  1428                                                      ; ($00xx for RUN from immediate mode)
  1429 00:B48B: E8                 INX                     ; increment it (now $00 if immediate mode)
  1430 00:B48C: 85 3D              STA   Cpntrl            ; save continue pointer low byte
  1431 00:B48E: 84 3E              STY   Cpntrh            ; save continue pointer high byte
  1432                        LAB_15D1
  1433 00:B490: B2 6E              LDA   (Bpntrl)          ; get next byte
  1434 00:B492: F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
  1435                        
  1436 00:B494: C9 3A              CMP   #':'              ; compare with ":"
  1437 00:B496: F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
  1438                        
  1439                        LAB_15D9
  1440 00:B498: 4C 97 BB           JMP   LAB_SNER          ; else syntax error then warm start
  1441                                                      ; have reached [EOL]
  1442                        LAB_15DC
  1443 00:B49B: A0 02              LDY   #$02              ; set index
  Sun Mar  3 2019 22:47                                                                                                    Page 24


  1444 00:B49D: B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
  1445 00:B49F: 18                 CLC                     ; clear carry for no "BREAK" message
  1446 00:B4A0: F0 4F              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
  1447                                                      ; marker)
  1448 00:B4A2: C8                 INY                     ; increment index
  1449 00:B4A3: B1 6E              LDA   (Bpntrl),Y        ; get line # low byte
  1450 00:B4A5: 85 39              STA   Clinel            ; save current line low byte
  1451 00:B4A7: C8                 INY                     ; increment index
  1452 00:B4A8: B1 6E              LDA   (Bpntrl),Y        ; get line # high byte
  1453 00:B4AA: 85 3A              STA   Clineh            ; save current line high byte
  1454 00:B4AC: 98                 TYA                     ; A now = 4
  1455 00:B4AD: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1456 00:B4AF: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1457 00:B4B1: 90 02              BCC   LAB_15F6          ; branch if no overflow
  1458                        
  1459 00:B4B3: E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1460                        LAB_15F6
  1461 00:B4B5: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1462                        
  1463                        LAB_15F9
  1464 00:B4B8: 20 BD B4           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
  1465                        
  1466                        LAB_15FC
  1467 00:B4BB: 80 C5              BRA   LAB_15C2          ; loop
  1468                        
  1469                        ; interpret BASIC code from (Bpntrl)
  1470                        
  1471                        LAB_15FF
  1472 00:B4BD: F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
  1473                        
  1474                        LAB_1602
  1475 00:B4BF: 0A                 ASL                     ; *2 bytes per vector and normalise token
  1476 00:B4C0: B0 03              BCS   LAB_1609          ; branch if was token
  1477 00:B4C2: 4C 5A B7           JMP   LAB_LET           ; else go do implied LET
  1478                        
  1479                        LAB_1609
  1480 00:B4C5: C9 50              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
  1481 00:B4C7: B0 CF              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
  1482                                                      ; only tokens before TAB can start a line
  1483 00:B4C9: A8                 TAY                     ; copy to index
  1484 00:B4CA: B9 A6 D0           LDA   LAB_CTBL+1,Y      ; get vector high byte
  1485 00:B4CD: 48                 PHA                     ; onto stack
  1486 00:B4CE: B9 A5 D0           LDA   LAB_CTBL,Y        ; get vector low byte
  1487 00:B4D1: 48                 PHA                     ; onto stack
  1488 00:B4D2: 4C A5 CF           JMP   LAB_IGBY          ; jump to increment and scan memory
  1489                                                      ; then "return" to vector
  1490                        
  1491                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1492                        ; key press is detected.
  1493                        
  1494                        LAB_1629
  1495 00:B4D5: 6C 82 04           JMP   (VEC_CC)          ; ctrl-c check vector
  1496                        
  1497                        ; if there was a key press it gets back here ..
  1498                        
  1499                        LAB_1636
  1500 00:B4D8: C9 03              CMP   #$03              ; compare with CTRL-C
  1501                        
  1502                        ; perform STOP
  1503                        
  1504                        LAB_STOP
  1505 00:B4DA: B0 01              BCS   LAB_163B          ; branch if token follows STOP
  1506                                                      ; else just END
  Sun Mar  3 2019 22:47                                                                                                    Page 25


  1507                        ; END
  1508                        
  1509                        LAB_END
  1510 00:B4DC: 18                 CLC                     ; clear the carry, indicate a normal program end
  1511                        LAB_163B
  1512 00:B4DD: D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
  1513                        
  1514 00:B4DF: A5 6F              LDA   Bpntrh            ; get the BASIC execute pointer high byte
  1515 00:B4E1: A4 6E              LDY   Bpntrl            ; get BASIC execute pointer low byte
  1516 00:B4E3: 84 3D              STY   Cpntrl            ; save continue pointer low byte
  1517 00:B4E5: 85 3E              STA   Cpntrh            ; save continue pointer high byte
  1518                        LAB_1647
  1519 00:B4E7: A5 39              LDA   Clinel            ; get current line low byte
  1520 00:B4E9: A4 3A              LDY   Clineh            ; get current line high byte
  1521 00:B4EB: 85 3B              STA   Blinel            ; save break line low byte
  1522 00:B4ED: 84 3C              STY   Blineh            ; save break line high byte
  1523                        LAB_164F
  1524 00:B4EF: 68                 PLA                     ; pull return address low
  1525 00:B4F0: 68                 PLA                     ; pull return address high
  1526                        LAB_1651
  1527 00:B4F1: 90 07              BCC   LAB_165E          ; if was program end just do warm start
  1528                                                      ; else ..
  1529 00:B4F3: A9 55              LDA   #<LAB_BMSG        ; point to "Break" low byte
  1530 00:B4F5: A0 D6              LDY   #>LAB_BMSG        ; point to "Break" high byte
  1531 00:B4F7: 4C 19 B1           JMP   LAB_1269          ; print "Break" and do warm start
  1532                        
  1533                        LAB_165E
  1534 00:B4FA: 4C 24 B1           JMP   LAB_1274          ; go do warm start
  1535                        
  1536                        ; perform RESTORE
  1537                        
  1538                        LAB_RESTORE
  1539 00:B4FD: D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
  1540                        
  1541                        LAB_161A
  1542 00:B4FF: 38                 SEC                     ; set carry for subtract
  1543 00:B500: A5 2B              LDA   Smeml             ; get start of mem low byte
  1544 00:B502: E9 01              SBC   #$01              ; -1
  1545 00:B504: A4 2C              LDY   Smemh             ; get start of mem high byte
  1546 00:B506: B0 01              BCS   LAB_1624          ; branch if no underflow
  1547                        
  1548                        LAB_uflow
  1549 00:B508: 88                 DEY                     ; else decrement high byte
  1550                        LAB_1624
  1551 00:B509: 85 41              STA   Dptrl             ; save DATA pointer low byte
  1552 00:B50B: 84 42              STY   Dptrh             ; save DATA pointer high byte
  1553                        LAB_1628
  1554 00:B50D: 60                 RTS
  1555                                                      ; is RESTORE n
  1556                        LAB_RESTOREn
  1557 00:B50E: 20 FC B6           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1558 00:B511: 20 54 B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1559 00:B514: A5 3A              LDA   Clineh            ; get current line high byte
  1560 00:B516: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1561 00:B518: B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
  1562                        
  1563 00:B51A: 98                 TYA                     ; else copy line index to A
  1564 00:B51B: 38                 SEC                     ; set carry (+1)
  1565 00:B51C: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1566 00:B51E: A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1567 00:B520: 90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
  1568                        
  1569 00:B522: E8                 INX                     ; increment high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 26


  1570 00:B523: 80 04              BRA   LAB_go_search     ; branch always (can never be carry clear)
  1571                        
  1572                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1573                        
  1574                        LAB_reset_search
  1575 00:B525: A5 2B              LDA   Smeml             ; get start of mem low byte
  1576 00:B527: A6 2C              LDX   Smemh             ; get start of mem high byte
  1577                        
  1578                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1579                        
  1580                        LAB_go_search
  1581                        
  1582 00:B529: 20 F3 B2           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1583 00:B52C: B0 03              BCS   LAB_line_found    ; if carry set go set pointer
  1584                        
  1585 00:B52E: 4C 25 B6           JMP   LAB_16F7          ; else go do "Undefined statement" error
  1586                        
  1587                        LAB_line_found
  1588                                                      ; carry already set for subtract
  1589 00:B531: A5 5C              LDA   Baslnl            ; get pointer low byte
  1590 00:B533: E9 01              SBC   #$01              ; -1
  1591 00:B535: A4 5D              LDY   Baslnh            ; get pointer high byte
  1592 00:B537: B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
  1593 00:B539: 80 CD              BRA   LAB_uflow         ; else decrement high byte then save DATA pointer and
  1594                                                      ; return (branch always)
  1595                        ; perform NULL
  1596                        
  1597                        LAB_NULL
  1598 00:B53B: 20 0C C4           JSR   LAB_GTBY          ; get byte parameter
  1599 00:B53E: 86 06              STX   Nullct            ; save new NULL count
  1600                        LAB_167A
  1601 00:B540: 60                 RTS
  1602                        
  1603                        ; perform CONT
  1604                        
  1605                        LAB_CONT
  1606 00:B541: D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
  1607                        
  1608 00:B543: A4 3E              LDY   Cpntrh            ; get continue pointer high byte
  1609 00:B545: C0 04              CPY   #>Ibuffs          ; *** fix p2: test direct mode
  1610 00:B547: D0 05              BNE   LAB_166C          ; go do continue if we can
  1611                        
  1612 00:B549: A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
  1613 00:B54B: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1614                                                      ; we can continue so ..
  1615                        LAB_166C
  1616 00:B54E: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  1617 00:B550: A5 3D              LDA   Cpntrl            ; get continue pointer low byte
  1618 00:B552: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1619 00:B554: A5 3B              LDA   Blinel            ; get break line low byte
  1620 00:B556: A4 3C              LDY   Blineh            ; get break line high byte
  1621 00:B558: 85 39              STA   Clinel            ; set current line low byte
  1622 00:B55A: 84 3A              STY   Clineh            ; set current line high byte
  1623 00:B55C: 60                 RTS
  1624                        
  1625                        ; perform RUN
  1626                        
  1627                        LAB_RUN
  1628 00:B55D: D0 03              BNE   LAB_1696          ; branch if RUN n
  1629 00:B55F: 4C 30 B3           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
  1630                                                      ; return
  1631                        
  1632                        ; does RUN n
  Sun Mar  3 2019 22:47                                                                                                    Page 27


  1633                        
  1634                        LAB_1696
  1635 00:B562: 20 3D B3           JSR   LAB_147A          ; go do "CLEAR"
  1636 00:B565: 80 2E              BRA   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1637                        
  1638                        ; perform DO
  1639                        
  1640                        LAB_DO
  1641 00:B567: A9 05              LDA   #$05              ; need 5 bytes for DO
  1642 00:B569: 20 CB B0           JSR   LAB_1212          ; check room on stack for A bytes
  1643 00:B56C: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1644 00:B56E: 48                 PHA                     ; push on stack
  1645 00:B56F: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1646 00:B571: 48                 PHA                     ; push on stack
  1647 00:B572: A5 3A              LDA   Clineh            ; get current line high byte
  1648 00:B574: 48                 PHA                     ; push on stack
  1649 00:B575: A5 39              LDA   Clinel            ; get current line low byte
  1650 00:B577: 48                 PHA                     ; push on stack
  1651 00:B578: A9 9B              LDA   #TK_DO            ; token for DO
  1652 00:B57A: 48                 PHA                     ; push on stack
  1653 00:B57B: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1654 00:B57E: 4C 82 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1655                        
  1656                        ; perform GOSUB
  1657                        
  1658                        LAB_GOSUB
  1659 00:B581: A9 05              LDA   #$05              ; need 5 bytes for GOSUB
  1660 00:B583: 20 CB B0           JSR   LAB_1212          ; check room on stack for A bytes
  1661 00:B586: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1662 00:B588: 48                 PHA                     ; push on stack
  1663 00:B589: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1664 00:B58B: 48                 PHA                     ; push on stack
  1665 00:B58C: A5 3A              LDA   Clineh            ; get current line high byte
  1666 00:B58E: 48                 PHA                     ; push on stack
  1667 00:B58F: A5 39              LDA   Clinel            ; get current line low byte
  1668 00:B591: 48                 PHA                     ; push on stack
  1669 00:B592: A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
  1670 00:B594: 48                 PHA                     ; push on stack
  1671                        LAB_16B0
  1672 00:B595: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1673 00:B598: 20 9E B5           JSR   LAB_GOTO          ; perform GOTO n
  1674 00:B59B: 4C 82 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1675                                                      ; (can't RTS, we used the stack!)
  1676                        
  1677                        ; perform GOTO
  1678                        
  1679                        LAB_GOTO
  1680 00:B59E: 20 FC B6           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1681 00:B5A1: 20 54 B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1682 00:B5A4: A5 3A              LDA   Clineh            ; get current line high byte
  1683 00:B5A6: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1684 00:B5A8: B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
  1685                        
  1686 00:B5AA: 98                 TYA                     ; else copy line index to A
  1687 00:B5AB: 38                 SEC                     ; set carry (+1)
  1688 00:B5AC: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1689 00:B5AE: A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1690 00:B5B0: 90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
  1691                        
  1692 00:B5B2: E8                 INX                     ; increment high byte
  1693 00:B5B3: 80 04              BRA   LAB_16D4          ; branch always (can never be carry)
  1694                        
  1695                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  Sun Mar  3 2019 22:47                                                                                                    Page 28


  1696                        
  1697                        LAB_16D0
  1698 00:B5B5: A5 2B              LDA   Smeml             ; get start of mem low byte
  1699 00:B5B7: A6 2C              LDX   Smemh             ; get start of mem high byte
  1700                        
  1701                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1702                        
  1703                        LAB_16D4
  1704 00:B5B9: 20 F3 B2           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1705 00:B5BC: 90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
  1706                                                      ; (unspecified statement)
  1707                                                      ; carry already set for subtract
  1708 00:B5BE: A5 5C              LDA   Baslnl            ; get pointer low byte
  1709 00:B5C0: E9 01              SBC   #$01              ; -1
  1710 00:B5C2: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1711 00:B5C4: A5 5D              LDA   Baslnh            ; get pointer high byte
  1712 00:B5C6: E9 00              SBC   #$00              ; subtract carry
  1713 00:B5C8: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1714                        LAB_16E5
  1715 00:B5CA: 60                 RTS
  1716                        
  1717                        LAB_DONOK
  1718 00:B5CB: A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
  1719 00:B5CD: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1720                        
  1721                        ; perform LOOP
  1722                        
  1723                        LAB_LOOP
  1724 00:B5D0: A8                 TAY                     ; save following token
  1725 00:B5D1: BA                 TSX                     ; copy stack pointer
  1726 00:B5D2: BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
  1727 00:B5D5: C9 9B              CMP   #TK_DO            ; compare with DO token
  1728 00:B5D7: D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
  1729                        
  1730 00:B5D9: E8                 INX                     ; dump calling routine return address
  1731 00:B5DA: E8                 INX                     ; dump calling routine return address
  1732 00:B5DB: 9A                 TXS                     ; correct stack
  1733 00:B5DC: 98                 TYA                     ; get saved following token back
  1734 00:B5DD: F0 20              BEQ   LoopAlways        ; if no following token loop forever
  1735                                                      ; (stack pointer in X)
  1736                        
  1737 00:B5DF: C9 3A              CMP   #':'              ; could be ':'
  1738 00:B5E1: F0 1C              BEQ   LoopAlways        ; if :... loop forever
  1739                        
  1740 00:B5E3: E9 B0              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
  1741 00:B5E5: AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
  1742 00:B5E6: F0 04              BEQ   DoRest            ; branch if was UNTIL
  1743                        
  1744 00:B5E8: CA                 DEX                     ; decrement result
  1745 00:B5E9: D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
  1746                                                      ; only if the token was WHILE will this fail
  1747                        
  1748 00:B5EB: CA                 DEX                     ; set invert result byte
  1749                        DoRest
  1750 00:B5EC: 86 4A              STX   Frnxth            ; save invert result byte
  1751 00:B5EE: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1752 00:B5F1: 20 7B BA           JSR   LAB_EVEX          ; evaluate expression
  1753 00:B5F4: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  1754 00:B5F6: F0 02              BEQ   DoCmp             ; if =0 go do straight compare
  1755                        
  1756 00:B5F8: A9 FF              LDA   #$FF              ; else set all bits
  1757                        DoCmp
  1758 00:B5FA: BA                 TSX                     ; copy stack pointer
  Sun Mar  3 2019 22:47                                                                                                    Page 29


  1759 00:B5FB: 45 4A              EOR   Frnxth            ; EOR with invert byte
  1760 00:B5FD: D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
  1761                                                      ; loop condition wasn't met so do it again
  1762                        LoopAlways
  1763 00:B5FF: BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
  1764 00:B602: 85 39              STA   Clinel            ; save current line low byte
  1765 00:B604: BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
  1766 00:B607: 85 3A              STA   Clineh            ; save current line high byte
  1767 00:B609: BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
  1768 00:B60C: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1769 00:B60E: BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
  1770 00:B611: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1771 00:B613: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1772 00:B616: 4C 82 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1773                        
  1774                                                      ; clear stack and back to interpreter loop
  1775                        LoopDone
  1776 00:B619: E8                 INX                     ; dump DO token
  1777 00:B61A: E8                 INX                     ; dump current line low byte
  1778 00:B61B: E8                 INX                     ; dump current line high byte
  1779 00:B61C: E8                 INX                     ; dump BASIC execute pointer low byte
  1780 00:B61D: E8                 INX                     ; dump BASIC execute pointer high byte
  1781 00:B61E: 9A                 TXS                     ; correct stack
  1782 00:B61F: 80 1E              BRA   LAB_DATA          ; go perform DATA (find : or [EOL])
  1783                        
  1784                        ; do the return without gosub error
  1785                        
  1786                        LAB_16F4
  1787 00:B621: A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
  1788 00:B623: 80 02              BRA   LAB_16F7b         ; branch around next instruction, save one clock cycle
  1789                        
  1790                        LAB_16F7                      ; do undefined statement error
  1791 00:B625: A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
  1792                        LAB_16F7b
  1793 00:B627: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1794                        
  1795                        ; perform RETURN
  1796                        
  1797                        LAB_RETURN
  1798 00:B62A: D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
  1799                        
  1800                        LAB_16E8
  1801 00:B62C: 68                 PLA                     ; dump calling routine return address
  1802 00:B62D: 68                 PLA                     ; dump calling routine return address
  1803 00:B62E: 68                 PLA                     ; pull token
  1804 00:B62F: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  1805 00:B631: D0 EE              BNE   LAB_16F4          ; branch if no matching GOSUB
  1806                        
  1807                        LAB_16FF
  1808 00:B633: 68                 PLA                     ; pull current line low byte
  1809 00:B634: 85 39              STA   Clinel            ; save current line low byte
  1810 00:B636: 68                 PLA                     ; pull current line high byte
  1811 00:B637: 85 3A              STA   Clineh            ; save current line high byte
  1812 00:B639: 68                 PLA                     ; pull BASIC execute pointer low byte
  1813 00:B63A: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1814 00:B63C: 68                 PLA                     ; pull BASIC execute pointer high byte
  1815 00:B63D: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1816                        
  1817                                                      ; now do the DATA statement as we could be returning into
  1818                                                      ; the middle of an ON <var> GOSUB n,m,p,q line
  1819                                                      ; (the return address used by the DATA statement is the one
  1820                                                      ; pushed before the GOSUB was executed!)
  1821                        
  Sun Mar  3 2019 22:47                                                                                                    Page 30


  1822                        ; perform DATA
  1823                        
  1824                        LAB_DATA
  1825 00:B63F: 20 50 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1826                        
  1827                                                      ; set BASIC execute pointer
  1828                        LAB_170F
  1829 00:B642: 98                 TYA                     ; copy index to A
  1830 00:B643: 18                 CLC                     ; clear carry for add
  1831 00:B644: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1832 00:B646: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1833 00:B648: 90 02              BCC   LAB_1719          ; skip next if no carry
  1834                        
  1835 00:B64A: E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1836                        LAB_1719
  1837 00:B64C: 60                 RTS
  1838                        
  1839                        LAB_16FC
  1840 00:B64D: 4C 97 BB           JMP   LAB_SNER          ; do syntax error then warm start
  1841                        
  1842                        ; scan for next BASIC statement ([:] or [EOL])
  1843                        ; returns Y as index to [:] or [EOL]
  1844                        
  1845                        LAB_SNBS
  1846 00:B650: A2 3A              LDX   #':'              ; set look for character = ":"
  1847 00:B652: 80 02              BRA   LAB_SNBLb         ; branch around next instruction, save one clock cycle
  1848                        
  1849                        ; scan for next BASIC line
  1850                        ; returns Y as index to [EOL]
  1851                        
  1852                        LAB_SNBL
  1853 00:B654: A2 00              LDX   #$00              ; set alt search character = [EOL]
  1854                        LAB_SNBLb
  1855 00:B656: A0 00              LDY   #$00              ; set search character = [EOL]
  1856 00:B658: 84 0E              STY   Asrch             ; store search character
  1857                        LAB_1725
  1858 00:B65A: 8A                 TXA                     ; get alt search character
  1859 00:B65B: 45 0E              EOR   Asrch             ; toggle search character, effectively swap with $00
  1860 00:B65D: 85 0E              STA   Asrch             ; save swapped search character
  1861                        LAB_172D
  1862 00:B65F: B1 6E              LDA   (Bpntrl),Y        ; get next byte
  1863 00:B661: F0 E9              BEQ   LAB_1719          ; exit if null [EOL]
  1864                        
  1865 00:B663: C5 0E              CMP   Asrch             ; compare with search character
  1866 00:B665: F0 E5              BEQ   LAB_1719          ; exit if found
  1867                        
  1868 00:B667: C8                 INY                     ; increment index
  1869 00:B668: C9 22              CMP   #$22              ; compare current character with open quote
  1870 00:B66A: D0 F3              BNE   LAB_172D          ; if not open quote go get next character
  1871 00:B66C: 80 EC              BRA   LAB_1725          ; if found go swap search character for alt search character
  1872                        
  1873                        ; perform IF
  1874                        
  1875                        LAB_IF
  1876 00:B66E: 20 7B BA           JSR   LAB_EVEX          ; evaluate the expression
  1877 00:B671: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1878 00:B674: C9 AD              CMP   #TK_THEN          ; compare with THEN token
  1879 00:B676: F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
  1880                        
  1881                                                      ; wasn't IF .. THEN so must be IF .. GOTO
  1882 00:B678: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  1883 00:B67A: D0 D1              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
  1884                        
  Sun Mar  3 2019 22:47                                                                                                    Page 31


  1885 00:B67C: A6 6E              LDX   Bpntrl            ; save the basic pointer low byte
  1886 00:B67E: A4 6F              LDY   Bpntrh            ; save the basic pointer high byte
  1887 00:B680: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1888 00:B683: B0 C8              BCS   LAB_16FC          ; if not numeric go do syntax error
  1889                        
  1890 00:B685: 86 6E              STX   Bpntrl            ; restore the basic pointer low byte
  1891 00:B687: 84 6F              STY   Bpntrh            ; restore the basic pointer high byte
  1892                        LAB_174B
  1893 00:B689: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  1894 00:B68B: F0 1C              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
  1895                        
  1896 00:B68D: 20 A5 CF           JSR   LAB_IGBY          ; else increment and scan memory
  1897 00:B690: B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
  1898                        
  1899                        LAB_174C
  1900 00:B692: 4C 9E B5           JMP   LAB_GOTO          ; else was numeric so do GOTO n
  1901                        
  1902                                                      ; is var or keyword
  1903                        LAB_174D
  1904 00:B695: 68                 PLA                     ; discard interpreter loop return address
  1905 00:B696: 68                 PLA                     ; so data structures are at the correct stack offset
  1906 00:B697: 20 AB CF           JSR   LAB_GBYT          ; restore token or variable
  1907 00:B69A: 20 BD B4           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  1908                        
  1909                        ; the IF was executed and there may be a following ELSE so the code needs to return
  1910                        ; here to check and ignore the ELSE if present
  1911                        
  1912 00:B69D: B2 6E              LDA   (Bpntrl)          ; get the next BASIC byte
  1913 00:B69F: C9 A9              CMP   #TK_ELSE          ; compare it with the token for ELSE
  1914 00:B6A1: D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
  1915 00:B6A3: 20 3F B6           JSR   LAB_DATA          ; yes - skip the rest of the line
  1916                        
  1917                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  1918                        ; following ELSE will, correctly, cause a syntax error
  1919                        
  1920                        LAB_no_ELSE
  1921 00:B6A6: 4C 82 B4           JMP LAB_15C2            ; return to the interpreter inner loop
  1922                        
  1923                        ; perform ELSE after IF
  1924                        
  1925                        LAB_174E
  1926 00:B6A9: A0 00              LDY   #$00              ; clear the BASIC byte index
  1927 00:B6AB: A2 01              LDX   #$01              ; clear the nesting depth
  1928                        LAB_1750
  1929 00:B6AD: C8                 INY                     ; increment the BASIC byte index
  1930 00:B6AE: B1 6E              LDA   (Bpntrl),Y        ; get the next BASIC byte
  1931 00:B6B0: F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
  1932                        
  1933 00:B6B2: C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
  1934 00:B6B4: D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
  1935                        
  1936 00:B6B6: E8                 INX                     ; else increment the nesting depth ..
  1937 00:B6B7: D0 F4              BNE   LAB_1750          ; .. and continue looking
  1938                        
  1939                        LAB_1752
  1940 00:B6B9: C9 A9              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
  1941 00:B6BB: D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
  1942                        
  1943 00:B6BD: CA                 DEX                     ; was ELSE so decrement the nesting depth
  1944 00:B6BE: D0 ED              BNE   LAB_1750          ; loop if still nested
  1945                        
  1946 00:B6C0: C8                 INY                     ; increment the BASIC byte index past the ELSE
  1947                        
  Sun Mar  3 2019 22:47                                                                                                    Page 32


  1948                        ; found the matching ELSE, now do <{n|statement}>
  1949                        
  1950                        LAB_1753
  1951 00:B6C1: 98                 TYA                     ; else copy line index to A
  1952 00:B6C2: 18                 CLC                     ; clear carry for add
  1953 00:B6C3: 65 6E              ADC   Bpntrl            ; add the BASIC execute pointer low byte
  1954 00:B6C5: 85 6E              STA   Bpntrl            ; save the BASIC execute pointer low byte
  1955 00:B6C7: 90 02              BCC   LAB_1754          ; branch if no overflow to high byte
  1956                        
  1957 00:B6C9: E6 6F              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
  1958                        LAB_1754
  1959 00:B6CB: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  1960 00:B6CE: 90 C2              BCC   LAB_174C          ; if numeric do GOTO n
  1961                                                      ; the code will return to the interpreter loop at the
  1962                                                      ; tail end of the GOTO <n>
  1963                        
  1964 00:B6D0: 4C BD B4           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  1965                                                      ; the code will return to the interpreter loop at the
  1966                                                      ; tail end of the <statement>
  1967                        
  1968                        ; perform REM, skip (rest of) line
  1969                        
  1970                        LAB_REM
  1971 00:B6D3: 20 54 B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1972 00:B6D6: 4C 42 B6           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
  1973                        
  1974                        LAB_16FD
  1975 00:B6D9: 4C 97 BB           JMP   LAB_SNER          ; do syntax error then warm start
  1976                        
  1977                        ; perform ON
  1978                        
  1979                        LAB_ON
  1980 00:B6DC: 20 0C C4           JSR   LAB_GTBY          ; get byte parameter
  1981 00:B6DF: 48                 PHA                     ; push GOTO/GOSUB token
  1982 00:B6E0: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  1983 00:B6E2: F0 04              BEQ   LAB_176B          ; branch if GOSUB
  1984                        
  1985 00:B6E4: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  1986                        LAB_1767
  1987 00:B6E6: D0 F1              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
  1988                        
  1989                        ; next character was GOTO or GOSUB
  1990                        
  1991                        LAB_176B
  1992 00:B6E8: C6 61              DEC   FAC1_3            ; decrement index (byte value)
  1993 00:B6EA: D0 04              BNE   LAB_1773          ; branch if not zero
  1994                        
  1995 00:B6EC: 68                 PLA                     ; pull GOTO/GOSUB token
  1996 00:B6ED: 4C BF B4           JMP   LAB_1602          ; go execute it
  1997                        
  1998                        LAB_1773
  1999 00:B6F0: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2000 00:B6F3: 20 FC B6           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
  2001                                                      ; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2002                                                      ; just BNE LAB_176B for the loop. should be quicker ..
  2003                                                      ; no we can't, what if we meet a colon or [EOL]?)
  2004 00:B6F6: C9 2C              CMP   #$2C              ; compare next character with ","
  2005 00:B6F8: F0 EE              BEQ   LAB_176B          ; loop if ","
  2006                        
  2007                        LAB_177E
  2008 00:B6FA: 68                 PLA                     ; else pull keyword token (run out of options)
  2009                                                      ; also dump +/-1 pointer low byte and exit
  2010                        LAB_177F
  Sun Mar  3 2019 22:47                                                                                                    Page 33


  2011 00:B6FB: 60                 RTS
  2012                        
  2013                        ; takes n * 106 + 11 cycles where n is the number of digits
  2014                        
  2015                        ; get fixed-point number into temp integer
  2016                        
  2017                        LAB_GFPN
  2018 00:B6FC: A2 00              LDX   #$00              ; clear reg
  2019 00:B6FE: 86 0A              STX   Itempl            ; clear temporary integer low byte
  2020                        LAB_1785
  2021 00:B700: 86 0B              STX   Itemph            ; save temporary integer high byte
  2022 00:B702: B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
  2023                                                      ; not 0-9
  2024                        
  2025 00:B704: E0 19              CPX   #$19              ; compare high byte with $19
  2026 00:B706: A8                 TAY                     ; ensure Zb = 0 if the branch is taken
  2027 00:B707: B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
  2028                                                      ; bit does *$0A, = 64000, compare at target will fail
  2029                                                      ; and do syntax error
  2030                        
  2031 00:B709: E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
  2032 00:B70B: A8                 TAY                     ; copy binary digit
  2033 00:B70C: A5 0A              LDA   Itempl            ; get temporary integer low byte
  2034 00:B70E: 0A                 ASL                     ; *2 low byte
  2035 00:B70F: 26 0B              ROL   Itemph            ; *2 high byte
  2036 00:B711: 0A                 ASL                     ; *2 low byte
  2037 00:B712: 26 0B              ROL   Itemph            ; *2 high byte, *4
  2038 00:B714: 65 0A              ADC   Itempl            ; + low byte, *5
  2039 00:B716: 85 0A              STA   Itempl            ; save it
  2040 00:B718: 8A                 TXA                     ; get high byte copy to A
  2041 00:B719: 65 0B              ADC   Itemph            ; + high byte, *5
  2042 00:B71B: 06 0A              ASL   Itempl            ; *2 low byte, *10d
  2043 00:B71D: 2A                 ROL                     ; *2 high byte, *10d
  2044 00:B71E: AA                 TAX                     ; copy high byte back to X
  2045 00:B71F: 98                 TYA                     ; get binary digit back
  2046 00:B720: 65 0A              ADC   Itempl            ; add number low byte
  2047 00:B722: 85 0A              STA   Itempl            ; save number low byte
  2048 00:B724: 90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
  2049                        
  2050 00:B726: E8                 INX                     ; else increment high byte
  2051                        LAB_17B3
  2052 00:B727: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2053 00:B72A: 80 D4              BRA   LAB_1785          ; loop for next character
  2054                        
  2055                        ; perform DEC
  2056                        
  2057                        LAB_DEC
  2058 00:B72C: A9 82              LDA   #<LAB_2AFD        ; set -1 pointer low byte
  2059 00:B72E: 80 02              BRA   LAB_17B5          ; branch around next instruction, saves one clock cycle
  2060                        
  2061                        ; perform INC
  2062                        
  2063                        LAB_INC
  2064 00:B730: A9 7E              LDA   #<LAB_259C        ; set 1 pointer low byte
  2065                        LAB_17B5
  2066 00:B732: 48                 PHA                     ; save +/-1 pointer low byte
  2067                        LAB_17B7
  2068 00:B733: 20 39 BD           JSR   LAB_GVAR          ; get var address
  2069 00:B736: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2070 00:B738: 30 1D              BMI   IncrErr           ; exit if string
  2071                        
  2072 00:B73A: 85 49              STA   Lvarpl            ; save var address low byte
  2073 00:B73C: 84 4A              STY   Lvarph            ; save var address high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 34


  2074 00:B73E: 20 F2 C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  2075 00:B741: 68                 PLA                     ; get +/-1 pointer low byte
  2076 00:B742: 48                 PHA                     ; save +/-1 pointer low byte
  2077 00:B743: A0 D0              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
  2078 00:B745: 20 3A C5           JSR   LAB_246C          ; add (AY) to FAC1
  2079 00:B748: 20 18 C8           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
  2080                        
  2081 00:B74B: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2082 00:B74E: C9 2C              CMP   #','              ; compare with ","
  2083 00:B750: D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
  2084                        
  2085                                                      ; was "," so another INCR variable to do
  2086 00:B752: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2087 00:B755: 80 DC              BRA   LAB_17B7          ; go do next var
  2088                        
  2089                        IncrErr
  2090 00:B757: 4C 76 BA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  2091                        
  2092                        ; perform LET
  2093                        
  2094                        LAB_LET
  2095 00:B75A: 20 39 BD           JSR   LAB_GVAR          ; get var address
  2096 00:B75D: 85 49              STA   Lvarpl            ; save var address low byte
  2097 00:B75F: 84 4A              STY   Lvarph            ; save var address high byte
  2098 00:B761: A9 BD              LDA   #TK_EQUAL         ; get = token
  2099 00:B763: 20 88 BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2100 00:B766: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2101 00:B768: 48                 PHA                     ; push data type flag
  2102 00:B769: 20 7B BA           JSR   LAB_EVEX          ; evaluate expression
  2103 00:B76C: 68                 PLA                     ; pop data type flag
  2104 00:B76D: 2A                 ROL                     ; set carry if type = string
  2105 00:B76E: 20 6D BA           JSR   LAB_CKTM          ; type match check, set C for string
  2106 00:B771: D0 03              BNE   LAB_17D5          ; branch if string
  2107 00:B773: 4C 18 C8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2108                        
  2109                        ; string LET
  2110                        
  2111                        LAB_17D5
  2112 00:B776: A0 02              LDY   #$02              ; set index to pointer high byte
  2113 00:B778: B1 60              LDA   (des_pl),Y        ; get string pointer high byte
  2114 00:B77A: C5 34              CMP   Sstorh            ; compare bottom of string space high byte
  2115 00:B77C: 90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2116                        
  2117 00:B77E: D0 07              BNE   LAB_17E6          ; branch if >
  2118                                                      ; else was equal so compare low bytes
  2119 00:B780: 88                 DEY                     ; decrement index
  2120 00:B781: B1 60              LDA   (des_pl),Y        ; get pointer low byte
  2121 00:B783: C5 33              CMP   Sstorl            ; compare bottom of string space low byte
  2122 00:B785: 90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2123                        
  2124                                                      ; pointer was >= to bottom of string space pointer
  2125                        LAB_17E6
  2126 00:B787: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  2127 00:B789: C4 2E              CPY   Svarh             ; compare start of vars high byte
  2128 00:B78B: 90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
  2129 00:B78D: D0 0C              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
  2130                                                      ; else high bytes were equal so ..
  2131 00:B78F: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  2132 00:B791: C5 2D              CMP   Svarl             ; compare start of vars low byte
  2133 00:B793: B0 06              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
  2134                        
  2135                        LAB_17F4
  2136 00:B795: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  Sun Mar  3 2019 22:47                                                                                                    Page 35


  2137 00:B797: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  2138 00:B799: 80 14              BRA   LAB_1811          ; clean stack, copy descriptor to variable and return
  2139                        
  2140                                                      ; make space and copy string
  2141                        LAB_17FB
  2142 00:B79B: B2 60              LDA   (des_pl)          ; get string length
  2143 00:B79D: 20 BC C0           JSR   LAB_209C          ; copy string
  2144 00:B7A0: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  2145 00:B7A2: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  2146 00:B7A4: 85 6A              STA   ssptr_l           ; save descriptor pointer low byte
  2147 00:B7A6: 84 6B              STY   ssptr_h           ; save descriptor pointer high byte
  2148 00:B7A8: 20 98 C2           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  2149 00:B7AB: A9 5E              LDA   #<FAC1_e          ; set descriptor pointer low byte
  2150 00:B7AD: A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
  2151                        
  2152                                                      ; clean stack and assign value to string variable
  2153                        LAB_1811
  2154 00:B7AF: 85 50              STA   des_2l            ; save descriptor_2 pointer low byte
  2155 00:B7B1: 84 51              STY   des_2h            ; save descriptor_2 pointer high byte
  2156 00:B7B3: 20 FA C2           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  2157 00:B7B6: A0 00              LDY   #$00              ; index to length
  2158 00:B7B8: B1 50              LDA   (des_2l),Y        ; get string length
  2159 00:B7BA: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2160 00:B7BC: C8                 INY                     ; index to string pointer low byte
  2161 00:B7BD: B1 50              LDA   (des_2l),Y        ; get string pointer low byte
  2162 00:B7BF: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2163 00:B7C1: C8                 INY                     ; index to string pointer high byte
  2164 00:B7C2: B1 50              LDA   (des_2l),Y        ; get string pointer high byte
  2165 00:B7C4: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2166 00:B7C6: 60                 RTS
  2167                        
  2168                        ; perform GET
  2169                        
  2170                        LAB_GET
  2171 00:B7C7: 20 39 BD           JSR   LAB_GVAR          ; get var address
  2172 00:B7CA: 85 49              STA   Lvarpl            ; save var address low byte
  2173 00:B7CC: 84 4A              STY   Lvarph            ; save var address high byte
  2174 00:B7CE: 20 28 CE           JSR   INGET             ; get input byte
  2175 00:B7D1: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2176 00:B7D3: 30 07              BMI   LAB_GETS          ; go get string character
  2177                                                      ; was numeric get
  2178 00:B7D5: A8                 TAY                     ; copy character to Y
  2179 00:B7D6: 20 F2 BF           JSR   LAB_1FD0          ; convert Y to byte in FAC1
  2180 00:B7D9: 4C 18 C8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2181                        
  2182                        LAB_GETS
  2183 00:B7DC: 48                 PHA                     ; save character
  2184 00:B7DD: A9 01              LDA   #$01              ; string is single byte
  2185 00:B7DF: B0 01              BCS   LAB_IsByte        ; branch if byte received
  2186                        
  2187 00:B7E1: 68                 PLA                     ; string is null
  2188                        LAB_IsByte
  2189 00:B7E2: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  2190                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2191 00:B7E5: F0 03              BEQ   LAB_NoSt          ; skip store if null string
  2192                        
  2193 00:B7E7: 68                 PLA                     ; get character back
  2194 00:B7E8: 92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
  2195                        LAB_NoSt
  2196 00:B7EA: 20 11 C1           JSR   LAB_RTST          ; check for space on descriptor stack then put address
  2197                                                      ; and length on descriptor stack and update stack pointers
  2198 00:B7ED: 80 87              BRA   LAB_17D5          ; do string LET and return
  2199                        
  Sun Mar  3 2019 22:47                                                                                                    Page 36


  2200                        ; perform PRINT
  2201                        
  2202                        LAB_1829
  2203 00:B7EF: 20 72 B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2204                        LAB_182C
  2205 00:B7F2: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2206                        
  2207                        ; PRINT
  2208                        
  2209                        LAB_PRINT
  2210 00:B7F5: F0 37              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
  2211                        
  2212                        LAB_1831
  2213 00:B7F7: C9 A8              CMP   #TK_TAB           ; compare with TAB( token
  2214 00:B7F9: F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
  2215                        
  2216 00:B7FB: C9 AC              CMP   #TK_SPC           ; compare with SPC( token
  2217 00:B7FD: F0 4E              BEQ   LAB_18A2          ; go do TAB/SPC
  2218                        
  2219 00:B7FF: C9 2C              CMP   #','              ; compare with ","
  2220 00:B801: F0 34              BEQ   LAB_188B          ; go do move to next TAB mark
  2221                        
  2222 00:B803: C9 3B              CMP   #';'              ; compare with ";"
  2223 00:B805: F0 62              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
  2224                        
  2225 00:B807: 20 7B BA           JSR   LAB_EVEX          ; evaluate expression
  2226 00:B80A: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2227 00:B80C: 30 E1              BMI   LAB_1829          ; branch if string
  2228                        
  2229 00:B80E: 20 FE C9           JSR   LAB_296E          ; convert FAC1 to string
  2230 00:B811: 20 CE C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2231                        
  2232                        ; don't check fit if terminal width byte is zero
  2233                        
  2234 00:B814: A5 08              LDA   TWidth            ; get terminal width byte
  2235 00:B816: F0 0A              BEQ   LAB_185E          ; skip check if zero
  2236                        
  2237 00:B818: 38                 SEC                     ; set carry for subtract
  2238 00:B819: E5 07              SBC   TPos              ; subtract terminal position
  2239 00:B81B: F2 60              SBC   (des_pl)          ; subtract string length
  2240 00:B81D: B0 03              BCS   LAB_185E          ; branch if less than terminal width
  2241                        
  2242 00:B81F: 20 2E B8           JSR   LAB_CRLF          ; else print CR/LF
  2243                        LAB_185E
  2244 00:B822: 20 72 B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2245 00:B825: 80 CB              BRA   LAB_182C          ; always go continue processing line
  2246                        
  2247                        ; CR/LF return to BASIC from BASIC input handler
  2248                        
  2249                        LAB_1866
  2250 00:B827: 9E 00 04           STZ   Ibuffs,X          ; null terminate input
  2251 00:B82A: A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
  2252 00:B82C: A0 04              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
  2253                        
  2254                        ; print CR/LF
  2255                        
  2256                        LAB_CRLF
  2257 00:B82E: A9 0D              LDA   #$0D              ; load [CR]
  2258 00:B830: 20 8A B8           JSR   LAB_PRNA          ; go print the character
  2259 00:B833: A9 0A              LDA   #$0A              ; load [LF]
  2260 00:B835: 80 53              BRA   LAB_PRNA          ; go print the character and return, branch always
  2261                        
  2262                        LAB_188B
  Sun Mar  3 2019 22:47                                                                                                    Page 37


  2263 00:B837: A5 07              LDA   TPos              ; get terminal position
  2264 00:B839: C5 09              CMP   Iclim             ; compare with input column limit
  2265 00:B83B: 90 05              BCC   LAB_1897          ; branch if less
  2266                        
  2267 00:B83D: 20 2E B8           JSR   LAB_CRLF          ; else print CR/LF (next line)
  2268 00:B840: 80 27              BRA   LAB_18BD          ; continue with PRINT processing (branch always)
  2269                        
  2270                        LAB_1897
  2271 00:B842: 38                 SEC                     ; set carry for subtract
  2272                        LAB_1898
  2273 00:B843: E5 16              SBC   TabSiz            ; subtract TAB size
  2274 00:B845: B0 FC              BCS   LAB_1898          ; loop if result was +ve
  2275                        
  2276 00:B847: 49 FF              EOR   #$FF              ; complement it
  2277 00:B849: 69 01              ADC   #$01              ; +1 (twos complement)
  2278 00:B84B: 80 12              BRA   LAB_18B6          ; always print A spaces (result is never $00)
  2279                        
  2280                                                      ; do TAB/SPC
  2281                        LAB_18A2
  2282 00:B84D: 48                 PHA                     ; save token
  2283 00:B84E: 20 09 C4           JSR   LAB_SGBY          ; scan and get byte parameter
  2284 00:B851: C9 29              CMP   #$29              ; is next character )
  2285 00:B853: D0 7C              BNE   LAB_1910          ; if not do syntax error then warm start
  2286                        
  2287 00:B855: 68                 PLA                     ; get token back
  2288 00:B856: C9 A8              CMP   #TK_TAB           ; was it TAB ?
  2289 00:B858: D0 06              BNE   LAB_18B7          ; if not go do SPC
  2290                        
  2291                                                      ; calculate TAB offset
  2292 00:B85A: 8A                 TXA                     ; copy integer value to A
  2293 00:B85B: E5 07              SBC   TPos              ; subtract terminal position
  2294 00:B85D: 90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
  2295                        
  2296                                                      ; print A spaces
  2297                        LAB_18B6
  2298 00:B85F: AA                 TAX                     ; copy result to X
  2299                        LAB_18B7
  2300 00:B860: 8A                 TXA                     ; set flags on size for SPC
  2301 00:B861: F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
  2302                        
  2303                                                      ; print X spaces
  2304                        LAB_18BA
  2305 00:B863: 20 84 B8           JSR   LAB_18E0          ; print " "
  2306 00:B866: CA                 DEX                     ; decrement count
  2307 00:B867: D0 FA              BNE   LAB_18BA          ; loop if not all done
  2308                        
  2309                                                      ; continue with PRINT processing
  2310                        LAB_18BD
  2311 00:B869: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2312 00:B86C: D0 89              BNE   LAB_1831          ; if more to print go do it
  2313                        
  2314 00:B86E: 60                 RTS
  2315                        
  2316                        ; print null terminated string from memory
  2317                        
  2318                        LAB_18C3
  2319 00:B86F: 20 CE C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2320                        
  2321                        ; print string from Sutill/Sutilh
  2322                        
  2323                        LAB_18C6
  2324 00:B872: 20 C5 C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  2325                                                      ; space returns with A = length, X=$71=pointer low byte,
  Sun Mar  3 2019 22:47                                                                                                    Page 38


  2326                                                      ; Y=$72=pointer high byte
  2327 00:B875: A0 00              LDY   #$00              ; reset index
  2328 00:B877: AA                 TAX                     ; copy length to X
  2329 00:B878: F0 4A              BEQ   LAB_188C          ; exit (RTS) if null string
  2330                        
  2331                        LAB_18CD
  2332                        
  2333 00:B87A: B1 23              LDA   (ut1_pl),Y        ; get next byte
  2334 00:B87C: 20 8A B8           JSR   LAB_PRNA          ; go print the character
  2335 00:B87F: C8                 INY                     ; increment index
  2336 00:B880: CA                 DEX                     ; decrement count
  2337 00:B881: D0 F7              BNE   LAB_18CD          ; loop if not done yet
  2338 00:B883: 60                 RTS
  2339                        
  2340                                                      ; Print single format character
  2341                        ; print " "
  2342                        
  2343                        LAB_18E0
  2344 00:B884: A9 20              LDA   #$20              ; load " "
  2345 00:B886: 80 02              BRA   LAB_PRNA          ; branch around next instruction, saves one clock cycle
  2346                        
  2347                        ; print "?" character
  2348                        
  2349                        LAB_18E3
  2350 00:B888: A9 3F              LDA   #$3F              ; load "?" character
  2351                        
  2352                        ; print character in A
  2353                        ; now includes the null handler
  2354                        ; also includes infinite line length code
  2355                        ; note! some routines expect this one to exit with Zb=0
  2356                        
  2357                        LAB_PRNA
  2358 00:B88A: C9 20              CMP   #' '              ; compare with " "
  2359 00:B88C: 90 19              BCC   LAB_18F9          ; branch if less (non printing)
  2360                        
  2361                                                      ; else printable character
  2362 00:B88E: 48                 PHA                     ; save the character
  2363                        
  2364                        ; don't check fit if terminal width byte is zero
  2365                        
  2366 00:B88F: A5 08              LDA   TWidth            ; get terminal width
  2367 00:B891: D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
  2368                        
  2369                        ; is "infinite line" so check TAB position
  2370                        
  2371 00:B893: A5 07              LDA   TPos              ; get position
  2372 00:B895: E5 16              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
  2373 00:B897: D0 0B              BNE   LAB_18F7          ; skip reset if different
  2374                        
  2375 00:B899: 85 07              STA   TPos              ; else reset position
  2376 00:B89B: F0 07              BEQ   LAB_18F7          ; go print character
  2377                        
  2378                        LAB_18F0
  2379 00:B89D: C5 07              CMP   TPos              ; compare with terminal character position
  2380 00:B89F: D0 03              BNE   LAB_18F7          ; branch if not at end of line
  2381                        
  2382 00:B8A1: 20 2E B8           JSR   LAB_CRLF          ; else print CR/LF
  2383                        LAB_18F7
  2384 00:B8A4: E6 07              INC   TPos              ; increment terminal position
  2385 00:B8A6: 68                 PLA                     ; get character back
  2386                        LAB_18F9
  2387 00:B8A7: 20 C6 CF           JSR   V_OUTP            ; output byte via output vector
  2388 00:B8AA: C9 0D              CMP   #$0D              ; compare with [CR]
  Sun Mar  3 2019 22:47                                                                                                    Page 39


  2389 00:B8AC: D0 14              BNE   LAB_188A          ; branch if not [CR]
  2390                        
  2391                                                      ; else print nullct nulls after the [CR]
  2392 00:B8AE: 86 2A              STX   TempB             ; save buffer index
  2393 00:B8B0: A6 06              LDX   Nullct            ; get null count
  2394 00:B8B2: F0 0A              BEQ   LAB_1886          ; branch if no nulls
  2395                        
  2396 00:B8B4: A9 00              LDA   #$00              ; load [NULL]
  2397                        LAB_1880
  2398 00:B8B6: 20 8A B8           JSR   LAB_PRNA          ; go print the character
  2399 00:B8B9: CA                 DEX                     ; decrement count
  2400 00:B8BA: D0 FA              BNE   LAB_1880          ; loop if not all done
  2401                        
  2402 00:B8BC: A9 0D              LDA   #$0D              ; restore the character (and set the flags)
  2403                        LAB_1886
  2404 00:B8BE: 86 07              STX   TPos              ; clear terminal position (X always = zero when we get here)
  2405 00:B8C0: A6 2A              LDX   TempB             ; restore buffer index
  2406                        LAB_188A
  2407 00:B8C2: 29 FF              AND   #$FF              ; set the flags
  2408                        LAB_188C
  2409 00:B8C4: 60                 RTS
  2410                        
  2411                        ; handle bad input data
  2412                        
  2413                        LAB_1904
  2414 00:B8C5: A5 14              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
  2415 00:B8C7: 10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
  2416                        
  2417 00:B8C9: A5 3F              LDA   Dlinel            ; get current DATA line low byte
  2418 00:B8CB: A4 40              LDY   Dlineh            ; get current DATA line high byte
  2419 00:B8CD: 85 39              STA   Clinel            ; save current line low byte
  2420 00:B8CF: 84 3A              STY   Clineh            ; save current line high byte
  2421                        LAB_1910
  2422 00:B8D1: 4C 97 BB           JMP   LAB_SNER          ; do syntax error then warm start
  2423                        
  2424                                                      ; mode was INPUT
  2425                        LAB_1913
  2426 00:B8D4: A9 89              LDA   #<LAB_REDO        ; point to redo message (low addr)
  2427 00:B8D6: A0 D6              LDY   #>LAB_REDO        ; point to redo message (high addr)
  2428 00:B8D8: 20 6F B8           JSR   LAB_18C3          ; print null terminated string from memory
  2429 00:B8DB: A5 3D              LDA   Cpntrl            ; get continue pointer low byte
  2430 00:B8DD: A4 3E              LDY   Cpntrh            ; get continue pointer high byte
  2431 00:B8DF: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  2432 00:B8E1: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  2433 00:B8E3: 60                 RTS
  2434                        
  2435                        ; perform INPUT
  2436                        
  2437                        LAB_INPUT
  2438 00:B8E4: C9 22              CMP   #$22              ; compare next byte with open quote
  2439 00:B8E6: D0 0B              BNE   LAB_1934          ; branch if no prompt string
  2440                        
  2441 00:B8E8: 20 55 BB           JSR   LAB_1BC1          ; print "..." string
  2442 00:B8EB: A9 3B              LDA   #$3B              ; load A with ";"
  2443 00:B8ED: 20 88 BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2444 00:B8F0: 20 72 B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2445                        
  2446                                                      ; done with prompt, now get data
  2447                        LAB_1934
  2448 00:B8F3: 20 F6 BF           JSR   LAB_CKRN          ; check not Direct, back here if ok
  2449 00:B8F6: 20 04 B2           JSR   LAB_INLN          ; print "? " and get BASIC input
  2450 00:B8F9: A9 00              LDA   #$00              ; set mode = INPUT
  2451 00:B8FB: CD 00 04           CMP   Ibuffs            ; test first byte in buffer
  Sun Mar  3 2019 22:47                                                                                                    Page 40


  2452 00:B8FE: D0 09              BNE   LAB_1953          ; branch if not null input
  2453 00:B900: 4C E7 B4           JMP   LAB_1647          ; go do BREAK exit
  2454                        
  2455                        ; perform READ
  2456                        
  2457                        LAB_READ
  2458 00:B903: A6 41              LDX   Dptrl             ; get DATA pointer low byte
  2459 00:B905: A4 42              LDY   Dptrh             ; get DATA pointer high byte
  2460 00:B907: A9 80              LDA   #$80              ; set mode = READ
  2461                        
  2462                        LAB_1953
  2463 00:B909: 85 14              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
  2464 00:B90B: 86 43              STX   Rdptrl            ; save READ pointer low byte
  2465 00:B90D: 84 44              STY   Rdptrh            ; save READ pointer high byte
  2466                        
  2467                                                      ; READ or INPUT next variable from list
  2468                        LAB_195B
  2469 00:B90F: 20 39 BD           JSR   LAB_GVAR          ; get (var) address
  2470 00:B912: 85 49              STA   Lvarpl            ; save address low byte
  2471 00:B914: 84 4A              STY   Lvarph            ; save address high byte
  2472 00:B916: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2473 00:B918: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2474 00:B91A: 85 0A              STA   Itempl            ; save as temporary integer low byte
  2475 00:B91C: 84 0B              STY   Itemph            ; save as temporary integer high byte
  2476 00:B91E: A6 43              LDX   Rdptrl            ; get READ pointer low byte
  2477 00:B920: A4 44              LDY   Rdptrh            ; get READ pointer high byte
  2478 00:B922: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
  2479 00:B924: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2480 00:B926: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2481 00:B929: D0 11              BNE   LAB_1988          ; branch if not null
  2482                        
  2483                                                      ; pointer was to null entry
  2484 00:B92B: 24 14              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
  2485 00:B92D: 30 64              BMI   LAB_19DD          ; branch if READ
  2486                        
  2487                                                      ; mode was INPUT
  2488 00:B92F: 20 88 B8           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
  2489 00:B932: 20 04 B2           JSR   LAB_INLN          ; print "? " and get BASIC input
  2490 00:B935: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
  2491 00:B937: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2492                        LAB_1985
  2493 00:B939: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2494                        LAB_1988
  2495 00:B93C: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2496 00:B93E: 10 23              BPL   LAB_19B0          ; branch if numeric
  2497                        
  2498                                                      ; else get string
  2499 00:B940: 85 0D              STA   Srchc             ; save search character
  2500 00:B942: C9 22              CMP   #$22              ; was it " ?
  2501 00:B944: F0 07              BEQ   LAB_1999          ; branch if so
  2502                        
  2503 00:B946: A9 3A              LDA   #':'              ; else search character is ":"
  2504 00:B948: 85 0D              STA   Srchc             ; set new search character
  2505 00:B94A: A9 2C              LDA   #','              ; other search character is ","
  2506 00:B94C: 18                 CLC                     ; clear carry for add
  2507                        LAB_1999
  2508 00:B94D: 85 0E              STA   Asrch             ; set second search character
  2509 00:B94F: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2510 00:B951: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2511                        
  2512 00:B953: 69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
  2513 00:B955: 90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
  2514                        
  Sun Mar  3 2019 22:47                                                                                                    Page 41


  2515 00:B957: C8                 INY                     ; else increment high byte
  2516                        LAB_19A4
  2517 00:B958: 20 D4 C0           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
  2518 00:B95B: 20 4C C4           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2519 00:B95E: 20 76 B7           JSR   LAB_17D5          ; go do string LET
  2520 00:B961: 80 06              BRA   LAB_19B6          ; go check string terminator
  2521                        
  2522                                                      ; get numeric INPUT
  2523                        LAB_19B0
  2524 00:B963: 20 16 C9           JSR   LAB_2887          ; get FAC1 from string
  2525 00:B966: 20 18 C8           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
  2526                        LAB_19B6
  2527 00:B969: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2528 00:B96C: F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
  2529                        
  2530 00:B96E: C9 2C              CMP   #','              ; else compare with ","
  2531 00:B970: F0 03              BEQ   LAB_19C2          ; branch if ","
  2532                        
  2533 00:B972: 4C C5 B8           JMP   LAB_1904          ; else go handle bad input data
  2534                        
  2535                                                      ; got good input data
  2536                        LAB_19C2
  2537 00:B975: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2538                        LAB_19C5
  2539 00:B978: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2540 00:B97A: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2541 00:B97C: 85 43              STA   Rdptrl            ; save for now
  2542 00:B97E: 84 44              STY   Rdptrh            ; save for now
  2543 00:B980: A5 0A              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
  2544 00:B982: A4 0B              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
  2545 00:B984: 85 6E              STA   Bpntrl            ; set BASIC execute pointer low byte
  2546 00:B986: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2547 00:B988: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2548 00:B98B: F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
  2549                        
  2550 00:B98D: 20 93 BB           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
  2551 00:B990: 4C 0F B9           JMP   LAB_195B          ; go INPUT next variable from list
  2552                        
  2553                                                      ; find next DATA statement or do "Out of DATA" error
  2554                        LAB_19DD
  2555 00:B993: 20 50 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  2556 00:B996: C8                 INY                     ; increment index
  2557 00:B997: AA                 TAX                     ; copy character ([:] or [EOL])
  2558 00:B998: D0 12              BNE   LAB_19F6          ; branch if [:]
  2559                        
  2560 00:B99A: A2 06              LDX   #$06              ; set for "Out of DATA" error
  2561 00:B99C: C8                 INY                     ; increment index, now points to next line pointer high byte
  2562 00:B99D: B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
  2563 00:B99F: F0 71              BEQ   LAB_1A54          ; branch if end (eventually does error X)
  2564                        
  2565 00:B9A1: C8                 INY                     ; increment index
  2566 00:B9A2: B1 6E              LDA   (Bpntrl),Y        ; get next line # low byte
  2567 00:B9A4: 85 3F              STA   Dlinel            ; save current DATA line low byte
  2568 00:B9A6: C8                 INY                     ; increment index
  2569 00:B9A7: B1 6E              LDA   (Bpntrl),Y        ; get next line # high byte
  2570 00:B9A9: C8                 INY                     ; increment index
  2571 00:B9AA: 85 40              STA   Dlineh            ; save current DATA line high byte
  2572                        LAB_19F6
  2573 00:B9AC: B1 6E              LDA   (Bpntrl),Y        ; get byte
  2574 00:B9AE: C8                 INY                     ; increment index
  2575 00:B9AF: AA                 TAX                     ; copy to X
  2576 00:B9B0: 20 42 B6           JSR   LAB_170F          ; set BASIC execute pointer
  2577 00:B9B3: E0 83              CPX   #TK_DATA          ; compare with "DATA" token
  Sun Mar  3 2019 22:47                                                                                                    Page 42


  2578 00:B9B5: F0 82              BEQ   LAB_1985          ; was "DATA" so go do next READ
  2579 00:B9B7: 80 DA              BRA   LAB_19DD          ; go find next statement if not "DATA"
  2580                        
  2581                        ; end of INPUT/READ routine
  2582                        
  2583                        LAB_1A03
  2584 00:B9B9: A5 43              LDA   Rdptrl            ; get temp READ pointer low byte
  2585 00:B9BB: A4 44              LDY   Rdptrh            ; get temp READ pointer high byte
  2586 00:B9BD: A6 14              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
  2587 00:B9BF: 10 03              BPL   LAB_1A0E          ; branch if INPUT
  2588 00:B9C1: 4C 09 B5           JMP   LAB_1624          ; save AY as DATA pointer and return
  2589                        
  2590                                                      ; we were getting INPUT
  2591                        LAB_1A0E
  2592 00:B9C4: B2 43              LDA   (Rdptrl)          ; get next byte
  2593 00:B9C6: D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
  2594 00:B9C8: 60                 RTS
  2595                        
  2596                                                      ; user typed too much
  2597                        LAB_1A1B
  2598 00:B9C9: A9 78              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
  2599 00:B9CB: A0 D6              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
  2600 00:B9CD: 4C 6F B8           JMP   LAB_18C3          ; print null terminated string from memory and return
  2601                        
  2602                        ; search the stack for FOR activity
  2603                        ; exit with z=1 if FOR else exit with z=0
  2604                        
  2605                        LAB_11A1
  2606 00:B9D0: BA                 TSX                     ; copy stack pointer
  2607 00:B9D1: E8                 INX                     ; +1 pass return address
  2608 00:B9D2: E8                 INX                     ; +2 pass return address
  2609 00:B9D3: E8                 INX                     ; +3 pass calling routine return address
  2610 00:B9D4: E8                 INX                     ; +4 pass calling routine return address
  2611                        LAB_11A6
  2612 00:B9D5: BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
  2613 00:B9D8: C9 81              CMP   #TK_FOR           ; is it FOR token
  2614 00:B9DA: D0 21              BNE   LAB_11CE          ; exit if not FOR token
  2615                        
  2616                                                      ; was FOR token
  2617 00:B9DC: A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  2618 00:B9DE: D0 0A              BNE   LAB_11BB          ; branch if not null
  2619                        
  2620 00:B9E0: BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
  2621 00:B9E3: 85 49              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
  2622 00:B9E5: BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
  2623 00:B9E8: 85 4A              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
  2624                        LAB_11BB
  2625 00:B9EA: DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
  2626 00:B9ED: D0 07              BNE   LAB_11C7          ; branch if no match
  2627                        
  2628 00:B9EF: A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  2629 00:B9F1: DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
  2630 00:B9F4: F0 07              BEQ   LAB_11CE          ; exit if match found
  2631                        
  2632                        LAB_11C7
  2633 00:B9F6: 8A                 TXA                     ; copy index
  2634 00:B9F7: 18                 CLC                     ; clear carry for add
  2635 00:B9F8: 69 10              ADC   #$10              ; add FOR stack use size
  2636 00:B9FA: AA                 TAX                     ; copy back to index
  2637 00:B9FB: D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
  2638                        
  2639                        LAB_11CE
  2640 00:B9FD: 60                 RTS
  Sun Mar  3 2019 22:47                                                                                                    Page 43


  2641                        
  2642                        ; perform NEXT
  2643                        
  2644                        LAB_NEXT
  2645 00:B9FE: D0 04              BNE   LAB_1A46          ; branch if NEXT var
  2646                        
  2647 00:BA00: A0 00              LDY   #$00              ; else clear Y
  2648 00:BA02: 80 03              BRA   LAB_1A49          ; branch always (no variable to search for)
  2649                        
  2650                        ; NEXT var
  2651                        
  2652                        LAB_1A46
  2653 00:BA04: 20 39 BD           JSR   LAB_GVAR          ; get variable address
  2654                        LAB_1A49
  2655 00:BA07: 85 49              STA   Frnxtl            ; store variable pointer low byte
  2656 00:BA09: 84 4A              STY   Frnxth            ; store variable pointer high byte
  2657                                                      ; (both cleared if no variable defined)
  2658 00:BA0B: 20 D0 B9           JSR   LAB_11A1          ; search the stack for FOR activity
  2659 00:BA0E: F0 04              BEQ   LAB_1A56          ; branch if found
  2660                        
  2661 00:BA10: A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
  2662                        LAB_1A54
  2663 00:BA12: F0 64              BEQ   LAB_1ABE          ; do error #X, then warm start
  2664                        
  2665                        LAB_1A56
  2666 00:BA14: 9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
  2667                        
  2668 00:BA15: 8A                 TXA                     ; copy stack pointer
  2669 00:BA16: 38                 SEC                     ; set carry for subtract
  2670 00:BA17: E9 F7              SBC   #$F7              ; point to TO var
  2671 00:BA19: 85 25              STA   ut2_pl            ; save pointer to TO var for compare
  2672 00:BA1B: 69 FB              ADC   #$FB              ; point to STEP var
  2673                        
  2674 00:BA1D: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2675 00:BA1F: 20 F2 C7           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
  2676 00:BA22: BA                 TSX                     ; get stack pointer back
  2677 00:BA23: BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
  2678 00:BA26: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  2679 00:BA28: A5 49              LDA   Frnxtl            ; get FOR variable pointer low byte
  2680 00:BA2A: A4 4A              LDY   Frnxth            ; get FOR variable pointer high byte
  2681 00:BA2C: 20 3A C5           JSR   LAB_246C          ; add (FOR variable) to FAC1
  2682 00:BA2F: 20 18 C8           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
  2683 00:BA32: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2684 00:BA34: 20 8A C8           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
  2685 00:BA37: BA                 TSX                     ; get stack pointer back
  2686 00:BA38: DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
  2687 00:BA3B: F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
  2688                        
  2689                                                      ; loop back and do it all again
  2690 00:BA3D: BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
  2691 00:BA40: 85 39              STA   Clinel            ; save current line low byte
  2692 00:BA42: BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
  2693 00:BA45: 85 3A              STA   Clineh            ; save current line high byte
  2694 00:BA47: BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
  2695 00:BA4A: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  2696 00:BA4C: BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
  2697 00:BA4F: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  2698                        LAB_1A98
  2699 00:BA51: 4C 82 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  2700                        
  2701                                                      ; loop complete so carry on
  2702                        LAB_1A9B
  2703 00:BA54: 8A                 TXA                     ; stack copy to A
  Sun Mar  3 2019 22:47                                                                                                    Page 44


  2704 00:BA55: 69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
  2705 00:BA57: AA                 TAX                     ; copy back to index
  2706 00:BA58: 9A                 TXS                     ; copy to stack pointer
  2707 00:BA59: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2708 00:BA5C: C9 2C              CMP   #','              ; compare with ","
  2709 00:BA5E: D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
  2710                        
  2711                                                      ; was "," so another NEXT variable to do
  2712 00:BA60: 20 A5 CF           JSR   LAB_IGBY          ; else increment and scan memory
  2713 00:BA63: 20 04 BA           JSR   LAB_1A46          ; do NEXT (var)
  2714                        
  2715                        ; evaluate expression and check is numeric, else do type mismatch
  2716                        
  2717                        LAB_EVNM
  2718 00:BA66: 20 7B BA           JSR   LAB_EVEX          ; evaluate expression
  2719                        
  2720                        ; check if source is numeric, else do type mismatch
  2721                        
  2722                        LAB_CTNM
  2723 00:BA69: 18                 CLC                     ; destination is numeric
  2724 00:BA6A: 80 01              BRA   LAB_CKTM          ; branch around SEC
  2725                        
  2726                        ; check if source is string, else do type mismatch
  2727                        
  2728                        LAB_CTST
  2729 00:BA6C: 38                 SEC                     ; required type is string
  2730                        
  2731                        ; type match check, set C for string, clear C for numeric
  2732                        
  2733                        LAB_CKTM
  2734 00:BA6D: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2735 00:BA6F: 30 03              BMI   LAB_1ABA          ; branch if data type is string
  2736                                                      ; else data type was numeric
  2737 00:BA71: B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
  2738                        LAB_1AB9
  2739 00:BA73: 60                 RTS
  2740                        
  2741                                                      ; data type was string, now check required type
  2742                        LAB_1ABA
  2743 00:BA74: B0 FD              BCS   LAB_1AB9          ; exit if required type is string
  2744                        
  2745                                                      ; else do type mismatch error
  2746                        LAB_1ABC
  2747 00:BA76: A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
  2748                        LAB_1ABE
  2749 00:BA78: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  2750                        
  2751                        ; evaluate expression
  2752                        
  2753                        LAB_EVEX
  2754 00:BA7B: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  2755 00:BA7D: D0 02              BNE   LAB_1AC7          ; skip next if not zero
  2756                        
  2757 00:BA7F: C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  2758                        LAB_1AC7
  2759 00:BA81: C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  2760                        
  2761                        LAB_EVEZ
  2762 00:BA83: A9 00              LDA   #$00              ; set null precedence (flag done)
  2763                        LAB_1ACC
  2764 00:BA85: 48                 PHA                     ; push precedence byte
  2765 00:BA86: A9 02              LDA   #$02              ; 2 bytes
  2766 00:BA88: 20 CB B0           JSR   LAB_1212          ; check room on stack for A bytes
  Sun Mar  3 2019 22:47                                                                                                    Page 45


  2767 00:BA8B: 20 64 BB           JSR   LAB_GVAL          ; get value from line
  2768 00:BA8E: 64 4D              STZ   comp_f            ; clear compare function flag
  2769                        LAB_1ADB
  2770 00:BA90: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  2771                        LAB_1ADE
  2772 00:BA93: 38                 SEC                     ; set carry for subtract
  2773 00:BA94: E9 BC              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
  2774 00:BA96: 90 16              BCC   LAB_1AFA          ; branch if < TK_GT
  2775                        
  2776 00:BA98: C9 03              CMP   #$03              ; compare with ">" to "<" tokens
  2777 00:BA9A: B0 12              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
  2778                        
  2779                                                      ; was token for > = or < (A = 0, 1 or 2)
  2780 00:BA9C: C9 01              CMP   #$01              ; compare with token for =
  2781 00:BA9E: 2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
  2782                                                      ; (A = 0, 3 or 5)
  2783 00:BA9F: 49 01              EOR   #$01              ; toggle b0
  2784                                                      ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2785 00:BAA1: 45 4D              EOR   comp_f            ; EOR with compare function flag bits
  2786 00:BAA3: C5 4D              CMP   comp_f            ; compare with compare function flag
  2787 00:BAA5: 90 66              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
  2788                                                      ; was more than one <, = or >)
  2789                        
  2790 00:BAA7: 85 4D              STA   comp_f            ; save new compare function flag
  2791 00:BAA9: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2792 00:BAAC: 80 E5              BRA   LAB_1ADE          ; go do next character
  2793                        
  2794                                                      ; token is < ">" or > "<" tokens
  2795                        LAB_1AFA
  2796 00:BAAE: A6 4D              LDX   comp_f            ; get compare function flag
  2797 00:BAB0: D0 2C              BNE   LAB_1B2A          ; branch if compare function
  2798 00:BAB2: B0 79              BCS   LAB_1B78          ; go do functions
  2799                        
  2800                                                      ; else was <  TK_GT so is operator or lower
  2801 00:BAB4: 69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2802 00:BAB6: 90 75              BCC   LAB_1B78          ; branch if < + operator
  2803                                                      ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2804 00:BAB8: D0 07              BNE   LAB_1B0B          ; branch if not + token
  2805                        
  2806 00:BABA: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2807 00:BABC: 10 03              BPL   LAB_1B0B          ; branch if not string
  2808                        
  2809                                                      ; will only be $00 if type is string and token was +
  2810 00:BABE: 4C 5D C2           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
  2811                                                      ; is in line, and return
  2812                        
  2813                        LAB_1B0B
  2814 00:BAC1: 85 23              STA   ut1_pl            ; save it
  2815 00:BAC3: 0A                 ASL                     ; *2
  2816 00:BAC4: 65 23              ADC   ut1_pl            ; *3
  2817 00:BAC6: A8                 TAY                     ; copy to index
  2818                        LAB_1B13
  2819 00:BAC7: 68                 PLA                     ; pull previous precedence
  2820 00:BAC8: D9 81 D1           CMP   LAB_OPPT,Y        ; compare with precedence byte
  2821 00:BACB: B0 65              BCS   LAB_1B7D          ; branch if A >=
  2822                        
  2823 00:BACD: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  2824                        LAB_1B1C
  2825 00:BAD0: 48                 PHA                     ; save precedence
  2826                        LAB_1B1D
  2827 00:BAD1: 20 F9 BA           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
  2828 00:BAD4: 68                 PLA                     ; restore precedence
  2829 00:BAD5: A4 4B              LDY   prstk             ; get precedence stacked flag
  Sun Mar  3 2019 22:47                                                                                                    Page 46


  2830 00:BAD7: 10 19              BPL   LAB_1B3C          ; branch if stacked values
  2831                        
  2832 00:BAD9: AA                 TAX                     ; copy precedence (set flags)
  2833 00:BADA: F0 76              BEQ   LAB_1B9D          ; exit if done
  2834 00:BADC: 80 5D              BRA   LAB_1B86          ; else pop FAC2 and return, branch always
  2835                        
  2836                        LAB_1B2A
  2837 00:BADE: 26 11              ROL   Dtypef            ; shift data type flag into Cb
  2838 00:BAE0: 8A                 TXA                     ; copy compare function flag
  2839 00:BAE1: 85 11              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
  2840 00:BAE3: 2A                 ROL                     ; shift data type into compare function byte b0
  2841 00:BAE4: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  2842 00:BAE6: D0 02              BNE   LAB_1B34          ; branch if no underflow
  2843                        
  2844 00:BAE8: C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  2845                        LAB_1B34
  2846 00:BAEA: C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  2847             0000000C   TK_LT_PLUS  .EQU TK_LT-TK_PLUS
  2848 00:BAEC: A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
  2849 00:BAEE: 85 4D              STA   comp_f            ; save new compare function flag
  2850 00:BAF0: 80 D5              BRA   LAB_1B13          ; branch always
  2851                        
  2852                        LAB_1B3C
  2853 00:BAF2: D9 81 D1           CMP   LAB_OPPT,Y        ; compare with stacked function precedence
  2854 00:BAF5: B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
  2855 00:BAF7: 80 D7              BRA   LAB_1B1C          ; branch always
  2856                        
  2857                        ;.get vector, execute function then continue evaluation
  2858                        
  2859                        LAB_1B43
  2860 00:BAF9: B9 83 D1           LDA   LAB_OPPT+2,Y      ; get function vector high byte
  2861 00:BAFC: 48                 PHA                     ; onto stack
  2862 00:BAFD: B9 82 D1           LDA   LAB_OPPT+1,Y      ; get function vector low byte
  2863 00:BB00: 48                 PHA                     ; onto stack
  2864                                                      ; now push sign, round FAC1 and put on stack
  2865 00:BB01: 20 10 BB           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
  2866                                                      ; the function
  2867 00:BB04: A5 4D              LDA   comp_f            ; get compare function flag
  2868 00:BB06: 48                 PHA                     ; push compare evaluation byte
  2869 00:BB07: B9 81 D1           LDA   LAB_OPPT,Y        ; get precedence byte
  2870 00:BB0A: 4C 85 BA           JMP   LAB_1ACC          ; continue evaluating expression
  2871                        
  2872                        LAB_1B53
  2873 00:BB0D: 4C 97 BB           JMP   LAB_SNER          ; do syntax error then warm start
  2874                        
  2875                        ; push sign, round FAC1 and put on stack
  2876                        
  2877                        LAB_1B5B
  2878 00:BB10: 68                 PLA                     ; get return addr low byte
  2879 00:BB11: 85 23              STA   ut1_pl            ; save it
  2880 00:BB13: E6 23              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
  2881                                                      ; note! no check is made on the high byte! if the calling
  2882                                                      ; routine assembles to a page edge then this all goes
  2883                                                      ; horribly wrong !!!
  2884 00:BB15: 68                 PLA                     ; get return addr high byte
  2885 00:BB16: 85 24              STA   ut1_ph            ; save it
  2886 00:BB18: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  2887 00:BB1A: 48                 PHA                     ; push sign
  2888                        
  2889                        ; round FAC1 and put on stack
  2890                        
  2891                        LAB_1B66
  2892 00:BB1B: 20 4E C8           JSR   LAB_27BA          ; round FAC1
  Sun Mar  3 2019 22:47                                                                                                    Page 47


  2893 00:BB1E: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  2894 00:BB20: 48                 PHA                     ; push on stack
  2895 00:BB21: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  2896 00:BB23: 48                 PHA                     ; push on stack
  2897 00:BB24: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  2898 00:BB26: 48                 PHA                     ; push on stack
  2899 00:BB27: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  2900 00:BB29: 48                 PHA                     ; push on stack
  2901 00:BB2A: 6C 23 00           JMP   (ut1_pl)          ; return, sort of
  2902                        
  2903                        ; do functions
  2904                        
  2905                        LAB_1B78
  2906 00:BB2D: A0 FF              LDY   #$FF              ; flag function
  2907 00:BB2F: 68                 PLA                     ; pull precedence byte
  2908                        LAB_1B7B
  2909 00:BB30: F0 20              BEQ   LAB_1B9D          ; exit if done
  2910                        
  2911                        LAB_1B7D
  2912 00:BB32: C9 64              CMP   #$64              ; compare previous precedence with $64
  2913 00:BB34: F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
  2914                        
  2915 00:BB36: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  2916                        LAB_1B84
  2917 00:BB39: 84 4B              STY   prstk             ; save precedence stacked flag
  2918                        
  2919                                                      ; pop FAC2 and return
  2920                        LAB_1B86
  2921 00:BB3B: 68                 PLA                     ; pop byte
  2922 00:BB3C: 4A                 LSR                     ; shift out comparison evaluation lowest bit
  2923 00:BB3D: 85 15              STA   Cflag             ; save comparison evaluation flag
  2924 00:BB3F: 68                 PLA                     ; pop exponent
  2925 00:BB40: 85 65              STA   FAC2_e            ; save FAC2 exponent
  2926 00:BB42: 68                 PLA                     ; pop mantissa1
  2927 00:BB43: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  2928 00:BB45: 68                 PLA                     ; pop mantissa2
  2929 00:BB46: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  2930 00:BB48: 68                 PLA                     ; pop mantissa3
  2931 00:BB49: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  2932 00:BB4B: 68                 PLA                     ; pop sign
  2933 00:BB4C: 85 69              STA   FAC2_s            ; save FAC2 sign (b7)
  2934 00:BB4E: 45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  2935 00:BB50: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  2936                        LAB_1B9D
  2937 00:BB52: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  2938 00:BB54: 60                 RTS
  2939                        
  2940                        ; print "..." string to string util area
  2941                        
  2942                        LAB_1BC1
  2943 00:BB55: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2944 00:BB57: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2945 00:BB59: 69 00              ADC   #$00              ; add carry to low byte
  2946 00:BB5B: 90 01              BCC   LAB_1BCA          ; branch if no overflow
  2947                        
  2948 00:BB5D: C8                 INY                     ; increment high byte
  2949                        LAB_1BCA
  2950 00:BB5E: 20 CE C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2951 00:BB61: 4C 4C C4           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
  2952                        
  2953                        ; get value from line
  2954                        
  2955                        LAB_GVAL
  Sun Mar  3 2019 22:47                                                                                                    Page 48


  2956 00:BB64: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2957 00:BB67: B0 03              BCS   LAB_1BAC          ; branch if not numeric character
  2958                        
  2959                                                      ; else numeric string found (e.g. 123)
  2960                        LAB_1BA9
  2961 00:BB69: 4C 16 C9           JMP   LAB_2887          ; get FAC1 from string and return
  2962                        
  2963                        ; get value from line .. continued
  2964                        
  2965                                                      ; wasn't a number so ..
  2966                        LAB_1BAC
  2967 00:BB6C: AA                 TAX                     ; set the flags
  2968 00:BB6D: 30 2D              BMI   LAB_1BD0          ; if -ve go test token values
  2969                        
  2970                                                      ; else it is either a string, number, variable or (<expr>)
  2971 00:BB6F: C9 24              CMP   #'$'              ; compare with "$"
  2972 00:BB71: F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
  2973                        
  2974 00:BB73: C9 25              CMP   #'%'              ; else compare with "%"
  2975 00:BB75: F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
  2976                        
  2977 00:BB77: C9 2E              CMP   #'.'              ; compare with "."
  2978 00:BB79: F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
  2979                        
  2980                                                      ; it wasn't any sort of number so ..
  2981 00:BB7B: C9 22              CMP   #$22              ; compare with "
  2982 00:BB7D: F0 D6              BEQ   LAB_1BC1          ; branch if open quote
  2983                        
  2984                                                      ; wasn't any sort of number so ..
  2985                        
  2986                        ; evaluate expression within parentheses
  2987                        
  2988 00:BB7F: C9 28              CMP   #'('              ; compare with "("
  2989 00:BB81: D0 4C              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
  2990                        
  2991                        LAB_1BF7
  2992 00:BB83: 20 83 BA           JSR   LAB_EVEZ          ; evaluate expression, no decrement
  2993                        
  2994                        ; all the 'scan for' routines return the character after the sought character
  2995                        
  2996                        ; scan for ")" , else do syntax error then warm start
  2997                        
  2998                        LAB_1BFB
  2999 00:BB86: A9 29              LDA   #$29              ; load A with ")"
  3000                        
  3001                        ; scan for CHR$(A) , else do syntax error then warm start
  3002                        
  3003                        LAB_SCCA
  3004 00:BB88: D2 6E              CMP   (Bpntrl)          ; check next byte is = A
  3005 00:BB8A: D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
  3006                        
  3007 00:BB8C: 4C A5 CF           JMP   LAB_IGBY          ; increment and scan memory then return
  3008                        
  3009                        ; scan for "(" , else do syntax error then warm start
  3010                        
  3011                        LAB_1BFE
  3012 00:BB8F: A9 28              LDA   #$28              ; load A with "("
  3013 00:BB91: 80 F5              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3014                                                      ; (branch always)
  3015                        
  3016                        ; scan for "," , else do syntax error then warm start
  3017                        
  3018                        LAB_1C01
  Sun Mar  3 2019 22:47                                                                                                    Page 49


  3019 00:BB93: A9 2C              LDA   #$2C              ; load A with ","
  3020 00:BB95: 80 F1              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3021                                                      ; (branch always)
  3022                        
  3023                        ; syntax error then warm start
  3024                        
  3025                        LAB_SNER
  3026 00:BB97: A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
  3027 00:BB99: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  3028                        
  3029                        ; get value from line .. continued
  3030                        ; do tokens
  3031                        
  3032                        LAB_1BD0
  3033 00:BB9C: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  3034 00:BB9E: F0 28              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
  3035                        
  3036                                                      ; wasn't -n so ..
  3037 00:BBA0: C9 B2              CMP   #TK_PLUS          ; compare with token for +
  3038 00:BBA2: F0 C0              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
  3039                        
  3040 00:BBA4: C9 AE              CMP   #TK_NOT           ; compare with token for NOT
  3041 00:BBA6: D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
  3042                        
  3043                                                      ; was NOT token
  3044             0000000B   TK_EQUAL_PLUS     .EQU TK_EQUAL-TK_PLUS
  3045 00:BBA8: A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
  3046 00:BBAA: 80 1E              BRA   LAB_1C13          ; do set-up for function then execute (branch always)
  3047                        
  3048                        ; do = compare
  3049                        
  3050                        LAB_EQUAL
  3051 00:BBAC: 20 33 BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3052 00:BBAF: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3053 00:BBB1: 49 FF              EOR   #$FF              ; invert it
  3054 00:BBB3: A8                 TAY                     ; copy it
  3055 00:BBB4: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3056 00:BBB6: 49 FF              EOR   #$FF              ; invert it
  3057 00:BBB8: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3058                        
  3059                        ; get value from line .. continued
  3060                        
  3061                                                      ; wasn't +, -, or NOT so ..
  3062                        LAB_1BE7
  3063 00:BBBB: C9 AB              CMP   #TK_FN            ; compare with token for FN
  3064 00:BBBD: D0 03              BNE   LAB_1BEE          ; branch if not token for FN
  3065                        
  3066 00:BBBF: 4C 3F C0           JMP   LAB_201E          ; go evaluate FNx
  3067                        
  3068                        ; get value from line .. continued
  3069                        
  3070                                                      ; wasn't +, -, NOT or FN so ..
  3071                        LAB_1BEE
  3072 00:BBC2: E9 BF              SBC   #TK_SGN           ; subtract with token for SGN
  3073 00:BBC4: B0 18              BCS   LAB_1C27          ; if a function token go do it
  3074 00:BBC6: 80 CF              BRA   LAB_SNER          ; else do syntax error
  3075                        
  3076                        ; set-up for functions
  3077                        
  3078                        LAB_1C11
  3079             0000000A   TK_GT_PLUS  .EQU TK_GT-TK_PLUS
  3080 00:BBC8: A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
  3081                        LAB_1C13
  Sun Mar  3 2019 22:47                                                                                                    Page 50


  3082 00:BBCA: 68                 PLA                     ; dump return address low byte
  3083 00:BBCB: 68                 PLA                     ; dump return address high byte
  3084 00:BBCC: 4C D1 BA           JMP   LAB_1B1D          ; execute function then continue evaluation
  3085                        
  3086                        ; variable name set-up
  3087                        ; get (var), return value in FAC_1 and $ flag
  3088                        
  3089                        LAB_1C18
  3090 00:BBCF: 20 39 BD           JSR   LAB_GVAR          ; get (var) address
  3091 00:BBD2: 85 60              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
  3092 00:BBD4: 84 61              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
  3093 00:BBD6: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3094 00:BBD8: 30 03              BMI   LAB_1C25          ; if string then return (does RTS)
  3095                        
  3096                        LAB_1C24
  3097 00:BBDA: 4C F2 C7           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
  3098                        
  3099                        LAB_1C25
  3100 00:BBDD: 60                 RTS
  3101                        
  3102                        ; get value from line .. continued
  3103                        ; only functions left so ..
  3104                        
  3105                        ; set up function references
  3106                        
  3107                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3108                        ; to process function calls. now the function vector is computed and pushed on the stack
  3109                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3110                        ; is calculated and the routine called, if not this routine just does RTS. whichever
  3111                        ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3112                        ; the function code
  3113                        
  3114                        ; this also removes some less than elegant code that was used to bypass type checking
  3115                        ; for functions that returned strings
  3116                        
  3117                        LAB_1C27
  3118 00:BBDE: 0A                 ASL                     ; *2 (2 bytes per function address)
  3119 00:BBDF: A8                 TAY                     ; copy to index
  3120                        
  3121 00:BBE0: B9 3C D1           LDA   LAB_FTBM,Y        ; get function jump vector high byte
  3122 00:BBE3: 48                 PHA                     ; push functions jump vector high byte
  3123 00:BBE4: B9 3B D1           LDA   LAB_FTBL,Y        ; get function jump vector low byte
  3124 00:BBE7: 48                 PHA                     ; push functions jump vector low byte
  3125                        
  3126 00:BBE8: B9 F6 D0           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
  3127 00:BBEB: F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
  3128                        
  3129 00:BBED: 48                 PHA                     ; push functions pre process vector high byte
  3130 00:BBEE: B9 F5 D0           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
  3131 00:BBF1: 48                 PHA                     ; push functions pre process vector low byte
  3132                        
  3133                        LAB_1C56
  3134 00:BBF2: 60                 RTS                     ; do function, or pre process, call
  3135                        
  3136                        ; process string expression in parenthesis
  3137                        
  3138                        LAB_PPFS
  3139 00:BBF3: 20 83 BB           JSR   LAB_1BF7          ; process expression in parenthesis
  3140 00:BBF6: 4C 6C BA           JMP   LAB_CTST          ; check if source is string then do function,
  3141                                                      ; else do type mismatch
  3142                        
  3143                        ; process numeric expression in parenthesis
  3144                        
  Sun Mar  3 2019 22:47                                                                                                    Page 51


  3145                        LAB_PPFN
  3146 00:BBF9: 20 83 BB           JSR   LAB_1BF7          ; process expression in parenthesis
  3147 00:BBFC: 4C 69 BA           JMP   LAB_CTNM          ; check if source is numeric then do function,
  3148                                                      ; else do type mismatch
  3149                        
  3150                        ; set numeric data type and increment BASIC execute pointer
  3151                        
  3152                        LAB_PPBI
  3153 00:BBFF: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3154 00:BC01: 4C A5 CF           JMP   LAB_IGBY          ; increment and scan memory then do function
  3155                        
  3156                        ; process string for LEFT$, RIGHT$ or MID$
  3157                        
  3158                        LAB_LRMS
  3159 00:BC04: 20 83 BA           JSR   LAB_EVEZ          ; evaluate (should be string) expression
  3160 00:BC07: 20 93 BB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3161 00:BC0A: 20 6C BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  3162 00:BC0D: FA                 PLX                     ; get function jump vector low byte
  3163 00:BC0E: 7A                 PLY                     ; get function jump vector high byte
  3164 00:BC0F: A5 61              LDA   des_ph            ; get descriptor pointer high byte
  3165 00:BC11: 48                 PHA                     ; push string pointer high byte
  3166 00:BC12: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  3167 00:BC14: 48                 PHA                     ; push string pointer low byte
  3168 00:BC15: 5A                 PHY                     ; save function jump vector high byte
  3169 00:BC16: DA                 PHX                     ; save function jump vector low byte
  3170 00:BC17: 20 0C C4           JSR   LAB_GTBY          ; get byte parameter
  3171 00:BC1A: 8A                 TXA                     ; copy byte parameter to A
  3172 00:BC1B: 60                 RTS                     ; go do function
  3173                        
  3174                        ; process numeric expression(s) for BIN$ or HEX$
  3175                        
  3176                        LAB_BHSS
  3177 00:BC1C: 20 83 BA           JSR   LAB_EVEZ          ; process expression
  3178 00:BC1F: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3179 00:BC22: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3180 00:BC24: C9 98              CMP   #$98              ; compare with exponent = 2^24
  3181 00:BC26: B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
  3182                        
  3183 00:BC28: 20 C0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  3184 00:BC2B: A2 02              LDX   #$02              ; 3 bytes to do
  3185                        LAB_CFAC
  3186 00:BC2D: B5 5F              LDA   FAC1_1,X          ; get byte from FAC1
  3187 00:BC2F: 95 0A              STA   nums_1,X          ; save byte to temp
  3188 00:BC31: CA                 DEX                     ; decrement index
  3189 00:BC32: 10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
  3190                        
  3191 00:BC34: 20 AB CF           JSR   LAB_GBYT          ; get next BASIC byte
  3192 00:BC37: A2 00              LDX   #$00              ; set default to no leading "0"s
  3193 00:BC39: C9 29              CMP   #')'              ; compare with close bracket
  3194 00:BC3B: F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
  3195                        
  3196 00:BC3D: 20 5B C4           JSR   LAB_SCGB          ; scan for "," and get byte
  3197 00:BC40: 20 AB CF           JSR   LAB_GBYT          ; get last byte back
  3198 00:BC43: C9 29              CMP   #')'              ; is next character )
  3199 00:BC45: D0 01              BNE   LAB_BHER          ; if not ")" go do error
  3200                        
  3201                        LAB_1C54
  3202 00:BC47: 60                 RTS                     ; else do function
  3203                        
  3204                        LAB_BHER
  3205 00:BC48: 4C B5 BE           JMP   LAB_FCER          ; do function call error then warm start
  3206                        
  3207                        ; perform EOR
  Sun Mar  3 2019 22:47                                                                                                    Page 52


  3208                        
  3209                        ; added operator format is the same as AND or OR, precedence is the same as OR
  3210                        
  3211                        ; this bit worked first time but it took a while to sort out the operator table
  3212                        ; pointers and offsets afterwards!
  3213                        
  3214                        LAB_EOR
  3215 00:BC4B: 20 72 BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3216 00:BC4E: 45 0D              EOR   XOAw_l            ; EOR with expression 1 low byte
  3217 00:BC50: A8                 TAY                     ; save in Y
  3218 00:BC51: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3219 00:BC53: 45 0E              EOR   XOAw_h            ; EOR with expression 1 high byte
  3220 00:BC55: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3221                        
  3222                        ; perform OR
  3223                        
  3224                        LAB_OR
  3225 00:BC58: 20 72 BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3226 00:BC5B: 05 0D              ORA   XOAw_l            ; OR with expression 1 low byte
  3227 00:BC5D: A8                 TAY                     ; save in Y
  3228 00:BC5E: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3229 00:BC60: 05 0E              ORA   XOAw_h            ; OR with expression 1 high byte
  3230 00:BC62: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3231                        
  3232                        ; perform AND
  3233                        
  3234                        LAB_AND
  3235 00:BC65: 20 72 BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3236 00:BC68: 25 0D              AND   XOAw_l            ; AND with expression 1 low byte
  3237 00:BC6A: A8                 TAY                     ; save in Y
  3238 00:BC6B: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3239 00:BC6D: 25 0E              AND   XOAw_h            ; AND with expression 1 high byte
  3240 00:BC6F: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3241                        
  3242                        ; get first value for OR, AND or EOR
  3243                        
  3244                        GetFirst
  3245 00:BC72: 20 33 BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3246 00:BC75: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3247 00:BC77: 85 0E              STA   XOAw_h            ; save it
  3248 00:BC79: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3249 00:BC7B: 85 0D              STA   XOAw_l            ; save it
  3250 00:BC7D: 20 3F C5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3251 00:BC80: 20 33 BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3252 00:BC83: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3253                        LAB_1C95
  3254 00:BC85: 60                 RTS
  3255                        
  3256                        ; perform comparisons
  3257                        
  3258                        ; do < compare
  3259                        
  3260                        LAB_LTHAN
  3261 00:BC86: 20 6D BA           JSR   LAB_CKTM          ; type match check, set C for string
  3262 00:BC89: B0 12              BCS   LAB_1CAE          ; branch if string
  3263                        
  3264                                                      ; do numeric < compare
  3265 00:BC8B: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  3266 00:BC8D: 09 7F              ORA   #$7F              ; set all non sign bits
  3267 00:BC8F: 25 66              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
  3268 00:BC91: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  3269 00:BC93: A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  3270 00:BC95: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  Sun Mar  3 2019 22:47                                                                                                    Page 53


  3271 00:BC97: 20 88 C8           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
  3272 00:BC9A: AA                 TAX                     ; copy result
  3273 00:BC9B: 80 31              BRA   LAB_1CE1          ; go evaluate result
  3274                        
  3275                                                      ; do string < compare
  3276                        LAB_1CAE
  3277 00:BC9D: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3278 00:BC9F: C6 4D              DEC   comp_f            ; clear < bit in compare function flag
  3279 00:BCA1: 20 C5 C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  3280                                                      ; space returns with A = length, X=pointer low byte,
  3281                                                      ; Y=pointer high byte
  3282 00:BCA4: 85 5E              STA   str_ln            ; save length
  3283 00:BCA6: 86 5F              STX   str_pl            ; save string pointer low byte
  3284 00:BCA8: 84 60              STY   str_ph            ; save string pointer high byte
  3285 00:BCAA: A5 67              LDA   FAC2_2            ; get descriptor pointer low byte
  3286 00:BCAC: A4 68              LDY   FAC2_3            ; get descriptor pointer high byte
  3287 00:BCAE: 20 C9 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  3288                                                      ; returns with A = length, X=pointer low byte,
  3289                                                      ; Y=pointer high byte
  3290 00:BCB1: 86 67              STX   FAC2_2            ; save string pointer low byte
  3291 00:BCB3: 84 68              STY   FAC2_3            ; save string pointer high byte
  3292 00:BCB5: AA                 TAX                     ; copy length
  3293 00:BCB6: 38                 SEC                     ; set carry for subtract
  3294 00:BCB7: E5 5E              SBC   str_ln            ; subtract string 1 length
  3295 00:BCB9: F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
  3296                        
  3297 00:BCBB: A9 01              LDA   #$01              ; set str 1 length > string 2 length
  3298 00:BCBD: 90 04              BCC   LAB_1CD6          ; branch if so
  3299                        
  3300 00:BCBF: A6 5E              LDX   str_ln            ; get string 1 length
  3301 00:BCC1: A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
  3302                        LAB_1CD6
  3303 00:BCC3: 85 62              STA   FAC1_s            ; save length compare
  3304 00:BCC5: A0 FF              LDY   #$FF              ; set index
  3305 00:BCC7: E8                 INX                     ; adjust for loop
  3306                        LAB_1CDB
  3307 00:BCC8: C8                 INY                     ; increment index
  3308 00:BCC9: CA                 DEX                     ; decrement count
  3309 00:BCCA: D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
  3310                        
  3311 00:BCCC: A6 62              LDX   FAC1_s            ; get length compare back
  3312                        LAB_1CE1
  3313 00:BCCE: 30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
  3314                        
  3315 00:BCD0: 18                 CLC                     ; flag str 1 <= str 2
  3316 00:BCD1: 90 0C              BCC   LAB_1CF2          ; go evaluate result
  3317                        
  3318                        LAB_1CE6
  3319 00:BCD3: B1 67              LDA   (FAC2_2),Y        ; get string 2 byte
  3320 00:BCD5: D1 5F              CMP   (FAC1_1),Y        ; compare with string 1 byte
  3321 00:BCD7: F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
  3322                        
  3323 00:BCD9: A2 FF              LDX   #$FF              ; set str 1 < string 2
  3324 00:BCDB: B0 02              BCS   LAB_1CF2          ; branch if so
  3325                        
  3326 00:BCDD: A2 01              LDX   #$01              ;  set str 1 > string 2
  3327                        LAB_1CF2
  3328 00:BCDF: E8                 INX                     ; x = 0, 1 or 2
  3329 00:BCE0: 8A                 TXA                     ; copy to A
  3330 00:BCE1: 2A                 ROL                     ; *2 (1, 2 or 4)
  3331 00:BCE2: 25 15              AND   Cflag             ; AND with comparison evaluation flag
  3332 00:BCE4: F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
  3333                        
  Sun Mar  3 2019 22:47                                                                                                    Page 54


  3334 00:BCE6: A9 FF              LDA   #$FF              ; else set result true
  3335                        LAB_1CFB
  3336 00:BCE8: 4C 6F C8           JMP   LAB_27DB          ; save A as integer byte and return
  3337                        
  3338                        LAB_1CFE
  3339 00:BCEB: 20 93 BB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3340                        
  3341                        ; perform DIM
  3342                        
  3343                        LAB_DIM
  3344 00:BCEE: AA                 TAX                     ; copy "DIM" flag to X
  3345 00:BCEF: 20 3E BD           JSR   LAB_1D10          ; search for variable
  3346 00:BCF2: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  3347 00:BCF5: D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
  3348 00:BCF7: 60                 RTS
  3349                        
  3350                        ; perform << (left shift)
  3351                        
  3352                        LAB_LSHIFT
  3353 00:BCF8: 20 2E BD           JSR   GetPair           ; get integer expression and byte (no sign check)
  3354 00:BCFB: A5 60              LDA   FAC1_2            ; get expression high byte
  3355 00:BCFD: A6 2A              LDX   TempB             ; get shift count
  3356 00:BCFF: F0 22              BEQ   NoShift           ; branch if zero
  3357                        
  3358 00:BD01: E0 10              CPX   #$10              ; compare bit count with 16d
  3359 00:BD03: B0 23              BCS   TooBig            ; branch if >=
  3360                        
  3361                        Ls_loop
  3362 00:BD05: 06 61              ASL   FAC1_3            ; shift low byte
  3363 00:BD07: 2A                 ROL                     ; shift high byte
  3364 00:BD08: CA                 DEX                     ; decrement bit count
  3365 00:BD09: D0 FA              BNE   Ls_loop           ; loop if shift not complete
  3366                        
  3367 00:BD0B: A4 61              LDY   FAC1_3            ; get expression low byte
  3368 00:BD0D: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3369                        
  3370                        ; perform >> (right shift)
  3371                        
  3372                        LAB_RSHIFT
  3373 00:BD10: 20 2E BD           JSR   GetPair           ; get integer expression and byte (no sign check)
  3374 00:BD13: A5 60              LDA   FAC1_2            ; get expression high byte
  3375 00:BD15: A6 2A              LDX   TempB             ; get shift count
  3376 00:BD17: F0 0A              BEQ   NoShift           ; branch if zero
  3377                        
  3378 00:BD19: E0 10              CPX   #$10              ; compare bit count with 16d
  3379 00:BD1B: B0 0B              BCS   TooBig            ; branch if >=
  3380                        
  3381                        Rs_loop
  3382 00:BD1D: 4A                 LSR                     ; shift high byte
  3383 00:BD1E: 66 61              ROR   FAC1_3            ; shift low byte
  3384 00:BD20: CA                 DEX                     ; decrement bit count
  3385 00:BD21: D0 FA              BNE   Rs_loop           ; loop if shift not complete
  3386                        
  3387                        NoShift
  3388 00:BD23: A4 61              LDY   FAC1_3            ; get expression low byte
  3389 00:BD25: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3390                        
  3391                        TooBig
  3392 00:BD28: A9 00              LDA   #$00              ; clear high byte
  3393 00:BD2A: A8                 TAY                     ; copy to low byte
  3394 00:BD2B: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3395                        
  3396                        GetPair
  Sun Mar  3 2019 22:47                                                                                                    Page 55


  3397 00:BD2E: 20 0F C4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  3398 00:BD31: 86 2A              STX   TempB             ; save it
  3399 00:BD33: 20 3F C5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3400 00:BD36: 4C 33 BE           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
  3401                        
  3402                        ; search for variable
  3403                        
  3404                        ; return pointer to variable in Cvaral/Cvarah
  3405                        
  3406                        LAB_GVAR
  3407 00:BD39: A2 00              LDX   #$00              ; set DIM flag = $00
  3408 00:BD3B: 20 AB CF           JSR   LAB_GBYT          ; scan memory (1st character)
  3409                        LAB_1D10
  3410 00:BD3E: 86 10              STX   Defdim            ; save DIM flag
  3411                        LAB_1D12
  3412 00:BD40: 85 45              STA   Varnm1            ; save 1st character
  3413 00:BD42: 29 7F              AND   #$7F              ; clear FN flag bit
  3414 00:BD44: 20 AB BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3415 00:BD47: B0 03              BCS   LAB_1D1F          ; branch if ok
  3416                        
  3417 00:BD49: 4C 97 BB           JMP   LAB_SNER          ; else syntax error then warm start
  3418                        
  3419                                                      ; was variable name so ..
  3420                        LAB_1D1F
  3421 00:BD4C: A2 00              LDX   #$00              ; set DIM flag = $00
  3422 00:BD4E: 86 11              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3423 00:BD50: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
  3424 00:BD53: 90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
  3425                        
  3426                                                      ; 2nd character wasn't "0" to "9" so ..
  3427 00:BD55: 20 AB BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3428 00:BD58: 90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
  3429                        
  3430                        LAB_1D2D
  3431 00:BD5A: AA                 TAX                     ; copy 2nd character
  3432                        
  3433                                                      ; ignore further (valid) characters in the variable name
  3434                        LAB_1D2E
  3435 00:BD5B: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
  3436 00:BD5E: 90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
  3437                        
  3438 00:BD60: 20 AB BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3439 00:BD63: B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
  3440                        
  3441                                                      ; check if string variable
  3442                        LAB_1D38
  3443 00:BD65: C9 24              CMP   #'$'              ; compare with "$"
  3444 00:BD67: D0 0B              BNE   LAB_1D47          ; branch if not string
  3445                        
  3446                        ; to introduce a new variable type (% suffix for integers say) then this branch
  3447                        ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3448                        
  3449                                                      ; type is string
  3450 00:BD69: A9 FF              LDA   #$FF              ; set data type = string
  3451 00:BD6B: 85 11              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
  3452 00:BD6D: 8A                 TXA                     ; get 2nd character back
  3453 00:BD6E: 09 80              ORA   #$80              ; set top bit (indicate string var)
  3454 00:BD70: AA                 TAX                     ; copy back to 2nd character temp
  3455 00:BD71: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  3456                        
  3457                        ; after we have determined the variable type we need to come back here to determine
  3458                        ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3459                        
  Sun Mar  3 2019 22:47                                                                                                    Page 56


  3460                        LAB_1D47                      ; gets here with character after var name in A
  3461 00:BD74: 86 46              STX   Varnm2            ; save 2nd character
  3462 00:BD76: 05 13              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
  3463 00:BD78: C9 28              CMP   #'('              ; compare with "("
  3464 00:BD7A: D0 03              BNE   LAB_1D53          ; branch if not "("
  3465                        
  3466 00:BD7C: 4C 45 BE           JMP   LAB_1E17          ; go find, or make, array
  3467                        
  3468                        ; either find or create var
  3469                        ; var name (1st two characters only!) is in Varnm1,Varnm2
  3470                        
  3471                                                      ; variable name wasn't var(... so look for plain var
  3472                        LAB_1D53
  3473 00:BD7F: 64 13              STZ   Sufnxf            ; clear subscript/FNX flag
  3474 00:BD81: A5 2D              LDA   Svarl             ; get start of vars low byte
  3475 00:BD83: A6 2E              LDX   Svarh             ; get start of vars high byte
  3476 00:BD85: A0 00              LDY   #$00              ; clear index
  3477                        LAB_1D5D
  3478 00:BD87: 86 5D              STX   Vrschh            ; save search address high byte
  3479                        LAB_1D5F
  3480 00:BD89: 85 5C              STA   Vrschl            ; save search address low byte
  3481 00:BD8B: E4 30              CPX   Sarryh            ; compare high address with var space end
  3482 00:BD8D: D0 04              BNE   LAB_1D69          ; skip next compare if <>
  3483                        
  3484                                                      ; high addresses were = so compare low addresses
  3485 00:BD8F: C5 2F              CMP   Sarryl            ; compare low address with var space end
  3486 00:BD91: F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
  3487                        
  3488                        LAB_1D69
  3489 00:BD93: A5 45              LDA   Varnm1            ; get 1st character of var to find
  3490 00:BD95: D1 5C              CMP   (Vrschl),Y        ; compare with variable name 1st character
  3491 00:BD97: D0 08              BNE   LAB_1D77          ; branch if no match
  3492                        
  3493                                                      ; 1st characters match so compare 2nd characters
  3494 00:BD99: A5 46              LDA   Varnm2            ; get 2nd character of var to find
  3495 00:BD9B: C8                 INY                     ; index to point to variable name 2nd character
  3496 00:BD9C: D1 5C              CMP   (Vrschl),Y        ; compare with variable name 2nd character
  3497 00:BD9E: F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
  3498                        
  3499 00:BDA0: 88                 DEY                     ; else decrement index (now = $00)
  3500                        LAB_1D77
  3501 00:BDA1: 18                 CLC                     ; clear carry for add
  3502 00:BDA2: A5 5C              LDA   Vrschl            ; get search address low byte
  3503 00:BDA4: 69 06              ADC   #$06              ; +6 (offset to next var name)
  3504 00:BDA6: 90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
  3505                        
  3506 00:BDA8: E8                 INX                     ; else increment high byte
  3507 00:BDA9: 80 DC              BRA   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
  3508                        
  3509                        ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
  3510                        
  3511                        LAB_CASC
  3512 00:BDAB: C9 61              CMP   #'a'              ; compare with "a"
  3513 00:BDAD: B0 0A              BCS   LAB_1D83          ; go check <"z"+1
  3514                        
  3515                        ; check byte, return C=0 if<"A" or >"Z"
  3516                        
  3517                        LAB_1D82
  3518 00:BDAF: C9 41              CMP   #'A'              ; compare with "A"
  3519 00:BDB1: 90 05              BCC   LAB_1D8A          ; exit if less
  3520                        
  3521                                                      ; carry is set
  3522 00:BDB3: E9 5B              SBC   #$5B              ; subtract "Z"+1
  Sun Mar  3 2019 22:47                                                                                                    Page 57


  3523 00:BDB5: 38                 SEC                     ; set carry
  3524 00:BDB6: E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
  3525                                                      ; carry clear if byte>$5A
  3526                        LAB_1D8A
  3527 00:BDB8: 60                 RTS
  3528                        
  3529                        LAB_1D83
  3530 00:BDB9: E9 7B              SBC   #$7B              ; subtract "z"+1
  3531 00:BDBB: 38                 SEC                     ; set carry
  3532 00:BDBC: E9 85              SBC   #$85              ; subtract $85 (restore byte)
  3533                                                      ; carry clear if byte>$7A
  3534 00:BDBE: 60                 RTS
  3535                        
  3536                                                      ; reached end of variable mem without match
  3537                                                      ; .. so create new variable
  3538                        LAB_1D8B
  3539 00:BDBF: 68                 PLA                     ; pop return address low byte
  3540 00:BDC0: 48                 PHA                     ; push return address low byte
  3541             0000BBD1   LAB_1C18p2  .EQU LAB_1C18+2
  3542 00:BDC1: C9 D1              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
  3543 00:BDC3: D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
  3544                        
  3545                        ; This will only drop through if the call was from LAB_1C18 and is only called
  3546                        ; from there if it is searching for a variable from the RHS of a LET a=b statement
  3547                        ; it prevents the creation of variables not assigned a value.
  3548                        
  3549                        ; value returned by this is either numeric zero (exponent byte is $00) or null string
  3550                        ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3551                        
  3552                        ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3553                        
  3554                        ; this is where you would put the undefined variable error call e.g.
  3555                        
  3556                        ;                             ; variable doesn't exist so flag error
  3557                        ;     LDX   #$24              ; error code $24 ("undefined variable" error)
  3558                        ;     JMP   LAB_XERR          ; do error #X then warm start
  3559                        
  3560                        ; the above code has been tested and works a treat! (it replaces the three code lines
  3561                        ; below)
  3562                        
  3563                                                      ; else return dummy null value
  3564 00:BDC5: A9 7F              LDA   #<LAB_1D96        ; low byte point to $00,$00
  3565                                                      ; (uses part of misc constants table)
  3566 00:BDC7: A0 D0              LDY   #>LAB_1D96        ; high byte point to $00,$00
  3567 00:BDC9: 60                 RTS
  3568                        
  3569                                                      ; create new numeric variable
  3570                        LAB_1D98
  3571 00:BDCA: A5 2F              LDA   Sarryl            ; get var mem end low byte
  3572 00:BDCC: A4 30              LDY   Sarryh            ; get var mem end high byte
  3573 00:BDCE: 85 5C              STA   Ostrtl            ; save old block start low byte
  3574 00:BDD0: 84 5D              STY   Ostrth            ; save old block start high byte
  3575 00:BDD2: A5 31              LDA   Earryl            ; get array mem end low byte
  3576 00:BDD4: A4 32              LDY   Earryh            ; get array mem end high byte
  3577 00:BDD6: 85 58              STA   Obendl            ; save old block end low byte
  3578 00:BDD8: 84 59              STY   Obendh            ; save old block end high byte
  3579 00:BDDA: 18                 CLC                     ; clear carry for add
  3580 00:BDDB: 69 06              ADC   #$06              ; +6 (space for one var)
  3581 00:BDDD: 90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
  3582                        
  3583 00:BDDF: C8                 INY                     ; else increment high byte
  3584                        LAB_1DAE
  3585 00:BDE0: 85 56              STA   Nbendl            ; set new block end low byte
  Sun Mar  3 2019 22:47                                                                                                    Page 58


  3586 00:BDE2: 84 57              STY   Nbendh            ; set new block end high byte
  3587 00:BDE4: 20 89 B0           JSR   LAB_11CF          ; open up space in memory
  3588 00:BDE7: A5 56              LDA   Nbendl            ; get new start low byte
  3589 00:BDE9: A4 57              LDY   Nbendh            ; get new start high byte (-$100)
  3590 00:BDEB: C8                 INY                     ; correct high byte
  3591 00:BDEC: 85 2F              STA   Sarryl            ; save new var mem end low byte
  3592 00:BDEE: 84 30              STY   Sarryh            ; save new var mem end high byte
  3593 00:BDF0: A0 00              LDY   #$00              ; clear index
  3594 00:BDF2: A5 45              LDA   Varnm1            ; get var name 1st character
  3595 00:BDF4: 91 5C              STA   (Vrschl),Y        ; save var name 1st character
  3596 00:BDF6: C8                 INY                     ; increment index
  3597 00:BDF7: A5 46              LDA   Varnm2            ; get var name 2nd character
  3598 00:BDF9: 91 5C              STA   (Vrschl),Y        ; save var name 2nd character
  3599 00:BDFB: A9 00              LDA   #$00              ; clear A
  3600 00:BDFD: C8                 INY                     ; increment index
  3601 00:BDFE: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3602 00:BE00: C8                 INY                     ; increment index
  3603 00:BE01: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3604 00:BE03: C8                 INY                     ; increment index
  3605 00:BE04: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3606 00:BE06: C8                 INY                     ; increment index
  3607 00:BE07: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3608                        
  3609                                                      ; found a match for var ((Vrschl) = ptr)
  3610                        LAB_1DD7
  3611 00:BE09: A5 5C              LDA   Vrschl            ; get var address low byte
  3612 00:BE0B: 18                 CLC                     ; clear carry for add
  3613 00:BE0C: 69 02              ADC   #$02              ; +2 (offset past var name bytes)
  3614 00:BE0E: A4 5D              LDY   Vrschh            ; get var address high byte
  3615 00:BE10: 90 01              BCC   LAB_1DE1          ; branch if no overflow from add
  3616                        
  3617 00:BE12: C8                 INY                     ; else increment high byte
  3618                        LAB_1DE1
  3619 00:BE13: 85 47              STA   Cvaral            ; save current var address low byte
  3620 00:BE15: 84 48              STY   Cvarah            ; save current var address high byte
  3621 00:BE17: 60                 RTS
  3622                        
  3623                        ; set-up array pointer (Adatal/h) to first element in array
  3624                        ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3625                        
  3626                        LAB_1DE6
  3627 00:BE18: A5 0F              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
  3628 00:BE1A: 0A                 ASL                     ; *2 (also clears the carry !)
  3629 00:BE1B: 69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
  3630 00:BE1D: 65 5C              ADC   Astrtl            ; add array start pointer low byte
  3631 00:BE1F: A4 5D              LDY   Astrth            ; get array pointer high byte
  3632 00:BE21: 90 01              BCC   LAB_1DF2          ; branch if no overflow
  3633                        
  3634 00:BE23: C8                 INY                     ; else increment high byte
  3635                        LAB_1DF2
  3636 00:BE24: 85 56              STA   Adatal            ; save array data pointer low byte
  3637 00:BE26: 84 57              STY   Adatah            ; save array data pointer high byte
  3638 00:BE28: 60                 RTS
  3639                        
  3640                        ; evaluate integer expression
  3641                        
  3642                        LAB_EVIN
  3643 00:BE29: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  3644 00:BE2C: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  3645                                                      ; else do type mismatch
  3646                        
  3647                        ; evaluate integer expression (no check)
  3648                        
  Sun Mar  3 2019 22:47                                                                                                    Page 59


  3649                        LAB_EVPI
  3650 00:BE2F: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  3651 00:BE31: 30 0D              BMI   LAB_1E12          ; do function call error if -ve
  3652                        
  3653                        ; evaluate integer expression (no sign check)
  3654                        
  3655                        LAB_EVIR
  3656 00:BE33: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3657 00:BE35: C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
  3658 00:BE37: 90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
  3659                        
  3660 00:BE39: A9 86              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
  3661 00:BE3B: A0 D0              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
  3662 00:BE3D: 20 88 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  3663                        LAB_1E12
  3664 00:BE40: D0 73              BNE   LAB_FCER          ; if <> do function call error then warm start
  3665                        
  3666                        LAB_1E14
  3667 00:BE42: 4C C0 C8           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
  3668                        
  3669                        ; find or make array
  3670                        
  3671                        LAB_1E17
  3672 00:BE45: A5 10              LDA   Defdim            ; get DIM flag
  3673 00:BE47: 48                 PHA                     ; push it
  3674 00:BE48: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3675 00:BE4A: 48                 PHA                     ; push it
  3676 00:BE4B: A0 00              LDY   #$00              ; clear dimensions count
  3677                        
  3678                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3679                        
  3680                        LAB_1E1F
  3681 00:BE4D: 5A                 PHY                     ; save dimensions count
  3682 00:BE4E: A5 46              LDA   Varnm2            ; get array name 2nd byte
  3683 00:BE50: 48                 PHA                     ; save it
  3684 00:BE51: A5 45              LDA   Varnm1            ; get array name 1st byte
  3685 00:BE53: 48                 PHA                     ; save it
  3686 00:BE54: 20 29 BE           JSR   LAB_EVIN          ; evaluate integer expression
  3687 00:BE57: 68                 PLA                     ; pull array name 1st byte
  3688 00:BE58: 85 45              STA   Varnm1            ; restore array name 1st byte
  3689 00:BE5A: 68                 PLA                     ; pull array name 2nd byte
  3690 00:BE5B: 85 46              STA   Varnm2            ; restore array name 2nd byte
  3691 00:BE5D: 7A                 PLY                     ; restore dimensions count
  3692 00:BE5E: BA                 TSX                     ; copy stack pointer
  3693 00:BE5F: BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
  3694 00:BE62: 48                 PHA                     ; push it
  3695 00:BE63: BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
  3696 00:BE66: 48                 PHA                     ; push it
  3697 00:BE67: A5 60              LDA   FAC1_2            ; get this dimension size high byte
  3698 00:BE69: 9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
  3699 00:BE6C: A5 61              LDA   FAC1_3            ; get this dimension size low byte
  3700 00:BE6E: 9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
  3701 00:BE71: C8                 INY                     ; increment dimensions count
  3702 00:BE72: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  3703 00:BE75: C9 2C              CMP   #','              ; compare with ","
  3704 00:BE77: F0 D4              BEQ   LAB_1E1F          ; if found go do next dimension
  3705                        
  3706 00:BE79: 84 0F              STY   Dimcnt            ; store dimensions count
  3707 00:BE7B: 20 86 BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  3708 00:BE7E: 68                 PLA                     ; pull data type flag
  3709 00:BE7F: 85 11              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
  3710 00:BE81: 68                 PLA                     ; pull DIM flag
  3711 00:BE82: 85 10              STA   Defdim            ; restore DIM flag
  Sun Mar  3 2019 22:47                                                                                                    Page 60


  3712 00:BE84: A6 2F              LDX   Sarryl            ; get array mem start low byte
  3713 00:BE86: A5 30              LDA   Sarryh            ; get array mem start high byte
  3714                        
  3715                        ; now check to see if we are at the end of array memory (we would be if there were
  3716                        ; no arrays).
  3717                        
  3718                        LAB_1E5C
  3719 00:BE88: 86 5C              STX   Astrtl            ; save as array start pointer low byte
  3720 00:BE8A: 85 5D              STA   Astrth            ; save as array start pointer high byte
  3721 00:BE8C: C5 32              CMP   Earryh            ; compare with array mem end high byte
  3722 00:BE8E: D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
  3723                        
  3724 00:BE90: E4 31              CPX   Earryl            ; else compare with array mem end low byte
  3725 00:BE92: F0 3A              BEQ   LAB_1EA1          ; go build array if not found
  3726                        
  3727                                                      ; search for array
  3728                        LAB_1E68
  3729 00:BE94: A0 00              LDY   #$00              ; clear index
  3730 00:BE96: B1 5C              LDA   (Astrtl),Y        ; get array name first byte
  3731 00:BE98: C8                 INY                     ; increment index to second name byte
  3732 00:BE99: C5 45              CMP   Varnm1            ; compare with this array name first byte
  3733 00:BE9B: D0 06              BNE   LAB_1E77          ; branch if no match
  3734                        
  3735 00:BE9D: A5 46              LDA   Varnm2            ; else get this array name second byte
  3736 00:BE9F: D1 5C              CMP   (Astrtl),Y        ; compare with array name second byte
  3737 00:BEA1: F0 17              BEQ   LAB_1E8D          ; array found so branch
  3738                        
  3739                                                      ; no match
  3740                        LAB_1E77
  3741 00:BEA3: C8                 INY                     ; increment index
  3742 00:BEA4: B1 5C              LDA   (Astrtl),Y        ; get array size low byte
  3743 00:BEA6: 18                 CLC                     ; clear carry for add
  3744 00:BEA7: 65 5C              ADC   Astrtl            ; add array start pointer low byte
  3745 00:BEA9: AA                 TAX                     ; copy low byte to X
  3746 00:BEAA: C8                 INY                     ; increment index
  3747 00:BEAB: B1 5C              LDA   (Astrtl),Y        ; get array size high byte
  3748 00:BEAD: 65 5D              ADC   Astrth            ; add array mem pointer high byte
  3749 00:BEAF: 90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
  3750                        
  3751                        ; do array bounds error
  3752                        
  3753                        LAB_1E85
  3754 00:BEB1: A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
  3755 00:BEB3: 80 02              BRA   LAB_1E8A          ; branch around next instruction, saves on clock cycle
  3756                        
  3757                        ; do function call error
  3758                        
  3759                        LAB_FCER
  3760 00:BEB5: A2 08              LDX   #$08              ; error code $08 ("Function call" error)
  3761                        LAB_1E8A
  3762 00:BEB7: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  3763                        
  3764                                                      ; found array, are we trying to dimension it?
  3765                        LAB_1E8D
  3766 00:BEBA: A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
  3767 00:BEBC: A5 10              LDA   Defdim            ; get DIM flag
  3768 00:BEBE: D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
  3769                                                      ; start
  3770                        
  3771                        ; found the array and we're not dimensioning it so we must find an element in it
  3772                        
  3773 00:BEC0: 20 18 BE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  3774                                                      ; (Astrtl,Astrth points to start of array)
  Sun Mar  3 2019 22:47                                                                                                    Page 61


  3775 00:BEC3: A5 0F              LDA   Dimcnt            ; get dimensions count
  3776 00:BEC5: A0 04              LDY   #$04              ; set index to array's # of dimensions
  3777 00:BEC7: D1 5C              CMP   (Astrtl),Y        ; compare with no of dimensions
  3778 00:BEC9: D0 E6              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
  3779                                                      ; dimensions" error here .. if we want a different
  3780                                                      ; error message
  3781                        
  3782 00:BECB: 4C 51 BF           JMP   LAB_1F28          ; found array so go get element
  3783                                                      ; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3784                                                      ; Dimcnt and save it at (Astrtl),Y which is already the
  3785                                                      ; same or we would have taken the BNE)
  3786                        
  3787                                                      ; array not found, so build it
  3788                        LAB_1EA1
  3789 00:BECE: 20 18 BE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  3790                                                      ; (Astrtl,Astrth points to start of array)
  3791 00:BED1: 20 D6 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  3792                                                      ; addr to check is in AY (low/high)
  3793 00:BED4: A0 00              LDY   #$00              ; clear Y (don't need to clear A)
  3794 00:BED6: 84 6D              STY   Aspth             ; clear array data size high byte
  3795 00:BED8: A5 45              LDA   Varnm1            ; get variable name 1st byte
  3796 00:BEDA: 91 5C              STA   (Astrtl),Y        ; save array name 1st byte
  3797 00:BEDC: C8                 INY                     ; increment index
  3798 00:BEDD: A5 46              LDA   Varnm2            ; get variable name 2nd byte
  3799 00:BEDF: 91 5C              STA   (Astrtl),Y        ; save array name 2nd byte
  3800 00:BEE1: A5 0F              LDA   Dimcnt            ; get dimensions count
  3801 00:BEE3: A0 04              LDY   #$04              ; index to dimension count
  3802 00:BEE5: 84 6C              STY   Asptl             ; set array data size low byte (four bytes per element)
  3803 00:BEE7: 91 5C              STA   (Astrtl),Y        ; set array's dimensions count
  3804                        
  3805                                                      ; now calculate the size of the data space for the array
  3806 00:BEE9: 18                 CLC                     ; clear carry for add (clear on subsequent loops)
  3807                        LAB_1EC0
  3808 00:BEEA: A2 0B              LDX   #$0B              ; set default dimension value low byte
  3809 00:BEEC: A9 00              LDA   #$00              ; set default dimension value high byte
  3810 00:BEEE: 24 10              BIT   Defdim            ; test default DIM flag
  3811 00:BEF0: 50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
  3812                        
  3813 00:BEF2: 68                 PLA                     ; else pull dimension value low byte
  3814 00:BEF3: 69 01              ADC   #$01              ; +1 (allow for zeroeth element)
  3815 00:BEF5: AA                 TAX                     ; copy low byte to X
  3816 00:BEF6: 68                 PLA                     ; pull dimension value high byte
  3817 00:BEF7: 69 00              ADC   #$00              ; add carry from low byte
  3818                        
  3819                        LAB_1ED0
  3820 00:BEF9: C8                 INY                     ; index to dimension value high byte
  3821 00:BEFA: 91 5C              STA   (Astrtl),Y        ; save dimension value high byte
  3822 00:BEFC: C8                 INY                     ; index to dimension value high byte
  3823 00:BEFD: 8A                 TXA                     ; get dimension value low byte
  3824 00:BEFE: 91 5C              STA   (Astrtl),Y        ; save dimension value low byte
  3825 00:BF00: 20 A0 BF           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  3826 00:BF03: 86 6C              STX   Asptl             ; save array data size low byte
  3827 00:BF05: 85 6D              STA   Aspth             ; save array data size high byte
  3828 00:BF07: A4 23              LDY   ut1_pl            ; restore index (saved by subroutine)
  3829 00:BF09: C6 0F              DEC   Dimcnt            ; decrement dimensions count
  3830 00:BF0B: D0 DD              BNE   LAB_1EC0          ; loop while not = 0
  3831                        
  3832 00:BF0D: 65 57              ADC   Adatah            ; add size high byte to first element high byte
  3833                                                      ; (carry is always clear here)
  3834 00:BF0F: B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  3835                        
  3836 00:BF11: 85 57              STA   Adatah            ; save end of array high byte
  3837 00:BF13: A8                 TAY                     ; copy end high byte to Y
  Sun Mar  3 2019 22:47                                                                                                    Page 62


  3838 00:BF14: 8A                 TXA                     ; get array size low byte
  3839 00:BF15: 65 56              ADC   Adatal            ; add array start low byte
  3840 00:BF17: 90 03              BCC   LAB_1EF3          ; branch if no carry
  3841                        
  3842 00:BF19: C8                 INY                     ; else increment end of array high byte
  3843 00:BF1A: F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
  3844                        
  3845                                                      ; set-up mostly complete, now zero the array
  3846                        LAB_1EF3
  3847 00:BF1C: 20 D6 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  3848                                                      ; addr to check is in AY (low/high)
  3849 00:BF1F: 85 31              STA   Earryl            ; save array mem end low byte
  3850 00:BF21: 84 32              STY   Earryh            ; save array mem end high byte
  3851 00:BF23: A9 00              LDA   #$00              ; clear byte for array clear
  3852 00:BF25: E6 6D              INC   Aspth             ; increment array size high byte (now block count)
  3853 00:BF27: A4 6C              LDY   Asptl             ; get array size low byte (now index to block)
  3854 00:BF29: F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
  3855                        
  3856                        LAB_1F02
  3857 00:BF2B: 88                 DEY                     ; decrement index (do 0 to n-1)
  3858 00:BF2C: 91 56              STA   (Adatal),Y        ; zero byte
  3859 00:BF2E: D0 FB              BNE   LAB_1F02          ; loop until this block done
  3860                        
  3861                        LAB_1F07
  3862 00:BF30: C6 57              DEC   Adatah            ; decrement array pointer high byte
  3863 00:BF32: C6 6D              DEC   Aspth             ; decrement block count high byte
  3864 00:BF34: D0 F5              BNE   LAB_1F02          ; loop until all blocks done
  3865                        
  3866 00:BF36: E6 57              INC   Adatah            ; correct for last loop
  3867 00:BF38: 38                 SEC                     ; set carry for subtract
  3868 00:BF39: A0 02              LDY   #$02              ; index to array size low byte
  3869 00:BF3B: A5 31              LDA   Earryl            ; get array mem end low byte
  3870 00:BF3D: E5 5C              SBC   Astrtl            ; subtract array start low byte
  3871 00:BF3F: 91 5C              STA   (Astrtl),Y        ; save array size low byte
  3872 00:BF41: C8                 INY                     ; index to array size high byte
  3873 00:BF42: A5 32              LDA   Earryh            ; get array mem end high byte
  3874 00:BF44: E5 5D              SBC   Astrth            ; subtract array start high byte
  3875 00:BF46: 91 5C              STA   (Astrtl),Y        ; save array size high byte
  3876 00:BF48: A5 10              LDA   Defdim            ; get default DIM flag
  3877 00:BF4A: D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
  3878                        
  3879                                                      ; else, find element
  3880 00:BF4C: C8                 INY                     ; index to # of dimensions
  3881                        
  3882                        LAB_1F24
  3883 00:BF4D: B1 5C              LDA   (Astrtl),Y        ; get array's dimension count
  3884 00:BF4F: 85 0F              STA   Dimcnt            ; save it
  3885                        
  3886                        ; we have found, or built, the array. now we need to find the element
  3887                        
  3888                        LAB_1F28
  3889 00:BF51: A9 00              LDA   #$00              ; clear byte
  3890 00:BF53: 85 6C              STA   Asptl             ; clear array data pointer low byte
  3891                        LAB_1F2C
  3892 00:BF55: 85 6D              STA   Aspth             ; save array data pointer high byte
  3893 00:BF57: C8                 INY                     ; increment index (point to array bound high byte)
  3894 00:BF58: 68                 PLA                     ; pull array index low byte
  3895 00:BF59: AA                 TAX                     ; copy to X
  3896 00:BF5A: 85 60              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
  3897 00:BF5C: 68                 PLA                     ; pull array index high byte
  3898 00:BF5D: 85 61              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
  3899 00:BF5F: D1 5C              CMP   (Astrtl),Y        ; compare with array bound high byte
  3900 00:BF61: 90 0E              BCC   LAB_1F48          ; branch if within bounds
  Sun Mar  3 2019 22:47                                                                                                    Page 63


  3901 00:BF63: D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
  3902                        
  3903                                                      ; else high byte was = so test low bytes
  3904 00:BF65: C8                 INY                     ; index to array bound low byte
  3905 00:BF66: 8A                 TXA                     ; get array index low byte
  3906 00:BF67: D1 5C              CMP   (Astrtl),Y        ; compare with array bound low byte
  3907 00:BF69: 90 07              BCC   LAB_1F49          ; branch if within bounds
  3908                        
  3909                        LAB_1F42
  3910 00:BF6B: 4C B1 BE           JMP   LAB_1E85          ; else do array bounds error
  3911                        
  3912                        LAB_1F45
  3913 00:BF6E: 4C 04 B1           JMP   LAB_OMER          ; do "Out of memory" error then warm start
  3914                        
  3915                        LAB_1F48
  3916 00:BF71: C8                 INY                     ; index to array bound low byte
  3917                        LAB_1F49
  3918 00:BF72: A5 6D              LDA   Aspth             ; get array data pointer high byte
  3919 00:BF74: 05 6C              ORA   Asptl             ; OR with array data pointer low byte
  3920 00:BF76: F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
  3921                        
  3922 00:BF78: 20 A0 BF           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  3923 00:BF7B: 8A                 TXA                     ; get result low byte
  3924 00:BF7C: 65 60              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
  3925 00:BF7E: AA                 TAX                     ; save result low byte
  3926 00:BF7F: 98                 TYA                     ; get result high byte
  3927 00:BF80: A4 23              LDY   ut1_pl            ; restore index
  3928                        LAB_1F5A
  3929 00:BF82: 65 61              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
  3930 00:BF84: 86 6C              STX   Asptl             ; save array data pointer low byte
  3931 00:BF86: C6 0F              DEC   Dimcnt            ; decrement dimensions count
  3932 00:BF88: D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
  3933                        
  3934 00:BF8A: 06 6C              ASL   Asptl             ; array data pointer low byte * 2
  3935 00:BF8C: 2A                 ROL                     ; array data pointer high byte * 2
  3936 00:BF8D: 06 6C              ASL   Asptl             ; array data pointer low byte * 4
  3937 00:BF8F: 2A                 ROL                     ; array data pointer high byte * 4
  3938 00:BF90: A8                 TAY                     ; copy high byte
  3939 00:BF91: A5 6C              LDA   Asptl             ; get low byte
  3940 00:BF93: 65 56              ADC   Adatal            ; add array data start pointer low byte
  3941 00:BF95: 85 47              STA   Cvaral            ; save as current var address low byte
  3942 00:BF97: 98                 TYA                     ; get high byte back
  3943 00:BF98: 65 57              ADC   Adatah            ; add array data start pointer high byte
  3944 00:BF9A: 85 48              STA   Cvarah            ; save as current var address high byte
  3945 00:BF9C: A8                 TAY                     ; copy high byte to Y
  3946 00:BF9D: A5 47              LDA   Cvaral            ; get current var address low byte
  3947                        LAB_1F7B
  3948 00:BF9F: 60                 RTS
  3949                        
  3950                        ; does XY = (Astrtl),Y * (Asptl)
  3951                        
  3952                        LAB_1F7C
  3953 00:BFA0: 84 23              STY   ut1_pl            ; save index
  3954 00:BFA2: B1 5C              LDA   (Astrtl),Y        ; get dimension size low byte
  3955 00:BFA4: 85 28              STA   dims_l            ; save dimension size low byte
  3956 00:BFA6: 88                 DEY                     ; decrement index
  3957 00:BFA7: B1 5C              LDA   (Astrtl),Y        ; get dimension size high byte
  3958 00:BFA9: 85 29              STA   dims_h            ; save dimension size high byte
  3959                        
  3960 00:BFAB: A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
  3961 00:BFAD: 85 5A              STA   numbit            ; save bit count
  3962 00:BFAF: A2 00              LDX   #$00              ; clear result low byte
  3963 00:BFB1: A0 00              LDY   #$00              ; clear result high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 64


  3964                        LAB_1F8F
  3965 00:BFB3: 8A                 TXA                     ; get result low byte
  3966 00:BFB4: 0A                 ASL                     ; *2
  3967 00:BFB5: AA                 TAX                     ; save result low byte
  3968 00:BFB6: 98                 TYA                     ; get result high byte
  3969 00:BFB7: 2A                 ROL                     ; *2
  3970 00:BFB8: A8                 TAY                     ; save result high byte
  3971 00:BFB9: B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  3972                        
  3973 00:BFBB: 06 6C              ASL   Asptl             ; shift multiplier low byte
  3974 00:BFBD: 26 6D              ROL   Aspth             ; shift multiplier high byte
  3975 00:BFBF: 90 0B              BCC   LAB_1FA8          ; skip add if no carry
  3976                        
  3977 00:BFC1: 18                 CLC                     ; else clear carry for add
  3978 00:BFC2: 8A                 TXA                     ; get result low byte
  3979 00:BFC3: 65 28              ADC   dims_l            ; add dimension size low byte
  3980 00:BFC5: AA                 TAX                     ; save result low byte
  3981 00:BFC6: 98                 TYA                     ; get result high byte
  3982 00:BFC7: 65 29              ADC   dims_h            ; add dimension size high byte
  3983 00:BFC9: A8                 TAY                     ; save result high byte
  3984 00:BFCA: B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  3985                        
  3986                        LAB_1FA8
  3987 00:BFCC: C6 5A              DEC   numbit            ; decrement bit count
  3988 00:BFCE: D0 E3              BNE   LAB_1F8F          ; loop until all done
  3989 00:BFD0: 60                 RTS
  3990                        
  3991                        ; perform FRE()
  3992                        
  3993                        LAB_FRE
  3994 00:BFD1: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3995 00:BFD3: 10 03              BPL   LAB_1FB4          ; branch if numeric
  3996                        
  3997 00:BFD5: 20 C5 C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  3998                                                      ; space returns with A = length, X=$71=pointer low byte,
  3999                                                      ; Y=$72=pointer high byte
  4000                        
  4001                                                      ; FRE(n) was numeric so do this
  4002                        LAB_1FB4
  4003 00:BFD8: 20 6A C1           JSR   LAB_GARB          ; go do garbage collection
  4004 00:BFDB: 38                 SEC                     ; set carry for subtract
  4005 00:BFDC: A5 33              LDA   Sstorl            ; get bottom of string space low byte
  4006 00:BFDE: E5 31              SBC   Earryl            ; subtract array mem end low byte
  4007 00:BFE0: A8                 TAY                     ; copy result to Y
  4008 00:BFE1: A5 34              LDA   Sstorh            ; get bottom of string space high byte
  4009 00:BFE3: E5 32              SBC   Earryh            ; subtract array mem end high byte
  4010                        
  4011                        ; save and convert integer AY to FAC1
  4012                        
  4013                        LAB_AYFC
  4014 00:BFE5: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  4015 00:BFE7: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  4016 00:BFE9: 84 60              STY   FAC1_2            ; save FAC1 mantissa2
  4017 00:BFEB: A2 90              LDX   #$90              ; set exponent=2^16 (integer)
  4018 00:BFED: 4C 75 C8           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
  4019                        
  4020                        ; perform POS()
  4021                        
  4022                        LAB_POS
  4023 00:BFF0: A4 07              LDY   TPos              ; get terminal position
  4024                        
  4025                        ; convert Y to byte in FAC1
  4026                        
  Sun Mar  3 2019 22:47                                                                                                    Page 65


  4027                        LAB_1FD0
  4028 00:BFF2: A9 00              LDA   #$00              ; clear high byte
  4029 00:BFF4: 80 EF              BRA   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
  4030                        
  4031                        ; check not Direct (used by DEF and INPUT)
  4032                        
  4033                        LAB_CKRN
  4034 00:BFF6: A6 3A              LDX   Clineh            ; get current line high byte
  4035 00:BFF8: E8                 INX                     ; increment it
  4036 00:BFF9: D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
  4037                        
  4038                                                      ; else do illegal direct error
  4039                        LAB_1FD9
  4040 00:BFFB: A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
  4041                        LAB_1FDB
  4042 00:BFFD: 4C 06 B1           JMP   LAB_XERR          ; go do error #X, then warm start
  4043                        
  4044                        ; perform DEF
  4045                        
  4046                        LAB_DEF
  4047 00:C000: 20 30 C0           JSR   LAB_200B          ; check FNx syntax
  4048 00:C003: 85 4E              STA   func_l            ; save function pointer low byte
  4049 00:C005: 84 4F              STY   func_h            ; save function pointer high byte
  4050 00:C007: 20 F6 BF           JSR   LAB_CKRN          ; check not Direct (back here if ok)
  4051 00:C00A: 20 8F BB           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
  4052 00:C00D: A9 80              LDA   #$80              ; set flag for FNx
  4053 00:C00F: 85 13              STA   Sufnxf            ; save subscript/FNx flag
  4054 00:C011: 20 39 BD           JSR   LAB_GVAR          ; get (var) address
  4055 00:C014: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4056 00:C017: 20 86 BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4057 00:C01A: A9 BD              LDA   #TK_EQUAL         ; get = token
  4058 00:C01C: 20 88 BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  4059 00:C01F: A5 48              LDA   Cvarah            ; get current var address high byte
  4060 00:C021: 48                 PHA                     ; push it
  4061 00:C022: A5 47              LDA   Cvaral            ; get current var address low byte
  4062 00:C024: 48                 PHA                     ; push it
  4063 00:C025: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4064 00:C027: 48                 PHA                     ; push it
  4065 00:C028: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4066 00:C02A: 48                 PHA                     ; push it
  4067 00:C02B: 20 3F B6           JSR   LAB_DATA          ; go perform DATA
  4068 00:C02E: 80 6E              BRA   LAB_207A          ; put execute pointer and variable pointer into function
  4069                                                      ; and return
  4070                        
  4071                        ; check FNx syntax
  4072                        
  4073                        LAB_200B
  4074 00:C030: A9 AB              LDA   #TK_FN            ; get FN" token
  4075 00:C032: 20 88 BB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  4076                                                      ; return character after A
  4077 00:C035: 09 80              ORA   #$80              ; set FN flag bit
  4078 00:C037: 85 13              STA   Sufnxf            ; save FN flag so array variable test fails
  4079 00:C039: 20 40 BD           JSR   LAB_1D12          ; search for FN variable
  4080 00:C03C: 4C 69 BA           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
  4081                                                      ; mismatch
  4082                        
  4083                                                      ; Evaluate FNx
  4084                        LAB_201E
  4085 00:C03F: 20 30 C0           JSR   LAB_200B          ; check FNx syntax
  4086 00:C042: 48                 PHA                     ; push function pointer low byte
  4087 00:C043: 5A                 PHY                     ; push function pointer high byte
  4088 00:C044: 20 8F BB           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
  4089 00:C047: 20 7B BA           JSR   LAB_EVEX          ; evaluate expression
  Sun Mar  3 2019 22:47                                                                                                    Page 66


  4090 00:C04A: 20 86 BB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4091 00:C04D: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4092 00:C050: 68                 PLA                     ; pop function pointer high byte
  4093 00:C051: 85 4F              STA   func_h            ; restore it
  4094 00:C053: 68                 PLA                     ; pop function pointer low byte
  4095 00:C054: 85 4E              STA   func_l            ; restore it
  4096 00:C056: A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
  4097 00:C058: A0 03              LDY   #$03              ; index to variable pointer high byte
  4098 00:C05A: B1 4E              LDA   (func_l),Y        ; get variable pointer high byte
  4099 00:C05C: F0 9F              BEQ   LAB_1FDB          ; if zero go do undefined function error
  4100                        
  4101 00:C05E: 85 48              STA   Cvarah            ; save variable address high byte
  4102 00:C060: 88                 DEY                     ; index to variable address low byte
  4103 00:C061: B1 4E              LDA   (func_l),Y        ; get variable address low byte
  4104 00:C063: 85 47              STA   Cvaral            ; save variable address low byte
  4105 00:C065: AA                 TAX                     ; copy address low byte
  4106                        
  4107                                                      ; now stack the function variable value before use
  4108 00:C066: C8                 INY                     ; index to mantissa_3
  4109                        LAB_2043
  4110 00:C067: B1 47              LDA   (Cvaral),Y        ; get byte from variable
  4111 00:C069: 48                 PHA                     ; stack it
  4112 00:C06A: 88                 DEY                     ; decrement index
  4113 00:C06B: 10 FA              BPL   LAB_2043          ; loop until variable stacked
  4114                        
  4115 00:C06D: A4 48              LDY   Cvarah            ; get variable address high byte
  4116 00:C06F: 20 1C C8           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
  4117                                                      ; (function variable), return Y=0, always
  4118 00:C072: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4119 00:C074: 48                 PHA                     ; push it
  4120 00:C075: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4121 00:C077: 48                 PHA                     ; push it
  4122 00:C078: B1 4E              LDA   (func_l),Y        ; get function execute pointer low byte
  4123 00:C07A: 85 6E              STA   Bpntrl            ; save as BASIC execute pointer low byte
  4124 00:C07C: C8                 INY                     ; index to high byte
  4125 00:C07D: B1 4E              LDA   (func_l),Y        ; get function execute pointer high byte
  4126 00:C07F: 85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
  4127 00:C081: A5 48              LDA   Cvarah            ; get variable address high byte
  4128 00:C083: 48                 PHA                     ; push it
  4129 00:C084: A5 47              LDA   Cvaral            ; get variable address low byte
  4130 00:C086: 48                 PHA                     ; push it
  4131 00:C087: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4132                                                      ; else do type mismatch
  4133 00:C08A: 68                 PLA                     ; pull variable address low byte
  4134 00:C08B: 85 4E              STA   func_l            ; save variable address low byte
  4135 00:C08D: 68                 PLA                     ; pull variable address high byte
  4136 00:C08E: 85 4F              STA   func_h            ; save variable address high byte
  4137 00:C090: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  4138 00:C093: F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
  4139                        
  4140 00:C095: 4C 97 BB           JMP   LAB_SNER          ; else syntax error then warm start
  4141                        
  4142                        ; restore Bpntrl,Bpntrh and function variable from stack
  4143                        
  4144                        LAB_2074
  4145 00:C098: 68                 PLA                     ; pull BASIC execute pointer low byte
  4146 00:C099: 85 6E              STA   Bpntrl            ; restore BASIC execute pointer low byte
  4147 00:C09B: 68                 PLA                     ; pull BASIC execute pointer high byte
  4148 00:C09C: 85 6F              STA   Bpntrh            ; restore BASIC execute pointer high byte
  4149                        
  4150                        ; put execute pointer and variable pointer into function
  4151                        
  4152                        LAB_207A
  Sun Mar  3 2019 22:47                                                                                                    Page 67


  4153 00:C09E: A0 00              LDY   #$00              ; clear index
  4154 00:C0A0: 68                 PLA                     ; pull BASIC execute pointer low byte
  4155 00:C0A1: 91 4E              STA   (func_l),Y        ; save to function
  4156 00:C0A3: C8                 INY                     ; increment index
  4157 00:C0A4: 68                 PLA                     ; pull BASIC execute pointer high byte
  4158 00:C0A5: 91 4E              STA   (func_l),Y        ; save to function
  4159 00:C0A7: C8                 INY                     ; increment index
  4160 00:C0A8: 68                 PLA                     ; pull current var address low byte
  4161 00:C0A9: 91 4E              STA   (func_l),Y        ; save to function
  4162 00:C0AB: C8                 INY                     ; increment index
  4163 00:C0AC: 68                 PLA                     ; pull current var address high byte
  4164 00:C0AD: 91 4E              STA   (func_l),Y        ; save to function
  4165 00:C0AF: 60                 RTS
  4166                        
  4167                        ; perform STR$()
  4168                        
  4169                        LAB_STRS
  4170 00:C0B0: 20 69 BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4171 00:C0B3: 20 FE C9           JSR   LAB_296E          ; convert FAC1 to string
  4172 00:C0B6: A9 75              LDA   #<Decssp1         ; set result string low pointer
  4173 00:C0B8: A0 00              LDY   #>Decssp1         ; set result string high pointer
  4174 00:C0BA: F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
  4175                        
  4176                        ; Do string vector
  4177                        ; copy des_pl/h to des_2l/h and make string space A bytes long
  4178                        
  4179                        LAB_209C
  4180 00:C0BC: A6 60              LDX   des_pl            ; get descriptor pointer low byte
  4181 00:C0BE: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  4182 00:C0C0: 86 50              STX   des_2l            ; save descriptor pointer low byte
  4183 00:C0C2: 84 51              STY   des_2h            ; save descriptor pointer high byte
  4184                        
  4185                        ; make string space A bytes long
  4186                        ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4187                        
  4188                        LAB_MSSP
  4189 00:C0C4: 20 38 C1           JSR   LAB_2115          ; make space in string memory for string A long
  4190                                                      ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4191 00:C0C7: 86 5F              STX   str_pl            ; save string pointer low byte
  4192 00:C0C9: 84 60              STY   str_ph            ; save string pointer high byte
  4193 00:C0CB: 85 5E              STA   str_ln            ; save length
  4194 00:C0CD: 60                 RTS
  4195                        
  4196                        ; Scan, set up string
  4197                        ; print " terminated string to Sutill/Sutilh
  4198                        
  4199                        LAB_20AE
  4200 00:C0CE: A2 22              LDX   #$22              ; set terminator to "
  4201 00:C0D0: 86 0D              STX   Srchc             ; set search character (terminator 1)
  4202 00:C0D2: 86 0E              STX   Asrch             ; set terminator 2
  4203                        
  4204                        ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4205                        ; source is AY
  4206                        
  4207                        LAB_20B4
  4208 00:C0D4: 85 6A              STA   ssptr_l           ; store string start low byte
  4209 00:C0D6: 84 6B              STY   ssptr_h           ; store string start high byte
  4210 00:C0D8: 85 5F              STA   str_pl            ; save string pointer low byte
  4211 00:C0DA: 84 60              STY   str_ph            ; save string pointer high byte
  4212 00:C0DC: A0 FF              LDY   #$FF              ; set length to -1
  4213                        LAB_20BE
  4214 00:C0DE: C8                 INY                     ; increment length
  4215 00:C0DF: B1 6A              LDA   (ssptr_l),Y       ; get byte from string
  Sun Mar  3 2019 22:47                                                                                                    Page 68


  4216 00:C0E1: F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
  4217                        
  4218 00:C0E3: C5 0D              CMP   Srchc             ; compare with search character (terminator 1)
  4219 00:C0E5: F0 04              BEQ   LAB_20CB          ; branch if terminator
  4220                        
  4221 00:C0E7: C5 0E              CMP   Asrch             ; compare with terminator 2
  4222 00:C0E9: D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
  4223                        
  4224                        LAB_20CB
  4225 00:C0EB: C9 22              CMP   #$22              ; compare with "
  4226 00:C0ED: F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
  4227                        
  4228                        LAB_20CF
  4229 00:C0EF: 18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
  4230                        LAB_20D0
  4231 00:C0F0: 84 5E              STY   str_ln            ; save length in FAC1 exponent
  4232 00:C0F2: 98                 TYA                     ; copy length to A
  4233 00:C0F3: 65 6A              ADC   ssptr_l           ; add string start low byte
  4234 00:C0F5: 85 6C              STA   Sendl             ; save string end low byte
  4235 00:C0F7: A6 6B              LDX   ssptr_h           ; get string start high byte
  4236 00:C0F9: 90 01              BCC   LAB_20DC          ; branch if no low byte overflow
  4237                        
  4238 00:C0FB: E8                 INX                     ; else increment high byte
  4239                        LAB_20DC
  4240 00:C0FC: 86 6D              STX   Sendh             ; save string end high byte
  4241 00:C0FE: A5 6B              LDA   ssptr_h           ; get string start high byte
  4242 00:C100: F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
  4243 00:C102: C9 04              CMP   #>Ibuffs          ; compare with location of input buffer page
  4244 00:C104: D0 0B              BNE   LAB_RTST          ; branch if not in utility area
  4245                        
  4246                        LAB_MVST
  4247                                                      ; string in utility area, move to string memory
  4248 00:C106: 98                 TYA                     ; copy length to A
  4249 00:C107: 20 BC C0           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4250                                                      ; long
  4251 00:C10A: A6 6A              LDX   ssptr_l           ; get string start low byte
  4252 00:C10C: A4 6B              LDY   ssptr_h           ; get string start high byte
  4253 00:C10E: 20 A6 C2           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
  4254                        
  4255                        ; check for space on descriptor stack then ..
  4256                        ; put string address and length on descriptor stack and update stack pointers
  4257                        
  4258                        LAB_RTST
  4259 00:C111: A6 17              LDX   next_s            ; get string stack pointer
  4260 00:C113: E0 23              CPX   #des_sk+$09       ; compare with max+1
  4261 00:C115: D0 05              BNE   LAB_20F8          ; branch if space on string stack
  4262                        
  4263                                                      ; else do string too complex error
  4264 00:C117: A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
  4265                        LAB_20F5
  4266 00:C119: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  4267                        
  4268                        ; put string address and length on descriptor stack and update stack pointers
  4269                        
  4270                        LAB_20F8
  4271 00:C11C: A5 5E              LDA   str_ln            ; get string length
  4272 00:C11E: 95 00              STA   PLUS_0,X          ; put on string stack
  4273 00:C120: A5 5F              LDA   str_pl            ; get string pointer low byte
  4274 00:C122: 95 01              STA   PLUS_1,X          ; put on string stack
  4275 00:C124: A5 60              LDA   str_ph            ; get string pointer high byte
  4276 00:C126: 95 02              STA   PLUS_2,X          ; put on string stack
  4277 00:C128: 86 60              STX   des_pl            ; save string descriptor pointer low byte
  4278 00:C12A: 64 61              STZ   des_ph            ; save string descriptor pointer high byte (always $00)
  Sun Mar  3 2019 22:47                                                                                                    Page 69


  4279 00:C12C: A0 FF              LDY   #$FF              ; Y = $FF
  4280 00:C12E: 84 11              STY   Dtypef            ; save data type flag, $FF=string
  4281 00:C130: 86 18              STX   last_sl           ; save old stack pointer (current top item)
  4282 00:C132: E8                 INX                     ; update stack pointer
  4283 00:C133: E8                 INX                     ; update stack pointer
  4284 00:C134: E8                 INX                     ; update stack pointer
  4285 00:C135: 86 17              STX   next_s            ; save new top item value
  4286 00:C137: 60                 RTS
  4287                        
  4288                        ; Build descriptor
  4289                        ; make space in string memory for string A long
  4290                        ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4291                        
  4292                        LAB_2115
  4293 00:C138: 46 12              LSR   Gclctd            ; clear garbage collected flag (b7)
  4294                        
  4295                                                      ; make space for string A long
  4296                        LAB_2117
  4297 00:C13A: 48                 PHA                     ; save string length
  4298 00:C13B: 49 FF              EOR   #$FF              ; complement it
  4299 00:C13D: 38                 SEC                     ; set carry for subtract (twos comp add)
  4300 00:C13E: 65 33              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
  4301 00:C140: A4 34              LDY   Sstorh            ; get bottom of string space high byte
  4302 00:C142: B0 01              BCS   LAB_2122          ; skip decrement if no underflow
  4303                        
  4304 00:C144: 88                 DEY                     ; decrement bottom of string space high byte
  4305                        LAB_2122
  4306 00:C145: C4 32              CPY   Earryh            ; compare with array mem end high byte
  4307 00:C147: 90 11              BCC   LAB_2137          ; do out of memory error if less
  4308                        
  4309 00:C149: D0 04              BNE   LAB_212C          ; if not = skip next test
  4310                        
  4311 00:C14B: C5 31              CMP   Earryl            ; compare with array mem end low byte
  4312 00:C14D: 90 0B              BCC   LAB_2137          ; do out of memory error if less
  4313                        
  4314                        LAB_212C
  4315 00:C14F: 85 33              STA   Sstorl            ; save bottom of string space low byte
  4316 00:C151: 84 34              STY   Sstorh            ; save bottom of string space high byte
  4317 00:C153: 85 35              STA   Sutill            ; save string utility ptr low byte
  4318 00:C155: 84 36              STY   Sutilh            ; save string utility ptr high byte
  4319 00:C157: AA                 TAX                     ; copy low byte to X
  4320 00:C158: 68                 PLA                     ; get string length back
  4321 00:C159: 60                 RTS
  4322                        
  4323                        LAB_2137
  4324 00:C15A: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
  4325 00:C15C: A5 12              LDA   Gclctd            ; get garbage collected flag
  4326 00:C15E: 30 B9              BMI   LAB_20F5          ; if set then do error code X
  4327                        
  4328 00:C160: 20 6A C1           JSR   LAB_GARB          ; else go do garbage collection
  4329 00:C163: A9 80              LDA   #$80              ; flag for garbage collected
  4330 00:C165: 85 12              STA   Gclctd            ; set garbage collected flag
  4331 00:C167: 68                 PLA                     ; pull length
  4332 00:C168: 80 D0              BRA   LAB_2117          ; go try again (loop always, length should never be = $00)
  4333                        
  4334                        ; garbage collection routine
  4335                        
  4336                        LAB_GARB
  4337 00:C16A: A6 37              LDX   Ememl             ; get end of mem low byte
  4338 00:C16C: A5 38              LDA   Ememh             ; get end of mem high byte
  4339                        
  4340                        ; re-run routine from last ending
  4341                        
  Sun Mar  3 2019 22:47                                                                                                    Page 70


  4342                        LAB_214B
  4343 00:C16E: 86 33              STX   Sstorl            ; set string storage low byte
  4344 00:C170: 85 34              STA   Sstorh            ; set string storage high byte
  4345 00:C172: 64 4F              STZ   garb_h            ; clear working pointer high byte (flag no strings to move)
  4346 00:C174: A5 31              LDA   Earryl            ; get array mem end low byte
  4347 00:C176: A6 32              LDX   Earryh            ; get array mem end high byte
  4348 00:C178: 85 5C              STA   Histrl            ; save as highest string low byte
  4349 00:C17A: 86 5D              STX   Histrh            ; save as highest string high byte
  4350 00:C17C: A9 1A              LDA   #des_sk           ; set descriptor stack pointer
  4351 00:C17E: 85 23              STA   ut1_pl            ; save descriptor stack pointer low byte
  4352 00:C180: 64 24              STZ   ut1_ph            ; save descriptor stack pointer high byte ($00)
  4353                        LAB_2161
  4354 00:C182: C5 17              CMP   next_s            ; compare with descriptor stack pointer
  4355 00:C184: F0 05              BEQ   LAB_216A          ; branch if =
  4356                        
  4357 00:C186: 20 EC C1           JSR   LAB_21D7          ; go garbage collect descriptor stack
  4358 00:C189: 80 F7              BRA   LAB_2161          ; loop always
  4359                        
  4360                                                      ; done stacked strings, now do string vars
  4361                        LAB_216A
  4362 00:C18B: 06 52              ASL   g_step            ; set step size = $06
  4363 00:C18D: A5 2D              LDA   Svarl             ; get start of vars low byte
  4364 00:C18F: A6 2E              LDX   Svarh             ; get start of vars high byte
  4365 00:C191: 85 23              STA   ut1_pl            ; save as pointer low byte
  4366 00:C193: 86 24              STX   ut1_ph            ; save as pointer high byte
  4367                        LAB_2176
  4368 00:C195: E4 30              CPX   Sarryh            ; compare start of arrays high byte
  4369 00:C197: D0 04              BNE   LAB_217E          ; branch if no high byte match
  4370                        
  4371 00:C199: C5 2F              CMP   Sarryl            ; else compare start of arrays low byte
  4372 00:C19B: F0 05              BEQ   LAB_2183          ; branch if = var mem end
  4373                        
  4374                        LAB_217E
  4375 00:C19D: 20 E6 C1           JSR   LAB_21D1          ; go garbage collect strings
  4376 00:C1A0: 80 F3              BRA   LAB_2176          ; loop always
  4377                        
  4378                                                      ; done string vars, now do string arrays
  4379                        LAB_2183
  4380 00:C1A2: 85 56              STA   Nbendl            ; save start of arrays low byte as working pointer
  4381 00:C1A4: 86 57              STX   Nbendh            ; save start of arrays high byte as working pointer
  4382 00:C1A6: A9 04              LDA   #$04              ; set step size
  4383 00:C1A8: 85 52              STA   g_step            ; save step size
  4384                        LAB_218B
  4385 00:C1AA: A5 56              LDA   Nbendl            ; get pointer low byte
  4386 00:C1AC: A6 57              LDX   Nbendh            ; get pointer high byte
  4387                        LAB_218F
  4388 00:C1AE: E4 32              CPX   Earryh            ; compare with array mem end high byte
  4389 00:C1B0: D0 04              BNE   LAB_219A          ; branch if not at end
  4390                        
  4391 00:C1B2: C5 31              CMP   Earryl            ; else compare with array mem end low byte
  4392 00:C1B4: F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
  4393                        
  4394                        LAB_219A
  4395 00:C1B6: 85 23              STA   ut1_pl            ; save pointer low byte
  4396 00:C1B8: 86 24              STX   ut1_ph            ; save pointer high byte
  4397 00:C1BA: A0 02              LDY   #$02              ; set index
  4398 00:C1BC: B1 23              LDA   (ut1_pl),Y        ; get array size low byte
  4399 00:C1BE: 65 56              ADC   Nbendl            ; add start of this array low byte
  4400 00:C1C0: 85 56              STA   Nbendl            ; save start of next array low byte
  4401 00:C1C2: C8                 INY                     ; increment index
  4402 00:C1C3: B1 23              LDA   (ut1_pl),Y        ; get array size high byte
  4403 00:C1C5: 65 57              ADC   Nbendh            ; add start of this array high byte
  4404 00:C1C7: 85 57              STA   Nbendh            ; save start of next array high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 71


  4405 00:C1C9: A0 01              LDY   #$01              ; set index
  4406 00:C1CB: B1 23              LDA   (ut1_pl),Y        ; get name second byte
  4407 00:C1CD: 10 DB              BPL   LAB_218B          ; skip if not string array
  4408                        
  4409                        ; was string array so ..
  4410                        
  4411 00:C1CF: A0 04              LDY   #$04              ; set index
  4412 00:C1D1: B1 23              LDA   (ut1_pl),Y        ; get # of dimensions
  4413 00:C1D3: 0A                 ASL                     ; *2
  4414 00:C1D4: 69 05              ADC   #$05              ; +5 (array header size)
  4415 00:C1D6: 20 1E C2           JSR   LAB_2208          ; go set up for first element
  4416                        LAB_21C4
  4417 00:C1D9: E4 57              CPX   Nbendh            ; compare with start of next array high byte
  4418 00:C1DB: D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
  4419                        
  4420 00:C1DD: C5 56              CMP   Nbendl            ; else compare element pointer low byte with next array
  4421                                                      ; low byte
  4422 00:C1DF: F0 CD              BEQ   LAB_218F          ; if equal then go do next array
  4423                        
  4424                        LAB_21CC
  4425 00:C1E1: 20 EC C1           JSR   LAB_21D7          ; go defrag array strings
  4426 00:C1E4: 80 F3              BRA   LAB_21C4          ; go do next array string (loop always)
  4427                        
  4428                        ; defrag string variables
  4429                        ; enter with XA = variable pointer
  4430                        ; return with XA = next variable pointer
  4431                        
  4432                        LAB_21D1
  4433 00:C1E6: C8                 INY                     ; increment index (Y was $00)
  4434 00:C1E7: B1 23              LDA   (ut1_pl),Y        ; get var name byte 2
  4435 00:C1E9: 10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
  4436                        
  4437 00:C1EB: C8                 INY                     ; else increment index
  4438                        LAB_21D7
  4439 00:C1EC: B1 23              LDA   (ut1_pl),Y        ; get string length
  4440 00:C1EE: F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
  4441                        
  4442 00:C1F0: C8                 INY                     ; else increment index
  4443 00:C1F1: B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte
  4444 00:C1F3: AA                 TAX                     ; copy to X
  4445 00:C1F4: C8                 INY                     ; increment index
  4446 00:C1F5: B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte
  4447 00:C1F7: C5 34              CMP   Sstorh            ; compare bottom of string space high byte
  4448 00:C1F9: 90 06              BCC   LAB_21EC          ; branch if less
  4449 00:C1FB: D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
  4450                        
  4451                                                      ; high bytes were = so compare low bytes
  4452 00:C1FD: E4 33              CPX   Sstorl            ; compare bottom of string space low byte
  4453 00:C1FF: B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
  4454                        
  4455                                                      ; string pointer is < string storage pointer (pos in mem)
  4456                        LAB_21EC
  4457 00:C201: C5 5D              CMP   Histrh            ; compare to highest string high byte
  4458 00:C203: 90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
  4459                        
  4460 00:C205: D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
  4461                        
  4462                                                      ; high bytes were = so compare low bytes
  4463 00:C207: E4 5C              CPX   Histrl            ; compare to highest string low byte
  4464 00:C209: 90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
  4465                        
  4466                                                      ; string is in string memory space
  4467                        LAB_21F6
  Sun Mar  3 2019 22:47                                                                                                    Page 72


  4468 00:C20B: 86 5C              STX   Histrl            ; save as new highest string low byte
  4469 00:C20D: 85 5D              STA   Histrh            ; save as new highest string high byte
  4470 00:C20F: A5 23              LDA   ut1_pl            ; get start of vars(descriptors) low byte
  4471 00:C211: A6 24              LDX   ut1_ph            ; get start of vars(descriptors) high byte
  4472 00:C213: 85 4E              STA   garb_l            ; save as working pointer low byte
  4473 00:C215: 86 4F              STX   garb_h            ; save as working pointer high byte
  4474 00:C217: 88                 DEY                     ; decrement index DIFFERS
  4475 00:C218: 88                 DEY                     ; decrement index (should point to descriptor start)
  4476 00:C219: 84 54              STY   g_indx            ; save index pointer
  4477                        
  4478                                                      ; step pointer to next string
  4479                        LAB_2206
  4480 00:C21B: 18                 CLC                     ; clear carry for add
  4481                        LAB_2207
  4482 00:C21C: A5 52              LDA   g_step            ; get step size
  4483                        LAB_2208
  4484 00:C21E: 65 23              ADC   ut1_pl            ; add pointer low byte
  4485 00:C220: 85 23              STA   ut1_pl            ; save pointer low byte
  4486 00:C222: 90 02              BCC   LAB_2211          ; branch if no overflow
  4487                        
  4488 00:C224: E6 24              INC   ut1_ph            ; else increment high byte
  4489                        LAB_2211
  4490 00:C226: A6 24              LDX   ut1_ph            ; get pointer high byte
  4491 00:C228: A0 00              LDY   #$00              ; clear Y
  4492 00:C22A: 60                 RTS
  4493                        
  4494                        ; search complete, now either exit or set-up and move string
  4495                        
  4496                        LAB_2216
  4497 00:C22B: C6 52              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
  4498 00:C22D: A6 4F              LDX   garb_h            ; get string to move high byte
  4499 00:C22F: F0 F5              BEQ   LAB_2211          ; exit if nothing to move
  4500                        
  4501 00:C231: A4 54              LDY   g_indx            ; get index byte back (points to descriptor)
  4502 00:C233: 18                 CLC                     ; clear carry for add
  4503 00:C234: B1 4E              LDA   (garb_l),Y        ; get string length
  4504 00:C236: 65 5C              ADC   Histrl            ; add highest string low byte
  4505 00:C238: 85 58              STA   Obendl            ; save old block end low pointer
  4506 00:C23A: A5 5D              LDA   Histrh            ; get highest string high byte
  4507 00:C23C: 69 00              ADC   #$00              ; add any carry
  4508 00:C23E: 85 59              STA   Obendh            ; save old block end high byte
  4509 00:C240: A5 33              LDA   Sstorl            ; get bottom of string space low byte
  4510 00:C242: A6 34              LDX   Sstorh            ; get bottom of string space high byte
  4511 00:C244: 85 56              STA   Nbendl            ; save new block end low byte
  4512 00:C246: 86 57              STX   Nbendh            ; save new block end high byte
  4513 00:C248: 20 90 B0           JSR   LAB_11D6          ; open up space in memory, don't set array end
  4514 00:C24B: A4 54              LDY   g_indx            ; get index byte
  4515 00:C24D: C8                 INY                     ; point to descriptor low byte
  4516 00:C24E: A5 56              LDA   Nbendl            ; get string pointer low byte
  4517 00:C250: 91 4E              STA   (garb_l),Y        ; save new string pointer low byte
  4518 00:C252: AA                 TAX                     ; copy string pointer low byte
  4519 00:C253: E6 57              INC   Nbendh            ; correct high byte (move sets high byte -1)
  4520 00:C255: A5 57              LDA   Nbendh            ; get new string pointer high byte
  4521 00:C257: C8                 INY                     ; point to descriptor high byte
  4522 00:C258: 91 4E              STA   (garb_l),Y        ; save new string pointer high byte
  4523 00:C25A: 4C 6E C1           JMP   LAB_214B          ; re-run routine from last ending
  4524                                                      ; (but don't collect this string)
  4525                        
  4526                        ; concatenate
  4527                        ; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4528                        
  4529                        LAB_224D
  4530 00:C25D: A5 61              LDA   des_ph            ; get descriptor pointer high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 73


  4531 00:C25F: 48                 PHA                     ; put on stack
  4532 00:C260: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  4533 00:C262: 48                 PHA                     ; put on stack
  4534 00:C263: 20 64 BB           JSR   LAB_GVAL          ; get value from line
  4535 00:C266: 20 6C BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4536 00:C269: 68                 PLA                     ; get descriptor pointer low byte back
  4537 00:C26A: 85 6A              STA   ssptr_l           ; set pointer low byte
  4538 00:C26C: 68                 PLA                     ; get descriptor pointer high byte back
  4539 00:C26D: 85 6B              STA   ssptr_h           ; set pointer high byte
  4540 00:C26F: B2 6A              LDA   (ssptr_l)         ; get length_1 from descriptor
  4541 00:C271: 18                 CLC                     ; clear carry for add
  4542 00:C272: 72 60              ADC   (des_pl)          ; add length_2
  4543 00:C274: 90 05              BCC   LAB_226D          ; branch if no overflow
  4544                        
  4545 00:C276: A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
  4546 00:C278: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  4547                        
  4548                        LAB_226D
  4549 00:C27B: 20 BC C0           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4550                                                      ; long
  4551 00:C27E: 20 98 C2           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  4552 00:C281: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  4553 00:C283: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  4554 00:C285: 20 C9 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4555                                                      ; returns with A = length, ut1_pl = pointer low byte,
  4556                                                      ; ut1_ph = pointer high byte
  4557 00:C288: 20 AA C2           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4558 00:C28B: A5 6A              LDA   ssptr_l           ; set descriptor pointer low byte
  4559 00:C28D: A4 6B              LDY   ssptr_h           ; set descriptor pointer high byte
  4560 00:C28F: 20 C9 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4561                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4562                                                      ; Y=ut1_ph=pointer high byte
  4563 00:C292: 20 11 C1           JSR   LAB_RTST          ; check for space on descriptor stack then put string
  4564                                                      ; address and length on descriptor stack and update stack
  4565                                                      ; pointers
  4566 00:C295: 4C 90 BA           JMP   LAB_1ADB          ; continue evaluation
  4567                        
  4568                        ; copy string from descriptor (sdescr) to (Sutill)
  4569                        
  4570                        LAB_228A
  4571 00:C298: A0 00              LDY   #$00              ; clear index
  4572 00:C29A: B1 6A              LDA   (sdescr),Y        ; get string length
  4573 00:C29C: 48                 PHA                     ; save on stack
  4574 00:C29D: C8                 INY                     ; increment index
  4575 00:C29E: B1 6A              LDA   (sdescr),Y        ; get source string pointer low byte
  4576 00:C2A0: AA                 TAX                     ; copy to X
  4577 00:C2A1: C8                 INY                     ; increment index
  4578 00:C2A2: B1 6A              LDA   (sdescr),Y        ; get source string pointer high byte
  4579 00:C2A4: A8                 TAY                     ; copy to Y
  4580 00:C2A5: 68                 PLA                     ; get length back
  4581                        
  4582                        ; store string A bytes long from YX to (Sutill)
  4583                        
  4584                        LAB_2298
  4585 00:C2A6: 86 23              STX   ut1_pl            ; save source string pointer low byte
  4586 00:C2A8: 84 24              STY   ut1_ph            ; save source string pointer high byte
  4587                        
  4588                        ; store string A bytes long from (ut1_pl) to (Sutill)
  4589                        
  4590                        LAB_229C
  4591 00:C2AA: AA                 TAX                     ; copy length to index (don't count with Y)
  4592 00:C2AB: F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
  4593                        
  Sun Mar  3 2019 22:47                                                                                                    Page 74


  4594 00:C2AD: A0 00              LDY   #$00              ; zero pointer (copy forward)
  4595                        LAB_22A0
  4596 00:C2AF: B1 23              LDA   (ut1_pl),Y        ; get source byte
  4597 00:C2B1: 91 35              STA   (Sutill),Y        ; save destination byte
  4598                        
  4599 00:C2B3: C8                 INY                     ; increment index
  4600 00:C2B4: CA                 DEX                     ; decrement counter
  4601 00:C2B5: D0 F8              BNE   LAB_22A0          ; loop while <> 0
  4602                        
  4603 00:C2B7: 98                 TYA                     ; restore length from Y
  4604                        LAB_22A9
  4605 00:C2B8: 18                 CLC                     ; clear carry for add
  4606 00:C2B9: 65 35              ADC   Sutill            ; add string utility ptr low byte
  4607 00:C2BB: 85 35              STA   Sutill            ; save string utility ptr low byte
  4608 00:C2BD: 90 02              BCC   LAB_22B2          ; branch if no carry
  4609                        
  4610 00:C2BF: E6 36              INC   Sutilh            ; else increment string utility ptr high byte
  4611                        LAB_22B2
  4612 00:C2C1: 60                 RTS
  4613                        
  4614                        ; evaluate string
  4615                        
  4616                        LAB_EVST
  4617 00:C2C2: 20 6C BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4618                        
  4619                        ; pop string off descriptor stack, or from top of string space
  4620                        ; returns with A = length, X=pointer low byte, Y=pointer high byte
  4621                        
  4622                        LAB_22B6
  4623 00:C2C5: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  4624 00:C2C7: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  4625                        
  4626                        ; pop (YA) descriptor off stack or from top of string space
  4627                        ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4628                        
  4629                        LAB_22BA
  4630 00:C2C9: 85 23              STA   ut1_pl            ; save descriptor pointer low byte
  4631 00:C2CB: 84 24              STY   ut1_ph            ; save descriptor pointer high byte
  4632 00:C2CD: 20 FA C2           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  4633 00:C2D0: 08                 PHP                     ; save status flags
  4634 00:C2D1: A0 00              LDY   #$00              ; clear index
  4635 00:C2D3: B1 23              LDA   (ut1_pl),Y        ; get length from string descriptor
  4636 00:C2D5: 48                 PHA                     ; put on stack
  4637 00:C2D6: C8                 INY                     ; increment index
  4638 00:C2D7: B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
  4639 00:C2D9: AA                 TAX                     ; copy to X
  4640 00:C2DA: C8                 INY                     ; increment index
  4641 00:C2DB: B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
  4642 00:C2DD: A8                 TAY                     ; copy to Y
  4643 00:C2DE: 68                 PLA                     ; get string length back
  4644 00:C2DF: 28                 PLP                     ; restore status
  4645 00:C2E0: D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
  4646                        
  4647 00:C2E2: C4 34              CPY   Sstorh            ; compare bottom of string space high byte
  4648 00:C2E4: D0 0F              BNE   LAB_22E6          ; branch if <>
  4649                        
  4650 00:C2E6: E4 33              CPX   Sstorl            ; else compare bottom of string space low byte
  4651 00:C2E8: D0 0B              BNE   LAB_22E6          ; branch if <>
  4652                        
  4653 00:C2EA: 48                 PHA                     ; save string length
  4654 00:C2EB: 18                 CLC                     ; clear carry for add
  4655 00:C2EC: 65 33              ADC   Sstorl            ; add bottom of string space low byte
  4656 00:C2EE: 85 33              STA   Sstorl            ; save bottom of string space low byte
  Sun Mar  3 2019 22:47                                                                                                    Page 75


  4657 00:C2F0: 90 02              BCC   LAB_22E5          ; skip increment if no overflow
  4658                        
  4659 00:C2F2: E6 34              INC   Sstorh            ; increment bottom of string space high byte
  4660                        LAB_22E5
  4661 00:C2F4: 68                 PLA                     ; restore string length
  4662                        LAB_22E6
  4663 00:C2F5: 86 23              STX   ut1_pl            ; save string pointer low byte
  4664 00:C2F7: 84 24              STY   ut1_ph            ; save string pointer high byte
  4665 00:C2F9: 60                 RTS
  4666                        
  4667                        ; clean descriptor stack, YA = pointer
  4668                        ; checks if AY is on the descriptor stack, if so does a stack discard
  4669                        
  4670                        LAB_22EB
  4671 00:C2FA: C4 19              CPY   last_sh           ; compare pointer high byte
  4672 00:C2FC: D0 0C              BNE   LAB_22FB          ; exit if <>
  4673                        
  4674 00:C2FE: C5 18              CMP   last_sl           ; compare pointer low byte
  4675 00:C300: D0 08              BNE   LAB_22FB          ; exit if <>
  4676                        
  4677 00:C302: 85 17              STA   next_s            ; save descriptor stack pointer
  4678 00:C304: E9 03              SBC   #$03              ; -3
  4679 00:C306: 85 18              STA   last_sl           ; save low byte -3
  4680 00:C308: A0 00              LDY   #$00              ; clear high byte
  4681                        LAB_22FB
  4682 00:C30A: 60                 RTS
  4683                        
  4684                        ; perform CHR$()
  4685                        
  4686                        LAB_CHRS
  4687 00:C30B: 20 0F C4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  4688 00:C30E: DA                 PHX                     ; save character to stack
  4689 00:C30F: A9 01              LDA   #$01              ; string is single byte
  4690 00:C311: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  4691                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4692 00:C314: 68                 PLA                     ; get character back
  4693 00:C315: 92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
  4694 00:C317: 4C 11 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4695                                                      ; address and length on descriptor stack and update stack
  4696                                                      ; pointers
  4697                        
  4698                        ; perform LEFT$()
  4699                        
  4700                        LAB_LEFT
  4701 00:C31A: 48                 PHA                     ; push byte parameter
  4702 00:C31B: 20 7A C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4703                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4704 00:C31E: D1 50              CMP   (des_2l),Y        ; compare byte parameter with string length
  4705 00:C320: 98                 TYA                     ; clear A
  4706 00:C321: 80 09              BRA   LAB_2316          ; go do string copy (branch always)
  4707                        
  4708                        ; perform RIGHT$()
  4709                        
  4710                        LAB_RIGHT
  4711 00:C323: 48                 PHA                     ; push byte parameter
  4712 00:C324: 20 7A C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4713                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4714 00:C327: 18                 CLC                     ; clear carry for add-1
  4715 00:C328: F1 50              SBC   (des_2l),Y        ; subtract string length
  4716 00:C32A: 49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
  4717                        
  4718                        LAB_2316
  4719 00:C32C: 90 04              BCC   LAB_231C          ; branch if string length > byte parameter
  Sun Mar  3 2019 22:47                                                                                                    Page 76


  4720                        
  4721 00:C32E: B1 50              LDA   (des_2l),Y        ; else make parameter = length
  4722 00:C330: AA                 TAX                     ; copy to byte parameter copy
  4723 00:C331: 98                 TYA                     ; clear string start offset
  4724                        LAB_231C
  4725 00:C332: 48                 PHA                     ; save string start offset
  4726                        LAB_231D
  4727 00:C333: 8A                 TXA                     ; copy byte parameter (or string length if <)
  4728                        LAB_231E
  4729 00:C334: 48                 PHA                     ; save string length
  4730 00:C335: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  4731                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4732 00:C338: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  4733 00:C33A: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  4734 00:C33C: 20 C9 C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4735                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4736                                                      ; Y=ut1_ph=pointer high byte
  4737 00:C33F: 7A                 PLY                     ; get string length back
  4738 00:C340: 68                 PLA                     ; get string start offset back
  4739 00:C341: 18                 CLC                     ; clear carry for add
  4740 00:C342: 65 23              ADC   ut1_pl            ; add start offset to string start pointer low byte
  4741 00:C344: 85 23              STA   ut1_pl            ; save string start pointer low byte
  4742 00:C346: 90 02              BCC   LAB_2335          ; branch if no overflow
  4743                        
  4744 00:C348: E6 24              INC   ut1_ph            ; else increment string start pointer high byte
  4745                        LAB_2335
  4746 00:C34A: 98                 TYA                     ; copy length to A
  4747 00:C34B: 20 AA C2           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4748 00:C34E: 4C 11 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4749                                                      ; address and length on descriptor stack and update stack
  4750                                                      ; pointers
  4751                        
  4752                        ; perform MID$()
  4753                        
  4754                        LAB_MIDS
  4755 00:C351: 48                 PHA                     ; push byte parameter
  4756 00:C352: A9 FF              LDA   #$FF              ; set default length = 255
  4757 00:C354: 85 61              STA   mids_l            ; save default length
  4758 00:C356: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  4759 00:C359: C9 29              CMP   #')'              ; compare with ")"
  4760 00:C35B: F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
  4761                        
  4762 00:C35D: 20 93 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  4763 00:C360: 20 0C C4           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
  4764                        LAB_2358
  4765 00:C363: 20 7A C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4766                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4767 00:C366: CA                 DEX                     ; decrement start index
  4768 00:C367: 8A                 TXA                     ; copy to A
  4769 00:C368: 48                 PHA                     ; save string start offset
  4770 00:C369: 18                 CLC                     ; clear carry for sub-1
  4771 00:C36A: A2 00              LDX   #$00              ; clear output string length
  4772 00:C36C: F1 50              SBC   (des_2l),Y        ; subtract string length
  4773 00:C36E: B0 C3              BCS   LAB_231D          ; if start>string length go do null string
  4774                        
  4775 00:C370: 49 FF              EOR   #$FF              ; complement -length
  4776 00:C372: C5 61              CMP   mids_l            ; compare byte parameter
  4777 00:C374: 90 BE              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
  4778                        
  4779 00:C376: A5 61              LDA   mids_l            ; get length byte
  4780 00:C378: 80 BA              BRA   LAB_231E          ; go do string copy (branch always)
  4781                        
  4782                        ; pull string data and byte parameter from stack
  Sun Mar  3 2019 22:47                                                                                                    Page 77


  4783                        ; return pointer in des_2l/h, byte in A (and X), Y=0
  4784                        
  4785                        LAB_236F
  4786 00:C37A: 20 86 BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4787 00:C37D: 68                 PLA                     ; pull return address low byte (return address)
  4788 00:C37E: 85 54              STA   Fnxjpl            ; save functions jump vector low byte
  4789 00:C380: 68                 PLA                     ; pull return address high byte (return address)
  4790 00:C381: 85 55              STA   Fnxjph            ; save functions jump vector high byte
  4791 00:C383: FA                 PLX                     ; get byte parameter
  4792 00:C384: 68                 PLA                     ; pull string pointer low byte
  4793 00:C385: 85 50              STA   des_2l            ; save it
  4794 00:C387: 68                 PLA                     ; pull string pointer high byte
  4795 00:C388: 85 51              STA   des_2h            ; save it
  4796 00:C38A: A0 00              LDY   #$00              ; clear index
  4797 00:C38C: 8A                 TXA                     ; copy byte parameter
  4798 00:C38D: F0 77              BEQ   LAB_23A8          ; if null do function call error then warm start
  4799                        
  4800 00:C38F: E6 54              INC   Fnxjpl            ; increment function jump vector low byte
  4801                                                      ; (JSR pushes return addr-1. this is all very nice
  4802                                                      ; but will go tits up if either call is on a page
  4803                                                      ; boundary!)
  4804 00:C391: 6C 54 00           JMP   (Fnxjpl)          ; in effect, RTS
  4805                        
  4806                        ; perform LCASE$()
  4807                        
  4808                        LAB_LCASE
  4809 00:C394: 20 C2 C2           JSR   LAB_EVST          ; evaluate string
  4810 00:C397: 85 5E              STA   str_ln            ; set string length
  4811 00:C399: A8                 TAY                     ; copy length to Y
  4812 00:C39A: F0 38              BEQ   NoString          ; branch if null string
  4813                        
  4814 00:C39C: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  4815                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4816 00:C39F: 86 5F              STX   str_pl            ; save string pointer low byte
  4817 00:C3A1: 84 60              STY   str_ph            ; save string pointer high byte
  4818 00:C3A3: A8                 TAY                     ; get string length back
  4819                        
  4820                        LC_loop
  4821 00:C3A4: 88                 DEY                     ; decrement index
  4822 00:C3A5: B1 23              LDA   (ut1_pl),Y        ; get byte from string
  4823 00:C3A7: 20 AF BD           JSR   LAB_1D82          ; is character "A" to "Z"
  4824 00:C3AA: 90 02              BCC   NoUcase           ; branch if not upper case alpha
  4825                        
  4826 00:C3AC: 09 20              ORA   #$20              ; convert upper to lower case
  4827                        NoUcase
  4828 00:C3AE: 91 35              STA   (Sutill),Y        ; save byte back to string
  4829 00:C3B0: 98                 TYA                     ; test index
  4830 00:C3B1: D0 F1              BNE   LC_loop           ; loop if not all done
  4831 00:C3B3: 80 1F              BRA   NoString          ; tidy up and exit, branch always
  4832                        
  4833                        ; perform UCASE$()
  4834                        
  4835                        LAB_UCASE
  4836 00:C3B5: 20 C2 C2           JSR   LAB_EVST          ; evaluate string
  4837 00:C3B8: 85 5E              STA   str_ln            ; set string length
  4838 00:C3BA: A8                 TAY                     ; copy length to Y
  4839 00:C3BB: F0 17              BEQ   NoString          ; branch if null string
  4840                        
  4841 00:C3BD: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  4842                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4843 00:C3C0: 86 5F              STX   str_pl            ; save string pointer low byte
  4844 00:C3C2: 84 60              STY   str_ph            ; save string pointer high byte
  4845 00:C3C4: A8                 TAY                     ; get string length back
  Sun Mar  3 2019 22:47                                                                                                    Page 78


  4846                        
  4847                        UC_loop
  4848 00:C3C5: 88                 DEY                     ; decrement index
  4849 00:C3C6: B1 23              LDA   (ut1_pl),Y        ; get byte from string
  4850 00:C3C8: 20 AB BD           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
  4851 00:C3CB: 90 02              BCC   NoLcase           ; branch if not alpha
  4852                        
  4853 00:C3CD: 29 DF              AND   #$DF              ; convert lower to upper case
  4854                        NoLcase
  4855 00:C3CF: 91 35              STA   (Sutill),Y        ; save byte back to string
  4856 00:C3D1: 98                 TYA                     ; test index
  4857 00:C3D2: D0 F1              BNE   UC_loop           ; loop if not all done
  4858                        
  4859                        NoString
  4860 00:C3D4: 4C 11 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4861                                                      ; address and length on descriptor stack and update stack
  4862                                                      ; pointers
  4863                        
  4864                        ; perform SADD()
  4865                        
  4866                        LAB_SADD
  4867 00:C3D7: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  4868 00:C3DA: 20 39 BD           JSR   LAB_GVAR          ; get var address
  4869                        
  4870 00:C3DD: 20 86 BB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4871 00:C3E0: 20 6C BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4872                        
  4873 00:C3E3: A0 02              LDY   #$02              ; index to string pointer high byte
  4874 00:C3E5: B1 47              LDA   (Cvaral),Y        ; get string pointer high byte
  4875 00:C3E7: AA                 TAX                     ; copy string pointer high byte to X
  4876 00:C3E8: 88                 DEY                     ; index to string pointer low byte
  4877 00:C3E9: B1 47              LDA   (Cvaral),Y        ; get string pointer low byte
  4878 00:C3EB: A8                 TAY                     ; copy string pointer low byte to Y
  4879 00:C3EC: 8A                 TXA                     ; copy string pointer high byte to A
  4880 00:C3ED: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  4881                        
  4882                        ; perform LEN()
  4883                        
  4884                        LAB_LENS
  4885 00:C3F0: 20 F6 C3           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  4886 00:C3F3: 4C F2 BF           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  4887                        
  4888                        ; evaluate string, get length in Y
  4889                        
  4890                        LAB_ESGL
  4891 00:C3F6: 20 C2 C2           JSR   LAB_EVST          ; evaluate string
  4892 00:C3F9: A8                 TAY                     ; copy length to Y
  4893 00:C3FA: 60                 RTS
  4894                        
  4895                        ; perform ASC()
  4896                        
  4897                        LAB_ASC
  4898 00:C3FB: 20 F6 C3           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  4899 00:C3FE: F0 06              BEQ   LAB_23A8          ; if null do function call error then warm start
  4900                        
  4901 00:C400: B2 23              LDA   (ut1_pl)          ; get byte
  4902 00:C402: A8                 TAY                     ; copy to Y
  4903 00:C403: 4C F2 BF           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  4904                        
  4905                        ; do function call error then warm start
  4906                        
  4907                        LAB_23A8
  4908 00:C406: 4C B5 BE           JMP   LAB_FCER          ; do function call error then warm start
  Sun Mar  3 2019 22:47                                                                                                    Page 79


  4909                        
  4910                        ; scan and get byte parameter
  4911                        
  4912                        LAB_SGBY
  4913 00:C409: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  4914                        
  4915                        ; get byte parameter
  4916                        
  4917                        LAB_GTBY
  4918 00:C40C: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4919                                                      ; else do type mismatch
  4920                        
  4921                        ; evaluate byte expression, result in X
  4922                        
  4923                        LAB_EVBY
  4924 00:C40F: 20 2F BE           JSR   LAB_EVPI          ; evaluate integer expression (no check)
  4925                        
  4926 00:C412: A4 60              LDY   FAC1_2            ; get FAC1 mantissa2
  4927 00:C414: D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
  4928                        
  4929 00:C416: A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
  4930 00:C418: 4C AB CF           JMP   LAB_GBYT          ; scan memory and return
  4931                        
  4932                        ; perform VAL()
  4933                        
  4934                        LAB_VAL
  4935 00:C41B: 20 F6 C3           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  4936 00:C41E: D0 03              BNE   LAB_23C5          ; branch if not null string
  4937                        
  4938                                                      ; string was null so set result = $00
  4939 00:C420: 4C C8 C5           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  4940                        
  4941                        LAB_23C5
  4942 00:C423: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  4943 00:C425: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  4944 00:C427: 86 6C              STX   Btmpl             ; save BASIC execute pointer low byte
  4945 00:C429: 84 6D              STY   Btmph             ; save BASIC execute pointer high byte
  4946 00:C42B: A6 23              LDX   ut1_pl            ; get string pointer low byte
  4947 00:C42D: 86 6E              STX   Bpntrl            ; save as BASIC execute pointer low byte
  4948 00:C42F: 18                 CLC                     ; clear carry
  4949 00:C430: 65 23              ADC   ut1_pl            ; add string length
  4950 00:C432: 85 25              STA   ut2_pl            ; save string end low byte
  4951 00:C434: A5 24              LDA   ut1_ph            ; get string pointer high byte
  4952 00:C436: 85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
  4953 00:C438: 69 00              ADC   #$00              ; add carry to high byte
  4954 00:C43A: 85 26              STA   ut2_ph            ; save string end high byte
  4955 00:C43C: B2 25              LDA   (ut2_pl)          ; get string end +1 byte
  4956 00:C43E: 48                 PHA                     ; push it
  4957 00:C43F: A9 00              LDA   #$00              ; clear A
  4958 00:C441: 92 25              STA   (ut2_pl)          ; terminate string with $00
  4959 00:C443: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  4960 00:C446: 20 16 C9           JSR   LAB_2887          ; get FAC1 from string
  4961 00:C449: 68                 PLA                     ; restore string end +1 byte
  4962 00:C44A: 92 25              STA   (ut2_pl)          ; put string end byte back
  4963                        
  4964                        ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  4965                        
  4966                        LAB_23F3
  4967 00:C44C: A6 6C              LDX   Btmpl             ; get BASIC execute pointer low byte back
  4968 00:C44E: A4 6D              LDY   Btmph             ; get BASIC execute pointer high byte back
  4969 00:C450: 86 6E              STX   Bpntrl            ; save BASIC execute pointer low byte
  4970 00:C452: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  4971 00:C454: 60                 RTS
  Sun Mar  3 2019 22:47                                                                                                    Page 80


  4972                        
  4973                        ; get two parameters for POKE or WAIT
  4974                        
  4975                        LAB_GADB
  4976 00:C455: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4977                                                      ; else do type mismatch
  4978 00:C458: 20 6E C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  4979                        
  4980                        ; scan for "," and get byte, else do Syntax error then warm start
  4981                        
  4982                        LAB_SCGB
  4983 00:C45B: 20 93 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  4984 00:C45E: A5 0B              LDA   Itemph            ; save temporary integer high byte
  4985 00:C460: 48                 PHA                     ; on stack
  4986 00:C461: A5 0A              LDA   Itempl            ; save temporary integer low byte
  4987 00:C463: 48                 PHA                     ; on stack
  4988 00:C464: 20 0C C4           JSR   LAB_GTBY          ; get byte parameter
  4989 00:C467: 68                 PLA                     ; pull low byte
  4990 00:C468: 85 0A              STA   Itempl            ; restore temporary integer low byte
  4991 00:C46A: 68                 PLA                     ; pull high byte
  4992 00:C46B: 85 0B              STA   Itemph            ; restore temporary integer high byte
  4993 00:C46D: 60                 RTS
  4994                        
  4995                        ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  4996                        ; -ve and converts it into a right truncated integer in Itempl and Itemph
  4997                        
  4998                        ; save unsigned 16 bit integer part of FAC1 in temporary integer
  4999                        
  5000                        LAB_F2FX
  5001 00:C46E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5002 00:C470: C9 98              CMP   #$98              ; compare with exponent = 2^24
  5003 00:C472: B0 92              BCS   LAB_23A8          ; if >= do function call error then warm start
  5004                        
  5005                        LAB_F2FU
  5006 00:C474: 20 C0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  5007 00:C477: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5008 00:C479: A4 61              LDY   FAC1_3            ; get FAC1 mantissa3
  5009 00:C47B: 84 0A              STY   Itempl            ; save temporary integer low byte
  5010 00:C47D: 85 0B              STA   Itemph            ; save temporary integer high byte
  5011 00:C47F: 60                 RTS
  5012                        
  5013                        ; perform PEEK()
  5014                        
  5015                        LAB_PEEK
  5016 00:C480: 20 6E C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5017 00:C483: A2 00              LDX   #$00              ; clear index
  5018 00:C485: A1 0A              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
  5019 00:C487: A8                 TAY                     ; copy byte to Y
  5020 00:C488: 4C F2 BF           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5021                        
  5022                        ; perform POKE
  5023                        
  5024                        LAB_POKE
  5025 00:C48B: 20 55 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5026 00:C48E: 8A                 TXA                     ; copy byte argument to A
  5027 00:C48F: A2 00              LDX   #$00              ; clear index
  5028 00:C491: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  5029 00:C493: 60                 RTS
  5030                        
  5031                        ; perform DEEK()
  5032                        
  5033                        LAB_DEEK
  5034 00:C494: 20 6E C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  Sun Mar  3 2019 22:47                                                                                                    Page 81


  5035 00:C497: A2 00              LDX   #$00              ; clear index
  5036 00:C499: A1 0A              LDA   (Itempl,X)        ; PEEK low byte
  5037 00:C49B: A8                 TAY                     ; copy to Y
  5038 00:C49C: E6 0A              INC   Itempl            ; increment pointer low byte
  5039 00:C49E: D0 02              BNE   Deekh             ; skip high increment if no rollover
  5040                        
  5041 00:C4A0: E6 0B              INC   Itemph            ; increment pointer high byte
  5042                        Deekh
  5043 00:C4A2: A1 0A              LDA   (Itempl,X)        ; PEEK high byte
  5044 00:C4A4: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  5045                        
  5046                        ; perform DOKE
  5047                        
  5048                        LAB_DOKE
  5049 00:C4A7: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5050                                                      ; else do type mismatch
  5051 00:C4AA: 20 6E C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5052                        
  5053 00:C4AD: 84 49              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
  5054 00:C4AF: 85 4A              STA   Frnxth            ; save pointer high byte
  5055                        
  5056 00:C4B1: 20 93 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5057 00:C4B4: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5058                                                      ; else do type mismatch
  5059 00:C4B7: 20 6E C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5060                        
  5061 00:C4BA: 98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
  5062 00:C4BB: A2 00              LDX   #$00              ; clear index
  5063 00:C4BD: 81 49              STA   (Frnxtl,X)        ; POKE low byte
  5064 00:C4BF: E6 49              INC   Frnxtl            ; increment pointer low byte
  5065 00:C4C1: D0 02              BNE   Dokeh             ; skip high increment if no rollover
  5066                        
  5067 00:C4C3: E6 4A              INC   Frnxth            ; increment pointer high byte
  5068                        Dokeh
  5069 00:C4C5: A5 0B              LDA   Itemph            ; get value high byte
  5070 00:C4C7: 81 49              STA   (Frnxtl,X)        ; POKE high byte
  5071 00:C4C9: 4C AB CF           JMP   LAB_GBYT          ; scan memory and return
  5072                        
  5073                        ; perform SWAP
  5074                        
  5075                        LAB_SWAP
  5076 00:C4CC: 20 39 BD           JSR   LAB_GVAR          ; get var1 address
  5077 00:C4CF: 85 49              STA   Lvarpl            ; save var1 address low byte
  5078 00:C4D1: 84 4A              STY   Lvarph            ; save var1 address high byte
  5079 00:C4D3: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  5080 00:C4D5: 48                 PHA                     ; save data type flag
  5081                        
  5082 00:C4D6: 20 93 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5083 00:C4D9: 20 39 BD           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
  5084 00:C4DC: 68                 PLA                     ; pull var1 data type flag
  5085 00:C4DD: 45 11              EOR   Dtypef            ; compare with var2 data type
  5086 00:C4DF: 10 10              BPL   SwapErr           ; exit if not both the same type
  5087                        
  5088 00:C4E1: A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
  5089                        SwapLp
  5090 00:C4E3: B1 49              LDA   (Lvarpl),Y        ; get byte from var1
  5091 00:C4E5: AA                 TAX                     ; save var1 byte
  5092 00:C4E6: B1 47              LDA   (Cvaral),Y        ; get byte from var2
  5093 00:C4E8: 91 49              STA   (Lvarpl),Y        ; save byte to var1
  5094 00:C4EA: 8A                 TXA                     ; restore var1 byte
  5095 00:C4EB: 91 47              STA   (Cvaral),Y        ; save byte to var2
  5096 00:C4ED: 88                 DEY                     ; decrement index
  5097 00:C4EE: 10 F3              BPL   SwapLp            ; loop until done
  Sun Mar  3 2019 22:47                                                                                                    Page 82


  5098 00:C4F0: 60                 RTS
  5099                        
  5100                        SwapErr
  5101 00:C4F1: 4C 76 BA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  5102                        
  5103                        ; perform CALL
  5104                        
  5105                        LAB_CALL
  5106 00:C4F4: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5107                                                      ; else do type mismatch
  5108 00:C4F7: 20 6E C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5109 00:C4FA: A9 C5              LDA   #>CallExit        ; set return address high byte
  5110 00:C4FC: 48                 PHA                     ; put on stack
  5111 00:C4FD: A9 02              LDA   #<CallExit-1      ; set return address low byte
  5112 00:C4FF: 48                 PHA                     ; put on stack
  5113 00:C500: 6C 0A 00           JMP   (Itempl)          ; do indirect jump to user routine
  5114                        
  5115                        ; if the called routine exits correctly then it will return to here. this will then get
  5116                        ; the next byte for the interpreter and return
  5117                        
  5118                        CallExit
  5119 00:C503: 4C AB CF           JMP   LAB_GBYT          ; scan memory and return
  5120                        
  5121                        ; perform WAIT
  5122                        
  5123                        LAB_WAIT
  5124 00:C506: 20 55 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5125 00:C509: 86 49              STX   Frnxtl            ; save byte
  5126 00:C50B: A2 00              LDX   #$00              ; clear mask
  5127 00:C50D: 20 AB CF           JSR   LAB_GBYT          ; scan memory
  5128 00:C510: F0 03              BEQ   LAB_2441          ; skip if no third argument
  5129                        
  5130 00:C512: 20 5B C4           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
  5131                        LAB_2441
  5132 00:C515: 86 4A              STX   Frnxth            ; save EOR argument
  5133                        LAB_2445
  5134 00:C517: B1 0A              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
  5135 00:C519: 45 4A              EOR   Frnxth            ; EOR with second argument (mask)
  5136 00:C51B: 25 49              AND   Frnxtl            ; AND with first argument (byte)
  5137 00:C51D: F0 F8              BEQ   LAB_2445          ; loop if result is zero
  5138                        
  5139                        LAB_244D
  5140 00:C51F: 60                 RTS
  5141                        
  5142                        ; perform subtraction, FAC1 from (AY)
  5143                        
  5144                        LAB_2455
  5145 00:C520: 20 01 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5146                        
  5147                        ; perform subtraction, FAC1 from FAC2
  5148                        
  5149                        LAB_SUBTRACT
  5150 00:C523: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5151 00:C525: 49 FF              EOR   #$FF              ; complement it
  5152 00:C527: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5153 00:C529: 45 69              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
  5154 00:C52B: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5155 00:C52D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5156 00:C52F: 80 0C              BRA   LAB_ADD           ; go add FAC2 to FAC1
  5157                        
  5158                        ; perform addition
  5159                        
  5160                        LAB_2467
  Sun Mar  3 2019 22:47                                                                                                    Page 83


  5161 00:C531: 20 52 C6           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
  5162 00:C534: 90 49              BCC   LAB_24A8          ; go subtract mantissas
  5163                        
  5164                        ; add 0.5 to FAC1
  5165                        
  5166                        LAB_244E
  5167 00:C536: A9 87              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
  5168 00:C538: A0 D0              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
  5169                        
  5170                        ; add (AY) to FAC1
  5171                        
  5172                        LAB_246C
  5173 00:C53A: 20 01 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5174                        
  5175                        ; add FAC2 to FAC1
  5176                        
  5177                        LAB_ADD
  5178 00:C53D: D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
  5179                        
  5180                        ; copy FAC2 to FAC1
  5181                        
  5182                        LAB_279B
  5183 00:C53F: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  5184                        
  5185                        ; save FAC1 sign and copy ABS(FAC2) to FAC1
  5186                        
  5187                        LAB_279D
  5188 00:C541: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5189 00:C543: A2 04              LDX   #$04              ; 4 bytes to copy
  5190                        LAB_27A1
  5191 00:C545: B5 64              LDA   FAC1_o,X          ; get byte from FAC2,X
  5192 00:C547: 95 5D              STA   FAC1_e-1,X        ; save byte at FAC1,X
  5193 00:C549: CA                 DEX                     ; decrement count
  5194 00:C54A: D0 F9              BNE   LAB_27A1          ; loop if not all done
  5195                        
  5196 00:C54C: 86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
  5197 00:C54E: 60                 RTS
  5198                        
  5199                                                      ; FAC1 is non zero
  5200                        LAB_2474
  5201 00:C54F: A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
  5202 00:C551: 86 55              STX   FAC2_r            ; save as FAC2 rounding byte
  5203 00:C553: A2 65              LDX   #FAC2_e           ; set index to FAC2 exponent addr
  5204 00:C555: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  5205                        LAB_247C
  5206 00:C557: A8                 TAY                     ; copy exponent
  5207 00:C558: F0 C5              BEQ   LAB_244D          ; exit if zero
  5208                        
  5209 00:C55A: 38                 SEC                     ; set carry for subtract
  5210 00:C55B: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
  5211 00:C55D: F0 20              BEQ   LAB_24A8          ; branch if = (go add mantissa)
  5212 00:C55F: 90 10              BCC   LAB_2498          ; branch if <
  5213                        
  5214                                                      ; FAC2>FAC1
  5215 00:C561: 84 5E              STY   FAC1_e            ; save FAC1 exponent
  5216 00:C563: A4 69              LDY   FAC2_s            ; get FAC2 sign (b7)
  5217 00:C565: 84 62              STY   FAC1_s            ; save FAC1 sign (b7)
  5218 00:C567: 49 FF              EOR   #$FF              ; complement A
  5219 00:C569: 69 00              ADC   #$00              ; +1 (twos complement, carry is set)
  5220 00:C56B: 64 55              STZ   FAC2_r            ; clear FAC2 rounding byte
  5221 00:C56D: A2 5E              LDX   #FAC1_e           ; set index to FAC1 exponent addr
  5222 00:C56F: 80 02              BRA   LAB_249C          ; branch always
  5223                        
  Sun Mar  3 2019 22:47                                                                                                    Page 84


  5224                        LAB_2498
  5225 00:C571: 64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
  5226                        LAB_249C
  5227 00:C573: C9 F9              CMP   #$F9              ; compare exponent diff with $F9
  5228 00:C575: 30 BA              BMI   LAB_2467          ; branch if range $79-$F8
  5229                        
  5230 00:C577: A8                 TAY                     ; copy exponent difference to Y
  5231 00:C578: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5232 00:C57A: 56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
  5233 00:C57C: 20 69 C6           JSR   LAB_2592          ; shift FACX Y times right
  5234                        
  5235                                                      ; exponents are equal now do mantissa subtract
  5236                        LAB_24A8
  5237 00:C57F: 24 6A              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
  5238 00:C581: 10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
  5239                        
  5240 00:C583: A0 5E              LDY   #FAC1_e           ; set index to FAC1 exponent addr
  5241 00:C585: E0 65              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
  5242 00:C587: F0 02              BEQ   LAB_24B4          ; branch if =
  5243                        
  5244 00:C589: A0 65              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
  5245                        
  5246                                                      ; subtract smaller from bigger (take sign of bigger)
  5247                        LAB_24B4
  5248 00:C58B: 38                 SEC                     ; set carry for subtract
  5249 00:C58C: 49 FF              EOR   #$FF              ; ones complement A
  5250 00:C58E: 65 55              ADC   FAC2_r            ; add FAC2 rounding byte
  5251 00:C590: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5252 00:C592: B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
  5253 00:C595: F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
  5254 00:C597: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5255 00:C599: B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
  5256 00:C59C: F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
  5257 00:C59E: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5258 00:C5A0: B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
  5259 00:C5A3: F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
  5260 00:C5A5: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5261                        
  5262                        ; do ABS and normalise FAC1
  5263                        
  5264                        LAB_24D0
  5265 00:C5A7: B0 03              BCS   LAB_24D5          ; branch if number is +ve
  5266                        
  5267 00:C5A9: 20 0E C6           JSR   LAB_2537          ; negate FAC1
  5268                        
  5269                        ; normalise FAC1
  5270                        
  5271                        LAB_24D5
  5272 00:C5AC: A9 00              LDA   #$00              ; clear A
  5273 00:C5AE: A8                 TAY                     ; clear Y
  5274 00:C5AF: 18                 CLC                     ; clear carry for add
  5275                        LAB_24D9
  5276 00:C5B0: A6 5F              LDX   FAC1_1            ; get FAC1 mantissa1
  5277 00:C5B2: D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
  5278                        
  5279 00:C5B4: A6 60              LDX   FAC1_2            ; get FAC1 mantissa2
  5280 00:C5B6: 86 5F              STX   FAC1_1            ; save FAC1 mantissa1
  5281 00:C5B8: A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
  5282 00:C5BA: 86 60              STX   FAC1_2            ; save FAC1 mantissa2
  5283 00:C5BC: A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
  5284 00:C5BE: 86 61              STX   FAC1_3            ; save FAC1 mantissa3
  5285 00:C5C0: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5286 00:C5C2: 69 08              ADC   #$08              ; add x to exponent offset
  Sun Mar  3 2019 22:47                                                                                                    Page 85


  5287 00:C5C4: C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
  5288 00:C5C6: D0 E8              BNE   LAB_24D9          ; loop if not max
  5289                        
  5290                        ; clear FAC1 exponent and sign
  5291                        
  5292                        LAB_24F1
  5293 00:C5C8: A9 00              LDA   #$00              ; clear A
  5294                        LAB_24F3
  5295 00:C5CA: 85 5E              STA   FAC1_e            ; set FAC1 exponent
  5296                        
  5297                        ; save FAC1 sign
  5298                        
  5299                        LAB_24F5
  5300 00:C5CC: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5301 00:C5CE: 60                 RTS
  5302                        
  5303                        ; add FAC2 mantissa to FAC1 mantissa
  5304                        
  5305                        LAB_24F8
  5306 00:C5CF: 65 55              ADC   FAC2_r            ; add FAC2 rounding byte
  5307 00:C5D1: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5308 00:C5D3: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5309 00:C5D5: 65 68              ADC   FAC2_3            ; add FAC2 mantissa3
  5310 00:C5D7: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5311 00:C5D9: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5312 00:C5DB: 65 67              ADC   FAC2_2            ; add FAC2 mantissa2
  5313 00:C5DD: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5314 00:C5DF: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5315 00:C5E1: 65 66              ADC   FAC2_1            ; add FAC2 mantissa1
  5316 00:C5E3: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5317 00:C5E5: B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
  5318 00:C5E7: 60                 RTS                     ; else just exit
  5319                        
  5320                        LAB_2511
  5321 00:C5E8: 69 01              ADC   #$01              ; add 1 to exponent offset
  5322 00:C5EA: 06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
  5323 00:C5EC: 26 61              ROL   FAC1_3            ; shift FAC1 mantissa3
  5324 00:C5EE: 26 60              ROL   FAC1_2            ; shift FAC1 mantissa2
  5325 00:C5F0: 26 5F              ROL   FAC1_1            ; shift FAC1 mantissa1
  5326                        
  5327                        ; normalise FAC1
  5328                        
  5329                        LAB_251B
  5330 00:C5F2: 10 F4              BPL   LAB_2511          ; loop if not normalised
  5331                        
  5332 00:C5F4: 38                 SEC                     ; set carry for subtract
  5333 00:C5F5: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
  5334 00:C5F7: B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
  5335                        
  5336 00:C5F9: 49 FF              EOR   #$FF              ; complement exponent
  5337 00:C5FB: 69 01              ADC   #$01              ; +1 (twos complement)
  5338 00:C5FD: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5339                        
  5340                        ; test and normalise FAC1 for C=0/1
  5341                        
  5342                        LAB_2528
  5343 00:C5FF: 90 0C              BCC   LAB_2536          ; exit if no overflow
  5344                        
  5345                        ; normalise FAC1 for C=1
  5346                        
  5347                        LAB_252A
  5348 00:C601: E6 5E              INC   FAC1_e            ; increment FAC1 exponent
  5349 00:C603: F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
  Sun Mar  3 2019 22:47                                                                                                    Page 86


  5350                        
  5351 00:C605: 66 5F              ROR   FAC1_1            ; shift FAC1 mantissa1
  5352 00:C607: 66 60              ROR   FAC1_2            ; shift FAC1 mantissa2
  5353 00:C609: 66 61              ROR   FAC1_3            ; shift FAC1 mantissa3
  5354 00:C60B: 66 6B              ROR   FAC1_r            ; shift FAC1 rounding byte
  5355                        LAB_2536
  5356 00:C60D: 60                 RTS
  5357                        
  5358                        ; negate FAC1
  5359                        
  5360                        LAB_2537
  5361 00:C60E: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5362 00:C610: 49 FF              EOR   #$FF              ; complement it
  5363 00:C612: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5364                        
  5365                        ; twos complement FAC1 mantissa
  5366                        
  5367                        LAB_253D
  5368 00:C614: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5369 00:C616: 49 FF              EOR   #$FF              ; complement it
  5370 00:C618: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5371 00:C61A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5372 00:C61C: 49 FF              EOR   #$FF              ; complement it
  5373 00:C61E: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5374 00:C620: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5375 00:C622: 49 FF              EOR   #$FF              ; complement it
  5376 00:C624: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5377 00:C626: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5378 00:C628: 49 FF              EOR   #$FF              ; complement it
  5379 00:C62A: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5380 00:C62C: E6 6B              INC   FAC1_r            ; increment FAC1 rounding byte
  5381 00:C62E: D0 0A              BNE   LAB_2563          ; exit if no overflow
  5382                        
  5383                        ; increment FAC1 mantissa
  5384                        
  5385                        LAB_2559
  5386 00:C630: E6 61              INC   FAC1_3            ; increment FAC1 mantissa3
  5387 00:C632: D0 06              BNE   LAB_2563          ; finished if no rollover
  5388                        
  5389 00:C634: E6 60              INC   FAC1_2            ; increment FAC1 mantissa2
  5390 00:C636: D0 02              BNE   LAB_2563          ; finished if no rollover
  5391                        
  5392 00:C638: E6 5F              INC   FAC1_1            ; increment FAC1 mantissa1
  5393                        LAB_2563
  5394 00:C63A: 60                 RTS
  5395                        
  5396                        ; do overflow error (overflow exit)
  5397                        
  5398                        LAB_2564
  5399 00:C63B: A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
  5400 00:C63D: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  5401                        
  5402                        ; shift FCAtemp << A+8 times
  5403                        
  5404                        LAB_2569
  5405 00:C640: A2 26              LDX   #FACt_1-1         ; set offset to FACtemp
  5406                        LAB_256B
  5407 00:C642: B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
  5408 00:C644: 84 6B              STY   FAC1_r            ; save as FAC1 rounding byte
  5409 00:C646: B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
  5410 00:C648: 94 03              STY   PLUS_3,X          ; save FACX mantissa3
  5411 00:C64A: B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
  5412 00:C64C: 94 02              STY   PLUS_2,X          ; save FACX mantissa2
  Sun Mar  3 2019 22:47                                                                                                    Page 87


  5413 00:C64E: A4 64              LDY   FAC1_o            ; get FAC1 overflow byte
  5414 00:C650: 94 01              STY   PLUS_1,X          ; save FACX mantissa1
  5415                        
  5416                        ; shift FACX -A times right (> 8 shifts)
  5417                        
  5418                        LAB_257B
  5419 00:C652: 69 08              ADC   #$08              ; add 8 to shift count
  5420 00:C654: 30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
  5421                        
  5422 00:C656: F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
  5423                        
  5424 00:C658: E9 08              SBC   #$08              ; else subtract 8 again
  5425 00:C65A: A8                 TAY                     ; save count to Y
  5426 00:C65B: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5427 00:C65D: B0 12              BCS   LAB_259A          ; 
  5428                        
  5429                        LAB_2588
  5430 00:C65F: 16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
  5431 00:C661: 90 02              BCC   LAB_258E          ; branch if +ve
  5432                        
  5433 00:C663: F6 01              INC   PLUS_1,X          ; this sets b7 eventually
  5434                        LAB_258E
  5435 00:C665: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
  5436 00:C667: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
  5437                        
  5438                        ; shift FACX Y times right
  5439                        
  5440                        LAB_2592
  5441 00:C669: 76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
  5442 00:C66B: 76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
  5443 00:C66D: 6A                 ROR                     ; shift FACX rounding byte
  5444 00:C66E: C8                 INY                     ; increment exponent diff
  5445 00:C66F: D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
  5446                        
  5447                        LAB_259A
  5448 00:C671: 18                 CLC                     ; just clear it
  5449 00:C672: 60                 RTS
  5450                        
  5451                        ; perform LOG()
  5452                        
  5453                        LAB_LOG
  5454 00:C673: 20 5E C8           JSR   LAB_27CA          ; test sign and zero
  5455 00:C676: F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
  5456                        
  5457 00:C678: 10 03              BPL   LAB_25C7          ; skip error if +ve
  5458                        
  5459                        LAB_25C4
  5460 00:C67A: 4C B5 BE           JMP   LAB_FCER          ; do function call error then warm start (-ve)
  5461                        
  5462                        LAB_25C7
  5463 00:C67D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5464 00:C67F: E9 7F              SBC   #$7F              ; normalise it
  5465 00:C681: 48                 PHA                     ; save it
  5466 00:C682: A9 80              LDA   #$80              ; set exponent to zero
  5467 00:C684: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5468 00:C686: A9 07              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
  5469 00:C688: A0 D0              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
  5470 00:C68A: 20 3A C5           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
  5471 00:C68D: A9 0B              LDA   #<LAB_25B1        ; set root2 pointer low byte
  5472 00:C68F: A0 D0              LDY   #>LAB_25B1        ; set root2 pointer high byte
  5473 00:C691: 20 77 C7           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5474 00:C694: A9 7E              LDA   #<LAB_259C        ; set 1 pointer low byte
  5475 00:C696: A0 D0              LDY   #>LAB_259C        ; set 1 pointer high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 88


  5476 00:C698: 20 20 C5           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5477 00:C69B: A9 FA              LDA   #<LAB_25A0        ; set pointer low byte to counter
  5478 00:C69D: A0 CF              LDY   #>LAB_25A0        ; set pointer high byte to counter
  5479 00:C69F: 20 B8 CB           JSR   LAB_2B6E          ; ^2 then series evaluation
  5480 00:C6A2: A9 0F              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
  5481 00:C6A4: A0 D0              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
  5482 00:C6A6: 20 3A C5           JSR   LAB_246C          ; add (AY) to FAC1
  5483 00:C6A9: 68                 PLA                     ; restore FAC1 exponent
  5484 00:C6AA: 20 B1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  5485 00:C6AD: A9 13              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
  5486 00:C6AF: A0 D0              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
  5487                        
  5488                        ; do convert AY, FCA1*(AY)
  5489                        
  5490                        LAB_25FB
  5491 00:C6B1: 20 01 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5492                        LAB_MULTIPLY
  5493 00:C6B4: F0 4A              BEQ   LAB_264C          ; exit if zero
  5494                        
  5495 00:C6B6: 20 27 C7           JSR   LAB_2673          ; test and adjust accumulators
  5496 00:C6B9: 64 27              STZ   FACt_1            ; clear temp mantissa1
  5497 00:C6BB: 64 28              STZ   FACt_2            ; clear temp mantissa2
  5498 00:C6BD: 64 29              STZ   FACt_3            ; clear temp mantissa3
  5499 00:C6BF: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5500 00:C6C1: 20 D6 C6           JSR   LAB_2622          ; go do shift/add FAC2
  5501 00:C6C4: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5502 00:C6C6: 20 D6 C6           JSR   LAB_2622          ; go do shift/add FAC2
  5503 00:C6C9: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5504 00:C6CB: 20 D6 C6           JSR   LAB_2622          ; go do shift/add FAC2
  5505 00:C6CE: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5506 00:C6D0: 20 DB C6           JSR   LAB_2627          ; go do shift/add FAC2
  5507 00:C6D3: 4C E3 C7           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
  5508                        
  5509                        LAB_2622
  5510 00:C6D6: D0 03              BNE   LAB_2627          ; branch if byte <> zero
  5511                        
  5512 00:C6D8: 4C 40 C6           JMP   LAB_2569          ; shift FCAtemp << A+8 times
  5513                        
  5514                                                      ; else do shift and add
  5515                        LAB_2627
  5516 00:C6DB: 4A                 LSR                     ; shift byte
  5517 00:C6DC: 09 80              ORA   #$80              ; set top bit (mark for 8 times)
  5518                        LAB_262A
  5519 00:C6DE: A8                 TAY                     ; copy result
  5520 00:C6DF: 90 13              BCC   LAB_2640          ; skip next if bit was zero
  5521                        
  5522 00:C6E1: 18                 CLC                     ; clear carry for add
  5523 00:C6E2: A5 29              LDA   FACt_3            ; get temp mantissa3
  5524 00:C6E4: 65 68              ADC   FAC2_3            ; add FAC2 mantissa3
  5525 00:C6E6: 85 29              STA   FACt_3            ; save temp mantissa3
  5526 00:C6E8: A5 28              LDA   FACt_2            ; get temp mantissa2
  5527 00:C6EA: 65 67              ADC   FAC2_2            ; add FAC2 mantissa2
  5528 00:C6EC: 85 28              STA   FACt_2            ; save temp mantissa2
  5529 00:C6EE: A5 27              LDA   FACt_1            ; get temp mantissa1
  5530 00:C6F0: 65 66              ADC   FAC2_1            ; add FAC2 mantissa1
  5531 00:C6F2: 85 27              STA   FACt_1            ; save temp mantissa1
  5532                        LAB_2640
  5533 00:C6F4: 66 27              ROR   FACt_1            ; shift temp mantissa1
  5534 00:C6F6: 66 28              ROR   FACt_2            ; shift temp mantissa2
  5535 00:C6F8: 66 29              ROR   FACt_3            ; shift temp mantissa3
  5536 00:C6FA: 66 6B              ROR   FAC1_r            ; shift temp rounding byte
  5537 00:C6FC: 98                 TYA                     ; get byte back
  5538 00:C6FD: 4A                 LSR                     ; shift byte
  Sun Mar  3 2019 22:47                                                                                                    Page 89


  5539 00:C6FE: D0 DE              BNE   LAB_262A          ; loop if all bits not done
  5540                        
  5541                        LAB_264C
  5542 00:C700: 60                 RTS
  5543                        
  5544                        ; unpack memory (AY) into FAC2
  5545                        
  5546                        LAB_264D
  5547 00:C701: 85 23              STA   ut1_pl            ; save pointer low byte
  5548 00:C703: 84 24              STY   ut1_ph            ; save pointer high byte
  5549 00:C705: A0 03              LDY   #$03              ; 4 bytes to get (0-3)
  5550 00:C707: B1 23              LDA   (ut1_pl),Y        ; get mantissa3
  5551 00:C709: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  5552 00:C70B: 88                 DEY                     ; decrement index
  5553 00:C70C: B1 23              LDA   (ut1_pl),Y        ; get mantissa2
  5554 00:C70E: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  5555 00:C710: 88                 DEY                     ; decrement index
  5556 00:C711: B1 23              LDA   (ut1_pl),Y        ; get mantissa1+sign
  5557 00:C713: 85 69              STA   FAC2_s            ; save FAC2 sign (b7)
  5558 00:C715: 45 62              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
  5559 00:C717: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5560 00:C719: A5 69              LDA   FAC2_s            ; recover FAC2 sign (b7)
  5561 00:C71B: 09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
  5562 00:C71D: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  5563 00:C71F: 88                 DEY                     ; decrement index
  5564 00:C720: B1 23              LDA   (ut1_pl),Y        ; get exponent byte
  5565 00:C722: 85 65              STA   FAC2_e            ; save FAC2 exponent
  5566 00:C724: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5567 00:C726: 60                 RTS
  5568                        
  5569                        ; test and adjust accumulators
  5570                        
  5571                        LAB_2673
  5572 00:C727: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  5573                        LAB_2675
  5574 00:C729: F0 1E              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
  5575                        
  5576 00:C72B: 18                 CLC                     ; clear carry for add
  5577 00:C72C: 65 5E              ADC   FAC1_e            ; add FAC1 exponent
  5578 00:C72E: 90 05              BCC   LAB_2680          ; branch if sum of exponents <$0100
  5579                        
  5580 00:C730: 30 32              BMI   LAB_269B          ; do overflow error
  5581                        
  5582 00:C732: 18                 CLC                     ; clear carry for the add
  5583 00:C733: 80 02              BRA   LAB_2680b         ; branch around next instruction, saves one clock cycle
  5584                        LAB_2680
  5585 00:C735: 10 12              BPL   LAB_2696          ; if +ve go handle underflow
  5586                        LAB_2680b
  5587 00:C737: 69 80              ADC   #$80              ; adjust exponent
  5588 00:C739: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5589 00:C73B: D0 03              BNE   LAB_268B          ; branch if not zero
  5590                        
  5591 00:C73D: 4C CC C5           JMP   LAB_24F5          ; save FAC1 sign and return
  5592                        
  5593                        LAB_268B
  5594 00:C740: A5 6A              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
  5595 00:C742: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5596                        LAB_268F
  5597 00:C744: 60                 RTS
  5598                        
  5599                        ; handle overflow and underflow
  5600                        
  5601                        LAB_2690
  Sun Mar  3 2019 22:47                                                                                                    Page 90


  5602 00:C745: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5603 00:C747: 10 1B              BPL   LAB_269B          ; do overflow error
  5604                        
  5605                                                      ; handle underflow
  5606                        LAB_2696
  5607 00:C749: 68                 PLA                     ; pop return address low byte
  5608 00:C74A: 68                 PLA                     ; pop return address high byte
  5609 00:C74B: 4C C8 C5           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  5610                        
  5611                        ; multiply by 10
  5612                        
  5613                        LAB_269E
  5614 00:C74E: 20 3F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  5615 00:C751: AA                 TAX                     ; copy exponent (set the flags)
  5616 00:C752: F0 F0              BEQ   LAB_268F          ; exit if zero
  5617                        
  5618 00:C754: 18                 CLC                     ; clear carry for add
  5619 00:C755: 69 02              ADC   #$02              ; add two to exponent (*4)
  5620 00:C757: B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
  5621                        
  5622 00:C759: A2 00              LDX   #$00              ; clear byte
  5623 00:C75B: 86 6A              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  5624 00:C75D: 20 57 C5           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
  5625 00:C760: E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*10)
  5626 00:C762: D0 E0              BNE   LAB_268F          ; if non zero just do RTS
  5627                        
  5628                        LAB_269B
  5629 00:C764: 4C 3B C6           JMP   LAB_2564          ; do overflow error and warm start
  5630                        
  5631                        ; divide by 10
  5632                        
  5633                        LAB_26B9
  5634 00:C767: 20 3F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  5635 00:C76A: A9 8F              LDA   #<LAB_26B5        ; set pointer to 10d low addr
  5636 00:C76C: A0 D0              LDY   #>LAB_26B5        ; set pointer to 10d high addr
  5637 00:C76E: A2 00              LDX   #$00              ; clear sign
  5638                        
  5639                        ; divide by (AY) (X=sign)
  5640                        
  5641                        LAB_26C2
  5642 00:C770: 86 6A              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5643 00:C772: 20 F2 C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  5644 00:C775: 80 03              BRA   LAB_DIVIDE        ; do FAC2/FAC1
  5645                        
  5646                                                      ; Perform divide-by
  5647                        ; convert AY and do (AY)/FAC1
  5648                        
  5649                        LAB_26CA
  5650 00:C777: 20 01 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5651                        
  5652                                                      ; Perform divide-into
  5653                        LAB_DIVIDE
  5654 00:C77A: F0 62              BEQ   LAB_2737          ; if zero go do /0 error
  5655                        
  5656 00:C77C: 20 4E C8           JSR   LAB_27BA          ; round FAC1
  5657 00:C77F: A9 00              LDA   #$00              ; clear A
  5658 00:C781: 38                 SEC                     ; set carry for subtract
  5659 00:C782: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
  5660 00:C784: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5661 00:C786: 20 27 C7           JSR   LAB_2673          ; test and adjust accumulators
  5662 00:C789: E6 5E              INC   FAC1_e            ; increment FAC1 exponent
  5663 00:C78B: F0 D7              BEQ   LAB_269B          ; if zero do overflow error
  5664                        
  Sun Mar  3 2019 22:47                                                                                                    Page 91


  5665 00:C78D: A2 FF              LDX   #$FF              ; set index for pre increment
  5666 00:C78F: A9 01              LDA   #$01              ; set bit to flag byte save
  5667                        LAB_26E4
  5668 00:C791: A4 66              LDY   FAC2_1            ; get FAC2 mantissa1
  5669 00:C793: C4 5F              CPY   FAC1_1            ; compare FAC1 mantissa1
  5670 00:C795: D0 0A              BNE   LAB_26F4          ; branch if <>
  5671                        
  5672 00:C797: A4 67              LDY   FAC2_2            ; get FAC2 mantissa2
  5673 00:C799: C4 60              CPY   FAC1_2            ; compare FAC1 mantissa2
  5674 00:C79B: D0 04              BNE   LAB_26F4          ; branch if <>
  5675                        
  5676 00:C79D: A4 68              LDY   FAC2_3            ; get FAC2 mantissa3
  5677 00:C79F: C4 61              CPY   FAC1_3            ; compare FAC1 mantissa3
  5678                        LAB_26F4
  5679 00:C7A1: 08                 PHP                     ; save FAC2-FAC1 compare status
  5680 00:C7A2: 2A                 ROL                     ; shift the result byte
  5681 00:C7A3: 90 0E              BCC   LAB_2702          ; if no carry skip the byte save
  5682                        
  5683 00:C7A5: A0 01              LDY   #$01              ; set bit to flag byte save
  5684 00:C7A7: E8                 INX                     ; else increment the index to FACt
  5685 00:C7A8: E0 02              CPX   #$02              ; compare with the index to FACt_3
  5686 00:C7AA: 30 04              BMI   LAB_2701          ; if not last byte just go save it
  5687                        
  5688 00:C7AC: D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
  5689                                                      ; return
  5690                        
  5691 00:C7AE: A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
  5692                        LAB_2701
  5693 00:C7B0: 95 27              STA   FACt_1,X          ; write result byte to FACt_1 + index
  5694 00:C7B2: 98                 TYA                     ; copy the next save byte flag
  5695                        LAB_2702
  5696 00:C7B3: 28                 PLP                     ; restore FAC2-FAC1 compare status
  5697 00:C7B4: 90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
  5698                        
  5699 00:C7B6: A8                 TAY                     ; save FAC2-FAC1 compare status
  5700 00:C7B7: A5 68              LDA   FAC2_3            ; get FAC2 mantissa3
  5701 00:C7B9: E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
  5702 00:C7BB: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  5703 00:C7BD: A5 67              LDA   FAC2_2            ; get FAC2 mantissa2
  5704 00:C7BF: E5 60              SBC   FAC1_2            ; subtract FAC1 mantissa2
  5705 00:C7C1: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  5706 00:C7C3: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  5707 00:C7C5: E5 5F              SBC   FAC1_1            ; subtract FAC1 mantissa1
  5708 00:C7C7: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  5709 00:C7C9: 98                 TYA                     ; restore FAC2-FAC1 compare status
  5710                        
  5711                                                      ; FAC2 = FAC2*2
  5712                        LAB_2704
  5713 00:C7CA: 06 68              ASL   FAC2_3            ; shift FAC2 mantissa3
  5714 00:C7CC: 26 67              ROL   FAC2_2            ; shift FAC2 mantissa2
  5715 00:C7CE: 26 66              ROL   FAC2_1            ; shift FAC2 mantissa1
  5716 00:C7D0: B0 CF              BCS   LAB_26F4          ; loop with no compare
  5717                        
  5718 00:C7D2: 30 BD              BMI   LAB_26E4          ; loop with compare
  5719 00:C7D4: 80 CB              BRA   LAB_26F4          ; loop always with no compare
  5720                        
  5721                        ; do A<<6, save as FAC1 rounding byte, normalise and return
  5722                        
  5723                        LAB_272B
  5724 00:C7D6: 4A                 LSR                     ; shift b1 - b0 ..
  5725 00:C7D7: 6A                 ROR                     ; ..
  5726 00:C7D8: 6A                 ROR                     ; .. to b7 - b6
  5727 00:C7D9: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  Sun Mar  3 2019 22:47                                                                                                    Page 92


  5728 00:C7DB: 28                 PLP                     ; dump FAC2-FAC1 compare status
  5729 00:C7DC: 80 05              BRA   LAB_273C          ; copy temp to FAC1, normalise and return
  5730                        
  5731                        ; do "Divide by zero" error
  5732                        
  5733                        LAB_2737
  5734 00:C7DE: A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
  5735 00:C7E0: 4C 06 B1           JMP   LAB_XERR          ; do error #X, then warm start
  5736                        
  5737                        ; copy temp to FAC1 and normalise
  5738                        
  5739                        LAB_273C
  5740 00:C7E3: A5 27              LDA   FACt_1            ; get temp mantissa1
  5741 00:C7E5: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5742 00:C7E7: A5 28              LDA   FACt_2            ; get temp mantissa2
  5743 00:C7E9: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5744 00:C7EB: A5 29              LDA   FACt_3            ; get temp mantissa3
  5745 00:C7ED: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5746 00:C7EF: 4C AC C5           JMP   LAB_24D5          ; normalise FAC1 and return
  5747                        
  5748                        ; unpack memory (AY) into FAC1
  5749                        
  5750                        LAB_UFAC
  5751 00:C7F2: 85 23              STA   ut1_pl            ; save pointer low byte
  5752 00:C7F4: 84 24              STY   ut1_ph            ; save pointer high byte
  5753 00:C7F6: A0 03              LDY   #$03              ; 4 bytes to do
  5754 00:C7F8: B1 23              LDA   (ut1_pl),Y        ; get last byte
  5755 00:C7FA: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5756 00:C7FC: 88                 DEY                     ; decrement index
  5757 00:C7FD: B1 23              LDA   (ut1_pl),Y        ; get last-1 byte
  5758 00:C7FF: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5759 00:C801: 88                 DEY                     ; decrement index
  5760 00:C802: B1 23              LDA   (ut1_pl),Y        ; get second byte
  5761 00:C804: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5762 00:C806: 09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
  5763 00:C808: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5764 00:C80A: 88                 DEY                     ; decrement index
  5765 00:C80B: B1 23              LDA   (ut1_pl),Y        ; get first byte (exponent)
  5766 00:C80D: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5767 00:C80F: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5768 00:C811: 60                 RTS
  5769                        
  5770                        ; pack FAC1 into Adatal
  5771                        
  5772                        LAB_276E
  5773 00:C812: A2 56              LDX   #<Adatal          ; set pointer low byte
  5774                        LAB_2770
  5775 00:C814: A0 00              LDY   #>Adatal          ; set pointer high byte
  5776 00:C816: F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
  5777                        
  5778                        ; pack FAC1 into (Lvarpl)
  5779                        
  5780                        LAB_PFAC
  5781 00:C818: A6 49              LDX   Lvarpl            ; get destination pointer low byte
  5782 00:C81A: A4 4A              LDY   Lvarph            ; get destination pointer high byte
  5783                        
  5784                        ; pack FAC1 into (XY)
  5785                        
  5786                        LAB_2778
  5787 00:C81C: 20 4E C8           JSR   LAB_27BA          ; round FAC1
  5788 00:C81F: 86 23              STX   ut1_pl            ; save pointer low byte
  5789 00:C821: 84 24              STY   ut1_ph            ; save pointer high byte
  5790 00:C823: A0 03              LDY   #$03              ; set index
  Sun Mar  3 2019 22:47                                                                                                    Page 93


  5791 00:C825: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5792 00:C827: 91 23              STA   (ut1_pl),Y        ; store in destination
  5793 00:C829: 88                 DEY                     ; decrement index
  5794 00:C82A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5795 00:C82C: 91 23              STA   (ut1_pl),Y        ; store in destination
  5796 00:C82E: 88                 DEY                     ; decrement index
  5797 00:C82F: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5798 00:C831: 09 7F              ORA   #$7F              ; set bits x111 1111
  5799 00:C833: 25 5F              AND   FAC1_1            ; AND in FAC1 mantissa1
  5800 00:C835: 91 23              STA   (ut1_pl),Y        ; store in destination
  5801 00:C837: 88                 DEY                     ; decrement index
  5802 00:C838: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5803 00:C83A: 91 23              STA   (ut1_pl),Y        ; store in destination
  5804 00:C83C: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5805 00:C83E: 60                 RTS
  5806                        
  5807                        ; round and copy FAC1 to FAC2
  5808                        
  5809                        LAB_27AB
  5810 00:C83F: 20 4E C8           JSR   LAB_27BA          ; round FAC1
  5811                        
  5812                        ; copy FAC1 to FAC2
  5813                        
  5814                        LAB_27AE
  5815 00:C842: A2 05              LDX   #$05              ; 5 bytes to copy
  5816                        LAB_27B0
  5817 00:C844: B5 5D              LDA   FAC1_e-1,X        ; get byte from FAC1,X
  5818 00:C846: 95 64              STA   FAC1_o,X          ; save byte at FAC2,X
  5819 00:C848: CA                 DEX                     ; decrement count
  5820 00:C849: D0 F9              BNE   LAB_27B0          ; loop if not all done
  5821                        
  5822 00:C84B: 86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
  5823                        LAB_27B9
  5824 00:C84D: 60                 RTS
  5825                        
  5826                        ; round FAC1
  5827                        
  5828                        LAB_27BA
  5829 00:C84E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5830 00:C850: F0 FB              BEQ   LAB_27B9          ; exit if zero
  5831                        
  5832 00:C852: 06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
  5833 00:C854: 90 F7              BCC   LAB_27B9          ; exit if no overflow
  5834                        
  5835                        ; round FAC1 (no check)
  5836                        
  5837                        LAB_27C2
  5838 00:C856: 20 30 C6           JSR   LAB_2559          ; increment FAC1 mantissa
  5839 00:C859: D0 F2              BNE   LAB_27B9          ; branch if no overflow
  5840                        
  5841 00:C85B: 4C 01 C6           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
  5842                        
  5843                        ; get FAC1 sign
  5844                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5845                        
  5846                        LAB_27CA
  5847 00:C85E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5848 00:C860: F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
  5849                        
  5850                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5851                        ; no = 0 check
  5852                        
  5853                        LAB_27CE
  Sun Mar  3 2019 22:47                                                                                                    Page 94


  5854 00:C862: A5 62              LDA   FAC1_s            ; else get FAC1 sign (b7)
  5855                        
  5856                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5857                        ; no = 0 check, sign in A
  5858                        
  5859                        LAB_27D0
  5860 00:C864: 2A                 ROL                     ; move sign bit to carry
  5861 00:C865: A9 FF              LDA   #$FF              ; set byte for -ve result
  5862 00:C867: B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
  5863                        
  5864 00:C869: A9 01              LDA   #$01              ; else set byte for +ve result
  5865                        LAB_27D7
  5866 00:C86B: 60                 RTS
  5867                        
  5868                        ; perform SGN()
  5869                        
  5870                        LAB_SGN
  5871 00:C86C: 20 5E C8           JSR   LAB_27CA          ; get FAC1 sign
  5872                                                      ; return A=$FF/-ve A=$01/+ve
  5873                        ; save A as integer byte
  5874                        
  5875                        LAB_27DB
  5876 00:C86F: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5877 00:C871: 64 60              STZ   FAC1_2            ; clear FAC1 mantissa2
  5878 00:C873: A2 88              LDX   #$88              ; set exponent
  5879                        
  5880                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5881                        
  5882                        LAB_27E3
  5883 00:C875: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5884 00:C877: 49 FF              EOR   #$FF              ; complement it
  5885 00:C879: 2A                 ROL                     ; sign bit into carry
  5886                        
  5887                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5888                        
  5889                        LAB_STFA
  5890 00:C87A: 64 61              STZ   FAC1_3            ; clear FAC1 mantissa3
  5891 00:C87C: 86 5E              STX   FAC1_e            ; set FAC1 exponent
  5892 00:C87E: 64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
  5893 00:C880: 64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
  5894 00:C882: 4C A7 C5           JMP   LAB_24D0          ; do ABS and normalise FAC1
  5895                        
  5896                        ; perform ABS()
  5897                        
  5898                        LAB_ABS
  5899 00:C885: 46 62              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
  5900 00:C887: 60                 RTS
  5901                        
  5902                        ; compare FAC1 with (AY)
  5903                        ; returns A=$00 if FAC1 = (AY)
  5904                        ; returns A=$01 if FAC1 > (AY)
  5905                        ; returns A=$FF if FAC1 < (AY)
  5906                        
  5907                        LAB_27F8
  5908 00:C888: 85 25              STA   ut2_pl            ; save pointer low byte
  5909                        LAB_27FA
  5910 00:C88A: 84 26              STY   ut2_ph            ; save pointer high byte
  5911 00:C88C: A0 00              LDY   #$00              ; clear index
  5912 00:C88E: B1 25              LDA   (ut2_pl),Y        ; get exponent
  5913 00:C890: C8                 INY                     ; increment index
  5914 00:C891: AA                 TAX                     ; copy (AY) exponent to X
  5915 00:C892: F0 CA              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
  5916                                                      ; A=FF,C=1/-ve A=01,C=0/+ve
  Sun Mar  3 2019 22:47                                                                                                    Page 95


  5917                        
  5918 00:C894: B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  5919 00:C896: 45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  5920 00:C898: 30 C8              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
  5921                                                      ; A=01,C=0/+ve and return
  5922                        
  5923 00:C89A: E4 5E              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
  5924 00:C89C: D0 1A              BNE   LAB_2828          ; branch if different
  5925                        
  5926 00:C89E: B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  5927 00:C8A0: 09 80              ORA   #$80              ; normalise top bit
  5928 00:C8A2: C5 5F              CMP   FAC1_1            ; compare with FAC1 mantissa1
  5929 00:C8A4: D0 12              BNE   LAB_2828          ; branch if different
  5930                        
  5931 00:C8A6: C8                 INY                     ; increment index
  5932 00:C8A7: B1 25              LDA   (ut2_pl),Y        ; get mantissa2
  5933 00:C8A9: C5 60              CMP   FAC1_2            ; compare with FAC1 mantissa2
  5934 00:C8AB: D0 0B              BNE   LAB_2828          ; branch if different
  5935                        
  5936 00:C8AD: C8                 INY                     ; increment index
  5937 00:C8AE: A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
  5938 00:C8B0: C5 6B              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
  5939 00:C8B2: B1 25              LDA   (ut2_pl),Y        ; get mantissa3
  5940 00:C8B4: E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
  5941 00:C8B6: F0 27              BEQ   LAB_2850          ; exit if mantissa3 equal
  5942                        
  5943                        ; gets here if number <> FAC1
  5944                        
  5945                        LAB_2828
  5946 00:C8B8: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5947 00:C8BA: 90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
  5948                        
  5949 00:C8BC: 49 FF              EOR   #$FF              ; else toggle FAC1 sign
  5950                        LAB_282E
  5951 00:C8BE: 80 A4              BRA   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
  5952                        
  5953                        ; convert FAC1 floating-to-fixed
  5954                        
  5955                        LAB_2831
  5956 00:C8C0: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5957 00:C8C2: F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
  5958                        
  5959 00:C8C4: 38                 SEC                     ; set carry for subtract
  5960 00:C8C5: E9 98              SBC   #$98              ; subtract maximum integer range exponent
  5961 00:C8C7: 24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
  5962 00:C8C9: 10 09              BPL   LAB_2845          ; branch if FAC1 +ve
  5963                        
  5964                                                      ; FAC1 was -ve
  5965 00:C8CB: AA                 TAX                     ; copy subtracted exponent
  5966 00:C8CC: A9 FF              LDA   #$FF              ; overflow for -ve number
  5967 00:C8CE: 85 64              STA   FAC1_o            ; set FAC1 overflow byte
  5968 00:C8D0: 20 14 C6           JSR   LAB_253D          ; twos complement FAC1 mantissa
  5969 00:C8D3: 8A                 TXA                     ; restore subtracted exponent
  5970                        LAB_2845
  5971 00:C8D4: A2 5E              LDX   #FAC1_e           ; set index to FAC1
  5972 00:C8D6: C9 F9              CMP   #$F9              ; compare exponent result
  5973 00:C8D8: 10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
  5974                        
  5975 00:C8DA: 20 52 C6           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
  5976 00:C8DD: 84 64              STY   FAC1_o            ; clear FAC1 overflow byte
  5977                        LAB_2850
  5978 00:C8DF: 60                 RTS
  5979                        
  Sun Mar  3 2019 22:47                                                                                                    Page 96


  5980                        ; shift FAC1 A times right
  5981                        
  5982                        LAB_2851
  5983 00:C8E0: A8                 TAY                     ; copy shift count
  5984 00:C8E1: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5985 00:C8E3: 29 80              AND   #$80              ; mask sign bit only (x000 0000)
  5986 00:C8E5: 46 5F              LSR   FAC1_1            ; shift FAC1 mantissa1
  5987 00:C8E7: 05 5F              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
  5988 00:C8E9: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5989 00:C8EB: 20 69 C6           JSR   LAB_2592          ; shift FAC1 Y times right
  5990 00:C8EE: 84 64              STY   FAC1_o            ; clear FAC1 overflow byte
  5991 00:C8F0: 60                 RTS
  5992                        
  5993                        ; perform INT()
  5994                        
  5995                        LAB_INT
  5996 00:C8F1: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5997 00:C8F3: C9 98              CMP   #$98              ; compare with max int
  5998 00:C8F5: B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
  5999                        
  6000 00:C8F7: 20 C0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6001 00:C8FA: 84 6B              STY   FAC1_r            ; save FAC1 rounding byte
  6002 00:C8FC: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6003 00:C8FE: 84 62              STY   FAC1_s            ; save FAC1 sign (b7)
  6004 00:C900: 49 80              EOR   #$80              ; toggle FAC1 sign
  6005 00:C902: 2A                 ROL                     ; shift into carry
  6006 00:C903: A9 98              LDA   #$98              ; set new exponent
  6007 00:C905: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6008 00:C907: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  6009 00:C909: 85 0D              STA   Temp3             ; save for EXP() function
  6010 00:C90B: 4C A7 C5           JMP   LAB_24D0          ; do ABS and normalise FAC1
  6011                        
  6012                        ; clear FAC1 and return
  6013                        
  6014                        LAB_287F
  6015 00:C90E: 85 5F              STA   FAC1_1            ; clear FAC1 mantissa1
  6016 00:C910: 85 60              STA   FAC1_2            ; clear FAC1 mantissa2
  6017 00:C912: 85 61              STA   FAC1_3            ; clear FAC1 mantissa3
  6018 00:C914: A8                 TAY                     ; clear Y
  6019                        LAB_2886
  6020 00:C915: 60                 RTS
  6021                        
  6022                        ; get FAC1 from string
  6023                        ; this routine now handles hex and binary values from strings
  6024                        ; starting with "$" and "%" respectively
  6025                        
  6026                        LAB_2887
  6027 00:C916: 64 11              STZ   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  6028 00:C918: A2 09              LDX   #$09              ; set index
  6029                        LAB_288B
  6030 00:C91A: 74 5A              STZ   numexp,X          ; clear byte
  6031 00:C91C: CA                 DEX                     ; decrement index
  6032 00:C91D: 10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
  6033 00:C91F: 90 7E              BCC   LAB_28FE          ; branch if 1st character numeric
  6034                        
  6035                        ; get FAC1 from string .. first character wasn't numeric
  6036                        
  6037 00:C921: C9 2D              CMP   #'-'              ; else compare with "-"
  6038 00:C923: D0 04              BNE   LAB_289A          ; branch if not "-"
  6039                        
  6040 00:C925: 86 63              STX   negnum            ; set flag for -ve number (X = $FF)
  6041 00:C927: 80 04              BRA   LAB_289C          ; branch always (go scan and check for hex/bin)
  6042                        
  Sun Mar  3 2019 22:47                                                                                                    Page 97


  6043                        ; get FAC1 from string .. first character wasn't numeric or -
  6044                        
  6045                        LAB_289A
  6046 00:C929: C9 2B              CMP   #'+'              ; else compare with "+"
  6047 00:C92B: D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
  6048                        
  6049                        ; was "+" or "-" to start, so get next character
  6050                        
  6051                        LAB_289C
  6052 00:C92D: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  6053 00:C930: 90 6D              BCC   LAB_28FE          ; branch if numeric character
  6054                        
  6055                        ; code here for hex and binary numbers
  6056                        
  6057                        LAB_289D
  6058 00:C932: C9 24              CMP   #'$'              ; else compare with "$"
  6059 00:C934: D0 03              BNE   LAB_NHEX          ; branch if not "$"
  6060                        
  6061 00:C936: 4C D0 CD           JMP   LAB_CHEX          ; branch if "$"
  6062                        
  6063                        LAB_NHEX
  6064 00:C939: C9 25              CMP   #'%'              ; else compare with "%"
  6065 00:C93B: D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
  6066                        
  6067 00:C93D: 4C FE CD           JMP   LAB_CBIN          ; branch if "%"
  6068                        
  6069                        LAB_289E
  6070 00:C940: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
  6071                        LAB_28A1
  6072 00:C943: 90 5A              BCC   LAB_28FE          ; branch if numeric character
  6073                        
  6074                        ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6075                        
  6076                        LAB_28A3
  6077 00:C945: C9 2E              CMP   #'.'              ; else compare with "."
  6078 00:C947: F0 2D              BEQ   LAB_28D5          ; branch if "."
  6079                        
  6080                        ; get FAC1 from string .. character wasn't numeric, -, + or .
  6081                        
  6082 00:C949: C9 45              CMP   #'E'              ; else compare with "E"
  6083 00:C94B: D0 2F              BNE   LAB_28DB          ; branch if not "E"
  6084                        
  6085                                                      ; was "E" so evaluate exponential part
  6086 00:C94D: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  6087 00:C950: 90 17              BCC   LAB_28C7          ; branch if numeric character
  6088                        
  6089 00:C952: C9 B3              CMP   #TK_MINUS         ; else compare with token for -
  6090 00:C954: F0 0E              BEQ   LAB_28C2          ; branch if token for -
  6091                        
  6092 00:C956: C9 2D              CMP   #'-'              ; else compare with "-"
  6093 00:C958: F0 0A              BEQ   LAB_28C2          ; branch if "-"
  6094                        
  6095 00:C95A: C9 B2              CMP   #TK_PLUS          ; else compare with token for +
  6096 00:C95C: F0 08              BEQ   LAB_28C4          ; branch if token for +
  6097                        
  6098 00:C95E: C9 2B              CMP   #'+'              ; else compare with "+"
  6099 00:C960: F0 04              BEQ   LAB_28C4          ; branch if "+"
  6100 00:C962: 80 07              BRA   LAB_28C9          ; branch always
  6101                        
  6102                        LAB_28C2
  6103 00:C964: 66 5D              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
  6104                        LAB_28C4
  6105 00:C966: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  Sun Mar  3 2019 22:47                                                                                                    Page 98


  6106                        LAB_28C7
  6107 00:C969: 90 59              BCC   LAB_2925          ; branch if numeric character
  6108                        
  6109                        LAB_28C9
  6110 00:C96B: 24 5D              BIT   expneg            ; test exponent -ve flag
  6111 00:C96D: 10 0D              BPL   LAB_28DB          ; if +ve go evaluate exponent
  6112                        
  6113                                                      ; else do exponent = -exponent 
  6114 00:C96F: A9 00              LDA   #$00              ; clear result
  6115 00:C971: 38                 SEC                     ; set carry for subtract
  6116 00:C972: E5 5B              SBC   expcnt            ; subtract exponent byte
  6117 00:C974: 80 08              BRA   LAB_28DD          ; go evaluate exponent
  6118                        
  6119                        LAB_28D5
  6120 00:C976: 66 5C              ROR   numdpf            ; set decimal point flag
  6121 00:C978: 24 5C              BIT   numdpf            ; test decimal point flag
  6122 00:C97A: 50 C4              BVC   LAB_289E          ; branch if only one decimal point so far
  6123                        
  6124                                                      ; evaluate exponent
  6125                        LAB_28DB
  6126 00:C97C: A5 5B              LDA   expcnt            ; get exponent count byte
  6127                        LAB_28DD
  6128 00:C97E: 38                 SEC                     ; set carry for subtract
  6129 00:C97F: E5 5A              SBC   numexp            ; subtract numerator exponent
  6130 00:C981: 85 5B              STA   expcnt            ; save exponent count byte
  6131 00:C983: F0 12              BEQ   LAB_28F6          ; branch if no adjustment
  6132 00:C985: 10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
  6133                        
  6134                                                      ; else go do FAC1/10^(0-expcnt)
  6135                        LAB_28E6
  6136 00:C987: 20 67 C7           JSR   LAB_26B9          ; divide by 10
  6137 00:C98A: E6 5B              INC   expcnt            ; increment exponent count byte
  6138 00:C98C: D0 F9              BNE   LAB_28E6          ; loop until all done
  6139 00:C98E: 80 07              BRA   LAB_28F6          ; branch always
  6140                        
  6141                        LAB_28EF
  6142 00:C990: 20 4E C7           JSR   LAB_269E          ; multiply by 10
  6143 00:C993: C6 5B              DEC   expcnt            ; decrement exponent count byte
  6144 00:C995: D0 F9              BNE   LAB_28EF          ; loop until all done
  6145                        
  6146                        LAB_28F6
  6147 00:C997: A5 63              LDA   negnum            ; get -ve flag
  6148 00:C999: 30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
  6149 00:C99B: 60                 RTS
  6150                        
  6151                        ; do - FAC1 and return
  6152                        
  6153                        LAB_28FB
  6154 00:C99C: 4C 5D CB           JMP   LAB_GTHAN         ; do - FAC1 and return
  6155                        
  6156                        ; do unsigned FAC1*10+number
  6157                        
  6158                        LAB_28FE
  6159 00:C99F: 48                 PHA                     ; save character
  6160 00:C9A0: 24 5C              BIT   numdpf            ; test decimal point flag
  6161 00:C9A2: 10 02              BPL   LAB_2905          ; skip exponent increment if not set
  6162                        
  6163 00:C9A4: E6 5A              INC   numexp            ; else increment number exponent
  6164                        LAB_2905
  6165 00:C9A6: 20 4E C7           JSR   LAB_269E          ; multiply FAC1 by 10
  6166 00:C9A9: 68                 PLA                     ; restore character
  6167 00:C9AA: 29 0F              AND   #$0F              ; convert to binary
  6168 00:C9AC: 20 B1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  Sun Mar  3 2019 22:47                                                                                                    Page 99


  6169 00:C9AF: 80 8F              BRA   LAB_289E          ; go do next character
  6170                        
  6171                        ; evaluate new ASCII digit
  6172                        
  6173                        LAB_2912
  6174 00:C9B1: 48                 PHA                     ; save digit
  6175 00:C9B2: 20 3F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6176 00:C9B5: 68                 PLA                     ; restore digit
  6177 00:C9B6: 20 6F C8           JSR   LAB_27DB          ; save A as integer byte
  6178 00:C9B9: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  6179 00:C9BB: 45 62              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
  6180 00:C9BD: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6181 00:C9BF: A6 5E              LDX   FAC1_e            ; get FAC1 exponent
  6182 00:C9C1: 4C 3D C5           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
  6183                        
  6184                        ; evaluate next character of exponential part of number
  6185                        
  6186                        LAB_2925
  6187 00:C9C4: A5 5B              LDA   expcnt            ; get exponent count byte
  6188 00:C9C6: C9 0A              CMP   #$0A              ; compare with 10 decimal
  6189 00:C9C8: 90 09              BCC   LAB_2934          ; branch if less
  6190                        
  6191 00:C9CA: A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
  6192 00:C9CC: 24 5D              BIT   expneg            ; test exponent -ve flag
  6193 00:C9CE: 30 0C              BMI   LAB_2942          ; branch if -ve
  6194                        
  6195 00:C9D0: 4C 3B C6           JMP   LAB_2564          ; else do overflow error
  6196                        
  6197                        LAB_2934
  6198 00:C9D3: 0A                 ASL                     ; * 2
  6199 00:C9D4: 0A                 ASL                     ; * 4
  6200 00:C9D5: 65 5B              ADC   expcnt            ; * 5
  6201 00:C9D7: 0A                 ASL                     ; * 10
  6202 00:C9D8: 72 6E              ADC   (Bpntrl)          ; add character (will be $30 too much!)
  6203 00:C9DA: E9 2F              SBC   #'0'-1            ; convert character to binary
  6204                        LAB_2942
  6205 00:C9DC: 85 5B              STA   expcnt            ; save exponent count byte
  6206 00:C9DE: 80 86              BRA   LAB_28C4          ; go get next character
  6207                        
  6208                        ; print " in line [LINE #]"
  6209                        
  6210                        LAB_2953
  6211 00:C9E0: A9 64              LDA   #<LAB_LMSG        ; point to " in line " message low byte
  6212 00:C9E2: A0 D6              LDY   #>LAB_LMSG        ; point to " in line " message high byte
  6213 00:C9E4: 20 6F B8           JSR   LAB_18C3          ; print null terminated string from memory
  6214                        
  6215                                                      ; print Basic line #
  6216 00:C9E7: A5 3A              LDA   Clineh            ; get current line high byte
  6217 00:C9E9: A6 39              LDX   Clinel            ; get current line low byte
  6218                        
  6219                        ; print XA as unsigned integer
  6220                        
  6221                        LAB_295E
  6222 00:C9EB: 85 5F              STA   FAC1_1            ; save low byte as FAC1 mantissa1
  6223 00:C9ED: 86 60              STX   FAC1_2            ; save high byte as FAC1 mantissa2
  6224 00:C9EF: A2 90              LDX   #$90              ; set exponent to 16d bits
  6225 00:C9F1: 38                 SEC                     ; set integer is +ve flag
  6226 00:C9F2: 20 7A C8           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
  6227 00:C9F5: A0 00              LDY   #$00              ; clear index
  6228 00:C9F7: 98                 TYA                     ; clear A
  6229 00:C9F8: 20 0B CA           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
  6230 00:C9FB: 4C 6F B8           JMP   LAB_18C3          ; print null terminated string from memory and return
  6231                        
  Sun Mar  3 2019 22:47                                                                                                    Page 100


  6232                        ; convert FAC1 to ASCII string result in (AY)
  6233                        ; not any more, moved scratchpad to page 0
  6234                        
  6235                        LAB_296E
  6236 00:C9FE: A0 01              LDY   #$01              ; set index = 1
  6237 00:CA00: A9 20              LDA   #$20              ; character = " " (assume +ve)
  6238 00:CA02: 24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
  6239 00:CA04: 10 02              BPL   LAB_2978          ; branch if +ve
  6240                        
  6241 00:CA06: A9 2D              LDA   #$2D              ; else character = "-"
  6242                        LAB_2978
  6243 00:CA08: 99 74 00           STA   Decss,Y           ; save leading character (" " or "-")
  6244                        LAB_297B
  6245 00:CA0B: 85 62              STA   FAC1_s            ; clear FAC1 sign (b7)
  6246 00:CA0D: 84 6C              STY   Sendl             ; save index
  6247 00:CA0F: C8                 INY                     ; increment index
  6248 00:CA10: A6 5E              LDX   FAC1_e            ; get FAC1 exponent
  6249 00:CA12: D0 05              BNE   LAB_2989          ; branch if FAC1<>0
  6250                        
  6251                                                      ; exponent was $00 so FAC1 is 0
  6252 00:CA14: A9 30              LDA   #'0'              ; set character = "0"
  6253 00:CA16: 4C 17 CB           JMP   LAB_2A89          ; save last character, [EOT] and exit
  6254                        
  6255                                                      ; FAC1 is some non zero value
  6256                        LAB_2989
  6257 00:CA19: A9 00              LDA   #$00              ; clear (number exponent count)
  6258 00:CA1B: E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
  6259                        
  6260 00:CA1D: B0 09              BCS   LAB_299A          ; branch if FAC1=>1
  6261                        
  6262                                                      ; FAC1<1
  6263 00:CA1F: A9 1F              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
  6264 00:CA21: A0 D0              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
  6265 00:CA23: 20 B1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6266 00:CA26: A9 FA              LDA   #$FA              ; set number exponent count (-6)
  6267                        LAB_299A
  6268 00:CA28: 85 5A              STA   numexp            ; save number exponent count
  6269                        LAB_299C
  6270 00:CA2A: A9 1B              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
  6271 00:CA2C: A0 D0              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
  6272 00:CA2E: 20 88 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6273 00:CA31: F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
  6274                        
  6275 00:CA33: 10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
  6276                        
  6277                                                      ; FAC1 < (AY)
  6278                        LAB_29A7
  6279 00:CA35: A9 17              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
  6280 00:CA37: A0 D0              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
  6281 00:CA39: 20 88 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6282 00:CA3C: F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
  6283 00:CA3E: 10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
  6284                        
  6285                                                      ; FAC1 <= (AY)
  6286                        LAB_29B2
  6287 00:CA40: 20 4E C7           JSR   LAB_269E          ; multiply by 10
  6288 00:CA43: C6 5A              DEC   numexp            ; decrement number exponent count
  6289 00:CA45: 80 EE              BRA   LAB_29A7          ; go test again (branch always)
  6290                        
  6291                        LAB_29B9
  6292 00:CA47: 20 67 C7           JSR   LAB_26B9          ; divide by 10
  6293 00:CA4A: E6 5A              INC   numexp            ; increment number exponent count
  6294 00:CA4C: 80 DC              BRA   LAB_299C          ; go test again (branch always)
  Sun Mar  3 2019 22:47                                                                                                    Page 101


  6295                        
  6296                        ; now we have just the digits to do
  6297                        
  6298                        LAB_29C0
  6299 00:CA4E: 20 36 C5           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
  6300                        LAB_29C3
  6301 00:CA51: 20 C0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6302 00:CA54: A2 01              LDX   #$01              ; set default digits before dp = 1
  6303 00:CA56: A5 5A              LDA   numexp            ; get number exponent count
  6304 00:CA58: 18                 CLC                     ; clear carry for add
  6305 00:CA59: 69 07              ADC   #$07              ; up to 6 digits before point
  6306 00:CA5B: 30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
  6307                        
  6308 00:CA5D: C9 08              CMP   #$08              ; A>=8 if n>=1E6
  6309 00:CA5F: B0 06              BCS   LAB_29D9          ; branch if >= $08
  6310                        
  6311                                                      ; carry is clear
  6312 00:CA61: 69 FF              ADC   #$FF              ; take 1 from digit count
  6313 00:CA63: AA                 TAX                     ; copy to A
  6314 00:CA64: A9 02              LDA   #$02              ;.set exponent adjust
  6315                        LAB_29D8
  6316 00:CA66: 38                 SEC                     ; set carry for subtract
  6317                        LAB_29D9
  6318 00:CA67: E9 02              SBC   #$02              ; -2
  6319 00:CA69: 85 5B              STA   expcnt            ; save exponent adjust
  6320 00:CA6B: 86 5A              STX   numexp            ; save digits before dp count
  6321 00:CA6D: 8A                 TXA                     ; copy to A
  6322 00:CA6E: F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
  6323 00:CA70: 10 13              BPL   LAB_29F7          ; branch if digits before dp
  6324                        
  6325                        LAB_29E4
  6326 00:CA72: A4 6C              LDY   Sendl             ; get output string index
  6327 00:CA74: A9 2E              LDA   #$2E              ; character "."
  6328 00:CA76: C8                 INY                     ; increment index
  6329 00:CA77: 99 74 00           STA   Decss,Y           ; save to output string
  6330 00:CA7A: 8A                 TXA                     ; 
  6331 00:CA7B: F0 06              BEQ   LAB_29F5          ; 
  6332                        
  6333 00:CA7D: A9 30              LDA   #'0'              ; character "0"
  6334 00:CA7F: C8                 INY                     ; increment index
  6335 00:CA80: 99 74 00           STA   Decss,Y           ; save to output string
  6336                        LAB_29F5
  6337 00:CA83: 84 6C              STY   Sendl             ; save output string index
  6338                        LAB_29F7
  6339 00:CA85: A0 00              LDY   #$00              ; clear index (point to 100,000)
  6340 00:CA87: A2 80              LDX   #$80              ; 
  6341                        LAB_29FB
  6342 00:CA89: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  6343 00:CA8B: 18                 CLC                     ; clear carry for add
  6344 00:CA8C: 79 95 D0           ADC   LAB_2A9C,Y        ; add -ve LSB
  6345 00:CA8F: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  6346 00:CA91: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  6347 00:CA93: 79 94 D0           ADC   LAB_2A9B,Y        ; add -ve NMSB
  6348 00:CA96: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  6349 00:CA98: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  6350 00:CA9A: 79 93 D0           ADC   LAB_2A9A,Y        ; add -ve MSB
  6351 00:CA9D: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  6352 00:CA9F: E8                 INX                     ; 
  6353 00:CAA0: B0 04              BCS   LAB_2A18          ; 
  6354                        
  6355 00:CAA2: 10 E5              BPL   LAB_29FB          ; not -ve so try again
  6356                        
  6357 00:CAA4: 30 02              BMI   LAB_2A1A          ; 
  Sun Mar  3 2019 22:47                                                                                                    Page 102


  6358                        
  6359                        LAB_2A18
  6360 00:CAA6: 30 E1              BMI   LAB_29FB          ; 
  6361                        
  6362                        LAB_2A1A
  6363 00:CAA8: 8A                 TXA                     ; 
  6364 00:CAA9: 90 04              BCC   LAB_2A21          ; 
  6365                        
  6366 00:CAAB: 49 FF              EOR   #$FF              ; 
  6367 00:CAAD: 69 0A              ADC   #$0A              ; 
  6368                        LAB_2A21
  6369 00:CAAF: 69 2F              ADC   #'0'-1            ; add "0"-1 to result
  6370 00:CAB1: C8                 INY                     ; increment index ..
  6371 00:CAB2: C8                 INY                     ; .. to next less ..
  6372 00:CAB3: C8                 INY                     ; .. power of ten
  6373 00:CAB4: 84 47              STY   Cvaral            ; save as current var address low byte
  6374 00:CAB6: A4 6C              LDY   Sendl             ; get output string index
  6375 00:CAB8: C8                 INY                     ; increment output string index
  6376 00:CAB9: AA                 TAX                     ; copy character to X
  6377 00:CABA: 29 7F              AND   #$7F              ; mask out top bit
  6378 00:CABC: 99 74 00           STA   Decss,Y           ; save to output string
  6379 00:CABF: C6 5A              DEC   numexp            ; decrement # of characters before the dp
  6380 00:CAC1: D0 06              BNE   LAB_2A3B          ; branch if still characters to do
  6381                        
  6382                                                      ; else output the point
  6383 00:CAC3: A9 2E              LDA   #$2E              ; character "."
  6384 00:CAC5: C8                 INY                     ; increment output string index
  6385 00:CAC6: 99 74 00           STA   Decss,Y           ; save to output string
  6386                        LAB_2A3B
  6387 00:CAC9: 84 6C              STY   Sendl             ; save output string index
  6388 00:CACB: A4 47              LDY   Cvaral            ; get current var address low byte
  6389 00:CACD: 8A                 TXA                     ; get character back
  6390 00:CACE: 49 FF              EOR   #$FF              ; 
  6391 00:CAD0: 29 80              AND   #$80              ; 
  6392 00:CAD2: AA                 TAX                     ; 
  6393 00:CAD3: C0 12              CPY   #$12              ; compare index with max
  6394 00:CAD5: D0 B2              BNE   LAB_29FB          ; loop if not max
  6395                        
  6396                                                      ; now remove trailing zeroes
  6397 00:CAD7: A4 6C              LDY   Sendl             ; get output string index
  6398                        LAB_2A4B
  6399 00:CAD9: B9 74 00           LDA   Decss,Y           ; get character from output string
  6400 00:CADC: 88                 DEY                     ; decrement output string index
  6401 00:CADD: C9 30              CMP   #'0'              ; compare with "0"
  6402 00:CADF: F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
  6403                        
  6404 00:CAE1: C9 2E              CMP   #'.'              ; compare with "."
  6405 00:CAE3: F0 01              BEQ   LAB_2A58          ; branch if was dp
  6406                        
  6407                                                      ; restore last character
  6408 00:CAE5: C8                 INY                     ; increment output string index
  6409                        LAB_2A58
  6410 00:CAE6: A9 2B              LDA   #$2B              ; character "+"
  6411 00:CAE8: A6 5B              LDX   expcnt            ; get exponent count
  6412 00:CAEA: F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
  6413                        
  6414                                                      ; exponent isn't zero so write exponent
  6415 00:CAEC: 10 08              BPL   LAB_2A68          ; branch if exponent count +ve
  6416                        
  6417 00:CAEE: A9 00              LDA   #$00              ; clear A
  6418 00:CAF0: 38                 SEC                     ; set carry for subtract
  6419 00:CAF1: E5 5B              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
  6420 00:CAF3: AA                 TAX                     ; copy exponent count to X
  Sun Mar  3 2019 22:47                                                                                                    Page 103


  6421 00:CAF4: A9 2D              LDA   #'-'              ; character "-"
  6422                        LAB_2A68
  6423 00:CAF6: 99 76 00           STA   Decss+2,Y         ; save to output string
  6424 00:CAF9: A9 45              LDA   #$45              ; character "E"
  6425 00:CAFB: 99 75 00           STA   Decss+1,Y         ; save exponent sign to output string
  6426 00:CAFE: 8A                 TXA                     ; get exponent count back
  6427 00:CAFF: A2 2F              LDX   #'0'-1            ; one less than "0" character
  6428 00:CB01: 38                 SEC                     ; set carry for subtract
  6429                        LAB_2A74
  6430 00:CB02: E8                 INX                     ; increment 10's character
  6431 00:CB03: E9 0A              SBC   #$0A              ; subtract 10 from exponent count
  6432 00:CB05: B0 FB              BCS   LAB_2A74          ; loop while still >= 0
  6433                        
  6434 00:CB07: 69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
  6435 00:CB09: 99 78 00           STA   Decss+4,Y         ; save to output string
  6436 00:CB0C: 8A                 TXA                     ; copy 10's character
  6437 00:CB0D: 99 77 00           STA   Decss+3,Y         ; save to output string
  6438 00:CB10: A9 00              LDA   #$00              ; set null terminator
  6439 00:CB12: 99 79 00           STA   Decss+5,Y         ; save to output string
  6440 00:CB15: 80 08              BRA   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
  6441                        
  6442                                                      ; save last character, [EOT] and exit
  6443                        LAB_2A89
  6444 00:CB17: 99 74 00           STA   Decss,Y           ; save last character to output string
  6445                        
  6446                                                      ; set null terminator and exit
  6447                        LAB_2A8C
  6448 00:CB1A: A9 00              LDA   #$00              ; set null terminator
  6449 00:CB1C: 99 75 00           STA   Decss+1,Y         ; save after last character
  6450                        
  6451                                                      ; set string pointer (AY) and exit
  6452                        LAB_2A91
  6453 00:CB1F: A9 75              LDA   #<Decssp1         ; set result string low pointer
  6454 00:CB21: A0 00              LDY   #>Decssp1         ; set result string high pointer
  6455 00:CB23: 60                 RTS
  6456                        
  6457                        ; perform power function
  6458                        
  6459                        LAB_POWER
  6460 00:CB24: F0 42              BEQ   LAB_EXP           ; go do  EXP()
  6461                        
  6462 00:CB26: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  6463 00:CB28: D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
  6464                        
  6465 00:CB2A: 4C CA C5           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
  6466                        
  6467                        LAB_2ABF
  6468 00:CB2D: A2 4E              LDX   #<func_l          ; set destination pointer low byte
  6469 00:CB2F: A0 00              LDY   #>func_l          ; set destination pointer high byte
  6470 00:CB31: 20 1C C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6471 00:CB34: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  6472 00:CB36: 10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
  6473                        
  6474                                                      ; else FAC2 is -ve and can only be raised to an
  6475                                                      ; integer power which gives an x +j0 result
  6476 00:CB38: 20 F1 C8           JSR   LAB_INT           ; perform INT
  6477 00:CB3B: A9 4E              LDA   #<func_l          ; set source pointer low byte
  6478 00:CB3D: A0 00              LDY   #>func_l          ; set source pointer high byte
  6479 00:CB3F: 20 88 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6480 00:CB42: D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
  6481                                                      ; this will leave FAC1 -ve and cause a Function Call
  6482                                                      ; error when LOG() is called
  6483                        
  Sun Mar  3 2019 22:47                                                                                                    Page 104


  6484 00:CB44: 98                 TYA                     ; clear sign b7
  6485 00:CB45: A4 0D              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
  6486                                                      ; for possible later negation, b0
  6487                        LAB_2AD9
  6488 00:CB47: 20 41 C5           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
  6489 00:CB4A: 98                 TYA                     ; copy sign back ..
  6490 00:CB4B: 48                 PHA                     ; .. and save it
  6491 00:CB4C: 20 73 C6           JSR   LAB_LOG           ; do LOG(n)
  6492 00:CB4F: A9 4E              LDA   #<garb_l          ; set pointer low byte
  6493 00:CB51: A0 00              LDY   #>garb_l          ; set pointer high byte
  6494 00:CB53: 20 B1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
  6495 00:CB56: 20 68 CB           JSR   LAB_EXP           ; go do EXP(n)
  6496 00:CB59: 68                 PLA                     ; pull sign from stack
  6497 00:CB5A: 4A                 LSR                     ; b0 is to be tested, shift to Cb
  6498 00:CB5B: 90 0A              BCC   LAB_2AF9          ; if no bit then exit
  6499                        
  6500                                                      ; Perform negation
  6501                        ; do - FAC1
  6502                        
  6503                        LAB_GTHAN
  6504 00:CB5D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6505 00:CB5F: F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
  6506                        
  6507 00:CB61: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6508 00:CB63: 49 FF              EOR   #$FF              ; complement it
  6509 00:CB65: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  6510                        LAB_2AF9
  6511 00:CB67: 60                 RTS
  6512                        
  6513                        ; perform EXP()   (x^e)
  6514                        
  6515                        LAB_EXP
  6516 00:CB68: A9 23              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
  6517 00:CB6A: A0 D0              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
  6518 00:CB6C: 20 B1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6519 00:CB6F: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  6520 00:CB71: 69 50              ADC   #$50              ; +$50/$100
  6521 00:CB73: 90 03              BCC   LAB_2B2B          ; skip rounding if no carry
  6522                        
  6523 00:CB75: 20 56 C8           JSR   LAB_27C2          ; round FAC1 (no check)
  6524                        LAB_2B2B
  6525 00:CB78: 85 55              STA   FAC2_r            ; save FAC2 rounding byte
  6526 00:CB7A: 20 42 C8           JSR   LAB_27AE          ; copy FAC1 to FAC2
  6527 00:CB7D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6528 00:CB7F: C9 88              CMP   #$88              ; compare with EXP limit (256d)
  6529 00:CB81: 90 03              BCC   LAB_2B39          ; branch if less
  6530                        
  6531                        LAB_2B36
  6532 00:CB83: 20 45 C7           JSR   LAB_2690          ; handle overflow and underflow
  6533                        LAB_2B39
  6534 00:CB86: 20 F1 C8           JSR   LAB_INT           ; perform INT
  6535 00:CB89: A5 0D              LDA   Temp3             ; get mantissa 3 from INT() function
  6536 00:CB8B: 18                 CLC                     ; clear carry for add
  6537 00:CB8C: 69 81              ADC   #$81              ; normalise +1
  6538 00:CB8E: F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
  6539                        
  6540 00:CB90: 38                 SEC                     ; set carry for subtract
  6541 00:CB91: E9 01              SBC   #$01              ; now correct for exponent
  6542 00:CB93: 48                 PHA                     ; save FAC2 exponent
  6543                        
  6544                                                      ; swap FAC1 and FAC2
  6545 00:CB94: A2 04              LDX   #$04              ; 4 bytes to do
  6546                        LAB_2B49
  Sun Mar  3 2019 22:47                                                                                                    Page 105


  6547 00:CB96: B5 65              LDA   FAC2_e,X          ; get FAC2,X
  6548 00:CB98: B4 5E              LDY   FAC1_e,X          ; get FAC1,X
  6549 00:CB9A: 95 5E              STA   FAC1_e,X          ; save FAC1,X
  6550 00:CB9C: 94 65              STY   FAC2_e,X          ; save FAC2,X
  6551 00:CB9E: CA                 DEX                     ; decrement count/index
  6552 00:CB9F: 10 F5              BPL   LAB_2B49          ; loop if not all done
  6553                        
  6554 00:CBA1: A5 55              LDA   FAC2_r            ; get FAC2 rounding byte
  6555 00:CBA3: 85 6B              STA   FAC1_r            ; save as FAC1 rounding byte
  6556 00:CBA5: 20 23 C5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6557 00:CBA8: 20 5D CB           JSR   LAB_GTHAN         ; do - FAC1
  6558 00:CBAB: A9 27              LDA   #<LAB_2AFE        ; set counter pointer low byte
  6559 00:CBAD: A0 D0              LDY   #>LAB_2AFE        ; set counter pointer high byte
  6560 00:CBAF: 20 CE CB           JSR   LAB_2B84          ; go do series evaluation
  6561 00:CBB2: 64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  6562 00:CBB4: 68                 PLA                     ;.get saved FAC2 exponent
  6563 00:CBB5: 4C 29 C7           JMP   LAB_2675          ; test and adjust accumulators and return
  6564                        
  6565                        ; ^2 then series evaluation
  6566                        
  6567                        LAB_2B6E
  6568 00:CBB8: 85 6C              STA   Cptrl             ; save count pointer low byte
  6569 00:CBBA: 84 6D              STY   Cptrh             ; save count pointer high byte
  6570 00:CBBC: 20 12 C8           JSR   LAB_276E          ; pack FAC1 into Adatal
  6571 00:CBBF: A9 56              LDA   #<Adatal          ; set pointer low byte (Y already $00)
  6572 00:CBC1: 20 B1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6573 00:CBC4: 20 D2 CB           JSR   LAB_2B88          ; go do series evaluation
  6574 00:CBC7: A9 56              LDA   #<Adatal          ; pointer to original # low byte
  6575 00:CBC9: A0 00              LDY   #>Adatal          ; pointer to original # high byte
  6576 00:CBCB: 4C B1 C6           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
  6577                        
  6578                        ; series evaluation
  6579                        
  6580                        LAB_2B84
  6581 00:CBCE: 85 6C              STA   Cptrl             ; save count pointer low byte
  6582 00:CBD0: 84 6D              STY   Cptrh             ; save count pointer high byte
  6583                        LAB_2B88
  6584 00:CBD2: A2 5A              LDX   #<numexp          ; set pointer low byte
  6585 00:CBD4: 20 14 C8           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
  6586 00:CBD7: B1 6C              LDA   (Cptrl),Y         ; get constants count
  6587 00:CBD9: 85 63              STA   numcon            ; save constants count
  6588 00:CBDB: A4 6C              LDY   Cptrl             ; get count pointer low byte
  6589 00:CBDD: C8                 INY                     ; increment it (now constants pointer)
  6590 00:CBDE: 98                 TYA                     ; copy it
  6591 00:CBDF: D0 02              BNE   LAB_2B97          ; skip next if no overflow
  6592                        
  6593 00:CBE1: E6 6D              INC   Cptrh             ; else increment high byte
  6594                        LAB_2B97
  6595 00:CBE3: 85 6C              STA   Cptrl             ; save low byte
  6596 00:CBE5: A4 6D              LDY   Cptrh             ; get high byte
  6597                        LAB_2B9B
  6598 00:CBE7: 20 B1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6599 00:CBEA: A5 6C              LDA   Cptrl             ; get constants pointer low byte
  6600 00:CBEC: A4 6D              LDY   Cptrh             ; get constants pointer high byte
  6601 00:CBEE: 18                 CLC                     ; clear carry for add
  6602 00:CBEF: 69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
  6603 00:CBF1: 90 01              BCC   LAB_2BA8          ; skip next if no overflow
  6604                        
  6605 00:CBF3: C8                 INY                     ; increment high byte
  6606                        LAB_2BA8
  6607 00:CBF4: 85 6C              STA   Cptrl             ; save pointer low byte
  6608 00:CBF6: 84 6D              STY   Cptrh             ; save pointer high byte
  6609 00:CBF8: 20 3A C5           JSR   LAB_246C          ; add (AY) to FAC1
  Sun Mar  3 2019 22:47                                                                                                    Page 106


  6610 00:CBFB: A9 5A              LDA   #<numexp          ; set pointer low byte to partial @ numexp
  6611 00:CBFD: A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
  6612 00:CBFF: C6 63              DEC   numcon            ; decrement constants count
  6613 00:CC01: D0 E4              BNE   LAB_2B9B          ; loop until all done
  6614 00:CC03: 60                 RTS
  6615                        
  6616                        ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6617                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6618                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
  6619                        
  6620                        ; Entropy = 7.997442 bits per byte
  6621                        ; Optimum compression would reduce these 65536 bytes by 0 percent
  6622                        
  6623                        ; Chi square distribution for 65536 samples is 232.01, and
  6624                        ; randomly would exceed this value 75.00 percent of the time
  6625                        
  6626                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6627                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6628                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6629                        
  6630                        LAB_RND
  6631 00:CC04: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6632 00:CC06: F0 07              BEQ   NextPRN           ; do next random # if zero
  6633                        
  6634                                                      ; else get seed into random number store
  6635 00:CC08: A2 70              LDX   #Rbyte4           ; set PRNG pointer low byte
  6636 00:CC0A: A0 00              LDY   #$00              ; set PRNG pointer high byte
  6637 00:CC0C: 20 1C C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6638                        NextPRN
  6639 00:CC0F: A2 AF              LDX   #$AF              ; set EOR byte
  6640 00:CC11: A0 13              LDY   #$13              ; do this nineteen times
  6641                        LoopPRN
  6642 00:CC13: 06 71              ASL   Rbyte1            ; shift PRNG most significant byte
  6643 00:CC15: 26 72              ROL   Rbyte2            ; shift PRNG middle byte
  6644 00:CC17: 26 73              ROL   Rbyte3            ; shift PRNG least significant byte
  6645 00:CC19: 26 70              ROL   Rbyte4            ; shift PRNG extra byte
  6646 00:CC1B: 90 05              BCC   Ninc1             ; branch if bit 32 clear
  6647                        
  6648 00:CC1D: 8A                 TXA                     ; set EOR byte
  6649 00:CC1E: 45 71              EOR   Rbyte1            ; EOR PRNG extra byte
  6650 00:CC20: 85 71              STA   Rbyte1            ; save new PRNG extra byte
  6651                        Ninc1
  6652 00:CC22: 88                 DEY                     ; decrement loop count
  6653 00:CC23: D0 EE              BNE   LoopPRN           ; loop if not all done
  6654                        
  6655 00:CC25: A2 02              LDX   #$02              ; three bytes to copy
  6656                        CopyPRNG
  6657 00:CC27: B5 71              LDA   Rbyte1,X          ; get PRNG byte
  6658 00:CC29: 95 5F              STA   FAC1_1,X          ; save FAC1 byte
  6659 00:CC2B: CA                 DEX
  6660 00:CC2C: 10 F9              BPL   CopyPRNG          ; loop if not complete
  6661                        
  6662 00:CC2E: A9 80              LDA   #$80              ; set the exponent
  6663 00:CC30: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6664                        
  6665 00:CC32: 0A                 ASL                     ; clear A
  6666 00:CC33: 85 62              STA   FAC1_s            ; save FAC1 sign
  6667                        
  6668 00:CC35: 4C AC C5           JMP   LAB_24D5          ; normalise FAC1 and return
  6669                        
  6670                        ; perform COS()
  6671                        
  6672                        LAB_COS
  Sun Mar  3 2019 22:47                                                                                                    Page 107


  6673 00:CC38: A9 44              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  6674 00:CC3A: A0 D0              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  6675 00:CC3C: 20 3A C5           JSR   LAB_246C          ; add (AY) to FAC1
  6676                        
  6677                        ; perform SIN()
  6678                        
  6679                        LAB_SIN
  6680 00:CC3F: 20 3F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6681 00:CC42: A9 59              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  6682 00:CC44: A0 D0              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  6683 00:CC46: A6 69              LDX   FAC2_s            ; get FAC2 sign (b7)
  6684 00:CC48: 20 70 C7           JSR   LAB_26C2          ; divide by (AY) (X=sign)
  6685 00:CC4B: 20 3F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6686 00:CC4E: 20 F1 C8           JSR   LAB_INT           ; perform INT
  6687 00:CC51: 64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  6688 00:CC53: 20 23 C5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6689 00:CC56: A9 8B              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  6690 00:CC58: A0 D0              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  6691 00:CC5A: 20 20 C5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  6692 00:CC5D: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6693 00:CC5F: 48                 PHA                     ; save FAC1 sign
  6694 00:CC60: 10 0D              BPL   LAB_2C35          ; branch if +ve
  6695                        
  6696                                                      ; FAC1 sign was -ve
  6697 00:CC62: 20 36 C5           JSR   LAB_244E          ; add 0.5 to FAC1
  6698 00:CC65: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6699 00:CC67: 30 09              BMI   LAB_2C38          ; branch if -ve
  6700                        
  6701 00:CC69: A5 15              LDA   Cflag             ; get comparison evaluation flag
  6702 00:CC6B: 49 FF              EOR   #$FF              ; toggle flag
  6703 00:CC6D: 85 15              STA   Cflag             ; save comparison evaluation flag
  6704                        LAB_2C35
  6705 00:CC6F: 20 5D CB           JSR   LAB_GTHAN         ; do - FAC1
  6706                        LAB_2C38
  6707 00:CC72: A9 8B              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  6708 00:CC74: A0 D0              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  6709 00:CC76: 20 3A C5           JSR   LAB_246C          ; add (AY) to FAC1
  6710 00:CC79: 68                 PLA                     ; restore FAC1 sign
  6711 00:CC7A: 10 03              BPL   LAB_2C45          ; branch if was +ve
  6712                        
  6713                                                      ; else correct FAC1
  6714 00:CC7C: 20 5D CB           JSR   LAB_GTHAN         ; do - FAC1
  6715                        LAB_2C45
  6716 00:CC7F: A9 48              LDA   #<LAB_2C84        ; set pointer low byte to counter
  6717 00:CC81: A0 D0              LDY   #>LAB_2C84        ; set pointer high byte to counter
  6718 00:CC83: 4C B8 CB           JMP   LAB_2B6E          ; ^2 then series evaluation and return
  6719                        
  6720                        ; perform TAN()
  6721                        
  6722                        LAB_TAN
  6723 00:CC86: 20 12 C8           JSR   LAB_276E          ; pack FAC1 into Adatal
  6724 00:CC89: 64 15              STZ   Cflag             ; clear comparison evaluation flag
  6725 00:CC8B: 20 3F CC           JSR   LAB_SIN           ; go do SIN(n)
  6726 00:CC8E: A2 4E              LDX   #<func_l          ; set sin(n) pointer low byte
  6727 00:CC90: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  6728 00:CC92: 20 1C C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6729 00:CC95: A9 56              LDA   #<Adatal          ; set n pointer low addr
  6730 00:CC97: A0 00              LDY   #>Adatal          ; set n pointer high addr
  6731 00:CC99: 20 F2 C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  6732 00:CC9C: 64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
  6733 00:CC9E: A5 15              LDA   Cflag             ; get comparison evaluation flag
  6734 00:CCA0: 20 AA CC           JSR   LAB_2C74          ; save flag and go do series evaluation
  6735                        
  Sun Mar  3 2019 22:47                                                                                                    Page 108


  6736 00:CCA3: A9 4E              LDA   #<func_l          ; set sin(n) pointer low byte
  6737 00:CCA5: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  6738 00:CCA7: 4C 77 C7           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
  6739                        
  6740                        LAB_2C74
  6741 00:CCAA: 48                 PHA                     ; save comparison evaluation flag
  6742 00:CCAB: 80 C2              BRA   LAB_2C35          ; go do series evaluation
  6743                        
  6744                        ; perform USR()
  6745                        
  6746                        LAB_USR
  6747 00:CCAD: 20 03 00           JSR   Usrjmp            ; call user code
  6748 00:CCB0: 4C 86 BB           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  6749                        
  6750                        ; perform ATN()
  6751                        
  6752                        LAB_ATN
  6753 00:CCB3: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6754 00:CCB5: 48                 PHA                     ; save sign
  6755 00:CCB6: 10 03              BPL   LAB_2CA1          ; branch if +ve
  6756                        
  6757 00:CCB8: 20 5D CB           JSR   LAB_GTHAN         ; else do - FAC1
  6758                        LAB_2CA1
  6759 00:CCBB: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6760 00:CCBD: 48                 PHA                     ; push exponent
  6761 00:CCBE: C9 81              CMP   #$81              ; compare with 1
  6762 00:CCC0: 90 07              BCC   LAB_2CAF          ; branch if FAC1<1
  6763                        
  6764 00:CCC2: A9 7E              LDA   #<LAB_259C        ; set 1 pointer low byte
  6765 00:CCC4: A0 D0              LDY   #>LAB_259C        ; set 1 pointer high byte
  6766 00:CCC6: 20 77 C7           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
  6767                        LAB_2CAF
  6768 00:CCC9: A9 5D              LDA   #<LAB_2CC9        ; set pointer low byte to counter
  6769 00:CCCB: A0 D0              LDY   #>LAB_2CC9        ; set pointer high byte to counter
  6770 00:CCCD: 20 B8 CB           JSR   LAB_2B6E          ; ^2 then series evaluation
  6771 00:CCD0: 68                 PLA                     ; restore old FAC1 exponent
  6772 00:CCD1: C9 81              CMP   #$81              ; compare with 1
  6773 00:CCD3: 90 07              BCC   LAB_2CC2          ; branch if FAC1<1
  6774                        
  6775 00:CCD5: A9 44              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  6776 00:CCD7: A0 D0              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  6777 00:CCD9: 20 20 C5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  6778                        LAB_2CC2
  6779 00:CCDC: 68                 PLA                     ; restore FAC1 sign
  6780 00:CCDD: 10 16              BPL   LAB_2D04          ; exit if was +ve
  6781                        
  6782 00:CCDF: 4C 5D CB           JMP   LAB_GTHAN         ; else do - FAC1 and return
  6783                        
  6784                        ; perform BITSET
  6785                        
  6786                        LAB_BITSET
  6787 00:CCE2: 20 55 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6788 00:CCE5: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6789 00:CCE7: B0 20              BCS   FCError           ; branch if > 7
  6790                        
  6791 00:CCE9: A9 00              LDA   #$00              ; clear A
  6792 00:CCEB: 38                 SEC                     ; set the carry
  6793                        S_Bits
  6794 00:CCEC: 2A                 ROL                     ; shift bit
  6795 00:CCED: CA                 DEX                     ; decrement bit number
  6796 00:CCEE: 10 FC              BPL   S_Bits            ; loop if still +ve
  6797                        
  6798 00:CCF0: E8                 INX                     ; make X = $00
  Sun Mar  3 2019 22:47                                                                                                    Page 109


  6799 00:CCF1: 01 0A              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
  6800 00:CCF3: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  6801                        LAB_2D04
  6802 00:CCF5: 60                 RTS
  6803                        
  6804                        ; perform BITCLR
  6805                        
  6806                        LAB_BITCLR
  6807 00:CCF6: 20 55 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6808 00:CCF9: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6809 00:CCFB: B0 0C              BCS   FCError           ; branch if > 7
  6810                        
  6811 00:CCFD: A9 FF              LDA   #$FF              ; set A
  6812                        S_Bitc
  6813 00:CCFF: 2A                 ROL                     ; shift bit
  6814 00:CD00: CA                 DEX                     ; decrement bit number
  6815 00:CD01: 10 FC              BPL   S_Bitc            ; loop if still +ve
  6816                        
  6817 00:CD03: E8                 INX                     ; make X = $00
  6818 00:CD04: 21 0A              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
  6819 00:CD06: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  6820 00:CD08: 60                 RTS
  6821                        
  6822                        FCError
  6823 00:CD09: 4C B5 BE           JMP   LAB_FCER          ; do function call error then warm start
  6824                        
  6825                        ; perform BITTST()
  6826                        
  6827                        LAB_BTST
  6828 00:CD0C: 20 A5 CF           JSR   LAB_IGBY          ; increment BASIC pointer
  6829 00:CD0F: 20 55 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6830 00:CD12: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6831 00:CD14: B0 F3              BCS   FCError           ; branch if > 7
  6832                        
  6833 00:CD16: 20 AB CF           JSR   LAB_GBYT          ; get next BASIC byte
  6834 00:CD19: C9 29              CMP   #')'              ; is next character ")"
  6835 00:CD1B: F0 03              BEQ   TST_OK            ; if ")" go do rest of function
  6836                        
  6837 00:CD1D: 4C 97 BB           JMP   LAB_SNER          ; do syntax error then warm start
  6838                        
  6839                        TST_OK
  6840 00:CD20: 20 A5 CF           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  6841 00:CD23: A9 00              LDA   #$00              ; clear A
  6842 00:CD25: 38                 SEC                     ; set the carry
  6843                        T_Bits
  6844 00:CD26: 2A                 ROL                     ; shift bit
  6845 00:CD27: CA                 DEX                     ; decrement bit number
  6846 00:CD28: 10 FC              BPL   T_Bits            ; loop if still +ve
  6847                        
  6848 00:CD2A: E8                 INX                     ; make X = $00
  6849 00:CD2B: 21 0A              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
  6850 00:CD2D: F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
  6851                        
  6852 00:CD2F: A9 FF              LDA   #$FF              ; set for -1 result
  6853                        LAB_NOTT
  6854 00:CD31: 4C 6F C8           JMP   LAB_27DB          ; go do SGN tail
  6855                        
  6856                        ; perform BIN$()
  6857                        
  6858                        LAB_BINS
  6859 00:CD34: E0 19              CPX   #$19              ; max + 1
  6860 00:CD36: B0 48              BCS   BinFErr           ; exit if too big ( > or = )
  6861                        
  Sun Mar  3 2019 22:47                                                                                                    Page 110


  6862 00:CD38: 86 2A              STX   TempB             ; save # of characters ($00 = leading zero remove)
  6863 00:CD3A: A9 18              LDA   #$18              ; need A byte long space
  6864 00:CD3C: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long
  6865 00:CD3F: A0 17              LDY   #$17              ; set index
  6866 00:CD41: A2 18              LDX   #$18              ; character count
  6867                        NextB1
  6868 00:CD43: 46 0A              LSR   nums_1            ; shift highest byte
  6869 00:CD45: 66 0B              ROR   nums_2            ; shift middle byte
  6870 00:CD47: 66 0C              ROR   nums_3            ; shift lowest byte bit 0 to carry
  6871 00:CD49: 8A                 TXA                     ; load with "0"/2
  6872 00:CD4A: 2A                 ROL                     ; shift in carry
  6873 00:CD4B: 91 5F              STA   (str_pl),Y        ; save to temp string + index
  6874 00:CD4D: 88                 DEY                     ; decrement index
  6875 00:CD4E: 10 F3              BPL   NextB1            ; loop if not done
  6876                        
  6877 00:CD50: A5 2A              LDA   TempB             ; get # of characters
  6878 00:CD52: F0 0A              BEQ   EndBHS            ; branch if truncate
  6879                        
  6880 00:CD54: AA                 TAX                     ; copy length to X
  6881 00:CD55: 38                 SEC                     ; set carry for add !
  6882 00:CD56: 49 FF              EOR   #$FF              ; 1's complement
  6883 00:CD58: 69 18              ADC   #$18              ; add 24d
  6884 00:CD5A: F0 1C              BEQ   GoPr2             ; if zero print whole string
  6885 00:CD5C: 80 0F              BRA   GoPr1             ; else go make output string
  6886                        
  6887                        ; this is the exit code and is also used by HEX$()
  6888                        ; truncate string to remove leading "0"s
  6889                        
  6890                        EndBHS
  6891 00:CD5E: A8                 TAY                     ; clear index (A=0, X=length here)
  6892                        NextB2
  6893 00:CD5F: B1 5F              LDA   (str_pl),Y        ; get character from string
  6894 00:CD61: C9 30              CMP   #'0'              ; compare with "0"
  6895 00:CD63: D0 07              BNE   GoPr              ; if not "0" then go print string from here
  6896                        
  6897 00:CD65: CA                 DEX                     ; decrement character count
  6898 00:CD66: F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
  6899                        
  6900 00:CD68: C8                 INY                     ; else increment index
  6901 00:CD69: 80 F4              BRA   NextB2            ; loop always
  6902                        
  6903                        ; make fixed length output string - ignore overflows!
  6904                        
  6905                        GoPr3
  6906 00:CD6B: E8                 INX                     ; need at least 1 character
  6907                        GoPr
  6908 00:CD6C: 98                 TYA                     ; copy result
  6909                        GoPr1
  6910 00:CD6D: 18                 CLC                     ; clear carry for add
  6911 00:CD6E: 65 5F              ADC   str_pl            ; add low address
  6912 00:CD70: 85 5F              STA   str_pl            ; save low address
  6913 00:CD72: A9 00              LDA   #$00              ; do high byte
  6914 00:CD74: 65 60              ADC   str_ph            ; add high address
  6915 00:CD76: 85 60              STA   str_ph            ; save high address
  6916                        GoPr2
  6917 00:CD78: 86 5E              STX   str_ln            ; X holds string length
  6918 00:CD7A: 20 A5 CF           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  6919 00:CD7D: 4C 11 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put address
  6920                                                      ; and length on descriptor stack and update stack pointers
  6921                        
  6922                        BinFErr
  6923 00:CD80: 4C B5 BE           JMP   LAB_FCER          ; do function call error then warm start
  6924                        
  Sun Mar  3 2019 22:47                                                                                                    Page 111


  6925                        ; perform HEX$()
  6926                        
  6927                        LAB_HEXS
  6928 00:CD83: E0 07              CPX   #$07              ; max + 1
  6929 00:CD85: B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
  6930                        
  6931 00:CD87: 86 2A              STX   TempB             ; save # of characters
  6932                        
  6933 00:CD89: A9 06              LDA   #$06              ; need 6 bytes for string
  6934 00:CD8B: 20 C4 C0           JSR   LAB_MSSP          ; make string space A bytes long
  6935 00:CD8E: A0 05              LDY   #$05              ; set string index
  6936                        
  6937 00:CD90: A5 0C              LDA   nums_3            ; get lowest byte
  6938 00:CD92: 20 AF CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  6939 00:CD95: A5 0B              LDA   nums_2            ; get middle byte
  6940 00:CD97: 20 AF CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  6941 00:CD9A: A5 0A              LDA   nums_1            ; get highest byte
  6942 00:CD9C: 20 AF CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  6943                        
  6944 00:CD9F: A2 06              LDX   #$06              ; character count
  6945 00:CDA1: A5 2A              LDA   TempB             ; get # of characters
  6946 00:CDA3: F0 B9              BEQ   EndBHS            ; branch if truncate
  6947                        
  6948 00:CDA5: AA                 TAX                     ; copy length to X
  6949 00:CDA6: 38                 SEC                     ; set carry for add !
  6950 00:CDA7: 49 FF              EOR   #$FF              ; 1's complement
  6951 00:CDA9: 69 06              ADC   #$06              ; add 6d
  6952 00:CDAB: F0 CB              BEQ   GoPr2             ; if zero print whole string
  6953 00:CDAD: 80 BE              BRA   GoPr1             ; else go make output string (branch always)
  6954                        
  6955                        ; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6956                        
  6957                        LAB_A2HX
  6958 00:CDAF: AA                 TAX                     ; save byte
  6959 00:CDB0: 29 0F              AND   #$0F              ; mask off top bits
  6960 00:CDB2: 20 BA CD           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
  6961 00:CDB5: 8A                 TXA                     ; get byte back
  6962 00:CDB6: 4A                 LSR                     ; /2  shift high nibble to low nibble
  6963 00:CDB7: 4A                 LSR                     ; /4
  6964 00:CDB8: 4A                 LSR                     ; /8
  6965 00:CDB9: 4A                 LSR                     ; /16
  6966                        LAB_AL2X
  6967 00:CDBA: C9 0A              CMP   #$0A              ; set carry for +1 if >9
  6968 00:CDBC: 90 02              BCC   LAB_AL20          ; skip adjust if <= 9
  6969 00:CDBE: 69 06              ADC   #$06              ; adjust for A to F
  6970                        LAB_AL20
  6971 00:CDC0: 69 30              ADC   #'0'              ; add ASCII "0"
  6972 00:CDC2: 91 5F              STA   (str_pl),Y        ; save to temp string
  6973 00:CDC4: 88                 DEY                     ; decrement counter
  6974 00:CDC5: 60                 RTS
  6975                        
  6976                        LAB_NLTO
  6977 00:CDC6: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6978 00:CDC8: A9 00              LDA   #$00              ; clear sign compare
  6979                        LAB_MLTE
  6980 00:CDCA: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6981 00:CDCC: 8A                 TXA                     ; restore character
  6982 00:CDCD: 20 B1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  6983                        
  6984                        ; gets here if the first character was "$" for hex
  6985                        ; get hex number
  6986                        
  6987                        LAB_CHEX
  Sun Mar  3 2019 22:47                                                                                                    Page 112


  6988 00:CDD0: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  6989 00:CDD3: 90 0A              BCC   LAB_ISHN          ; branch if numeric character
  6990                        
  6991 00:CDD5: 09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
  6992 00:CDD7: E9 61              SBC   #'a'              ; subtract "a" (carry set here)
  6993 00:CDD9: C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
  6994 00:CDDB: B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
  6995                        
  6996 00:CDDD: 69 0A              ADC   #$0A              ; convert to nibble
  6997                        LAB_ISHN
  6998 00:CDDF: 29 0F              AND   #$0F              ; convert to binary
  6999 00:CDE1: AA                 TAX                     ; save nibble
  7000 00:CDE2: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7001 00:CDE4: F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
  7002                        
  7003 00:CDE6: 69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
  7004 00:CDE8: 90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
  7005                        
  7006                        LAB_MLTO
  7007 00:CDEA: 4C 3B C6           JMP   LAB_2564          ; do overflow error and warm start
  7008                        
  7009                        LAB_NXCH
  7010 00:CDED: AA                 TAX                     ; save bit
  7011 00:CDEE: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7012 00:CDF0: F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
  7013                        
  7014 00:CDF2: E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*2)
  7015 00:CDF4: F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
  7016                        
  7017 00:CDF6: A9 00              LDA   #$00              ; clear sign compare
  7018                        LAB_MLBT
  7019 00:CDF8: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  7020 00:CDFA: 8A                 TXA                     ; restore bit
  7021 00:CDFB: 20 B1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  7022                        
  7023                        ; gets here if the first character was  "%" for binary
  7024                        ; get binary number
  7025                        
  7026                        LAB_CBIN
  7027 00:CDFE: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  7028 00:CE01: 49 30              EOR   #'0'              ; convert "0" to 0 etc.
  7029 00:CE03: C9 02              CMP   #$02              ; compare with max+1
  7030 00:CE05: 90 E6              BCC   LAB_NXCH          ; branch exit if < 2
  7031                        
  7032                        LAB_EXCH
  7033 00:CE07: 4C 97 C9           JMP   LAB_28F6          ; evaluate -ve flag and return
  7034                        
  7035                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
  7036                        ; now also the code that checks to see if an interrupt has occurred
  7037                        
  7038                        CTRLC
  7039 00:CE0A: AD 7F 04           LDA   ccflag            ; get [CTRL-C] check flag
  7040 00:CE0D: D0 18              BNE   LAB_FBA2          ; exit if inhibited
  7041                        
  7042 00:CE0F: 20 C3 CF           JSR   V_INPT            ; scan input device
  7043 00:CE12: 90 0B              BCC   LAB_FBA0          ; exit if buffer empty
  7044                        
  7045 00:CE14: 8D 80 04           STA   ccbyte            ; save received byte
  7046 00:CE17: A2 20              LDX   #$20              ; "life" timer for bytes
  7047 00:CE19: 8E 81 04           STX   ccnull            ; set countdown
  7048 00:CE1C: 4C D8 B4           JMP   LAB_1636          ; return to BASIC
  7049                        
  7050                        LAB_FBA0
  Sun Mar  3 2019 22:47                                                                                                    Page 113


  7051 00:CE1F: AE 81 04           LDX   ccnull            ; get countdown byte
  7052 00:CE22: F0 03              BEQ   LAB_FBA2          ; exit if finished
  7053                        
  7054 00:CE24: CE 81 04           DEC   ccnull            ; else decrement countdown
  7055                        LAB_FBA2
  7056 00:CE27: 60                 RTS
  7057                        
  7058                        INGET
  7059 00:CE28: 20 C3 CF           JSR   V_INPT            ; call scan input device
  7060 00:CE2B: B0 09              BCS   LAB_FB95          ; if byte go reset timer
  7061                        
  7062 00:CE2D: AD 81 04           LDA   ccnull            ; get countdown
  7063 00:CE30: F0 07              BEQ   LAB_FB96          ; exit if empty
  7064                        
  7065 00:CE32: AD 80 04           LDA   ccbyte            ; get last received byte
  7066 00:CE35: 38                 SEC                     ; flag we got a byte
  7067                        LAB_FB95
  7068 00:CE36: 9C 81 04           STZ   ccnull            ; clear timer because we got a byte
  7069                        LAB_FB96
  7070 00:CE39: 60                 RTS
  7071                        
  7072                        ; MAX() MIN() pre process
  7073                        
  7074                        LAB_MMPP
  7075 00:CE3A: 20 83 BA           JSR   LAB_EVEZ          ; process expression
  7076 00:CE3D: 4C 69 BA           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
  7077                        
  7078                        ; perform MAX()
  7079                        
  7080                        LAB_MAX
  7081 00:CE40: 20 6E CE           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7082                                                      ; pull FAC2 and compare with FAC1
  7083 00:CE43: 10 FB              BPL   LAB_MAX           ; branch if no swap to do
  7084                        
  7085 00:CE45: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  7086 00:CE47: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7087 00:CE49: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  7088 00:CE4B: 20 3F C5           JSR   LAB_279B          ; copy FAC2 to FAC1
  7089 00:CE4E: 80 F0              BRA   LAB_MAX           ; go do next (branch always)
  7090                        
  7091                        ; perform MIN()
  7092                        
  7093                        LAB_MIN
  7094 00:CE50: 20 6E CE           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7095                                                      ; pull FAC2 and compare with FAC1
  7096 00:CE53: 30 FB              BMI   LAB_MIN           ; branch if no swap to do
  7097 00:CE55: F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
  7098                        
  7099 00:CE57: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  7100 00:CE59: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7101 00:CE5B: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  7102 00:CE5D: 20 3F C5           JSR   LAB_279B          ; copy FAC2 to FAC1
  7103 00:CE60: 80 EE              BRA   LAB_MIN           ; go do next (branch always)
  7104                        
  7105                        ; exit routine. don't bother returning to the loop code
  7106                        ; check for correct exit, else so syntax error
  7107                        
  7108                        LAB_MMEC
  7109 00:CE62: C9 29              CMP   #')'              ; is it end of function?
  7110 00:CE64: D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
  7111                        
  7112 00:CE66: 68                 PLA                     ; dump return address low byte
  7113 00:CE67: 68                 PLA                     ; dump return address high byte
  Sun Mar  3 2019 22:47                                                                                                    Page 114


  7114 00:CE68: 4C A5 CF           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
  7115                        
  7116                        LAB_MMSE
  7117 00:CE6B: 4C 97 BB           JMP   LAB_SNER          ; do syntax error then warm start
  7118                        
  7119                        ; check for next, evaluate and return or exit
  7120                        ; this is the routine that does most of the work
  7121                        
  7122                        LAB_PHFA
  7123 00:CE6E: 20 AB CF           JSR   LAB_GBYT          ; get next BASIC byte
  7124 00:CE71: C9 2C              CMP   #','              ; is there more ?
  7125 00:CE73: D0 ED              BNE   LAB_MMEC          ; if not go do end check
  7126                        
  7127                                                      ; push FAC1
  7128 00:CE75: 20 4E C8           JSR   LAB_27BA          ; round FAC1
  7129 00:CE78: A5 62              LDA   FAC1_s            ; get FAC1 sign
  7130 00:CE7A: 09 7F              ORA   #$7F              ; set all non sign bits
  7131 00:CE7C: 25 5F              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
  7132 00:CE7E: 48                 PHA                     ; push on stack
  7133 00:CE7F: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  7134 00:CE81: 48                 PHA                     ; push on stack
  7135 00:CE82: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  7136 00:CE84: 48                 PHA                     ; push on stack
  7137 00:CE85: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7138 00:CE87: 48                 PHA                     ; push on stack
  7139                        
  7140 00:CE88: 20 A5 CF           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
  7141 00:CE8B: 20 66 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  7142                                                      ; else do type mismatch
  7143                        
  7144                                                      ; pop FAC2 (MAX/MIN expression so far)
  7145 00:CE8E: 68                 PLA                     ; pop exponent
  7146 00:CE8F: 85 65              STA   FAC2_e            ; save FAC2 exponent
  7147 00:CE91: 68                 PLA                     ; pop mantissa3
  7148 00:CE92: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  7149 00:CE94: 68                 PLA                     ; pop mantissa1
  7150 00:CE95: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  7151 00:CE97: 68                 PLA                     ; pop sign/mantissa1
  7152 00:CE98: 85 66              STA   FAC2_1            ; save FAC2 sign/mantissa1
  7153 00:CE9A: 85 69              STA   FAC2_s            ; save FAC2 sign
  7154                        
  7155                                                      ; compare FAC1 with (packed) FAC2
  7156 00:CE9C: A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  7157 00:CE9E: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  7158 00:CEA0: 4C 88 C8           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
  7159                                                      ; returns A=$00 if FAC1 = (AY)
  7160                                                      ; returns A=$01 if FAC1 > (AY)
  7161                                                      ; returns A=$FF if FAC1 < (AY)
  7162                        
  7163                        ; perform WIDTH
  7164                        
  7165                        LAB_WDTH
  7166 00:CEA3: C9 2C              CMP   #','              ; is next byte ","
  7167 00:CEA5: F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
  7168                        
  7169 00:CEA7: 20 0C C4           JSR   LAB_GTBY          ; get byte parameter
  7170 00:CEAA: 8A                 TXA                     ; copy width to A
  7171 00:CEAB: F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
  7172                        
  7173 00:CEAD: E0 10              CPX   #$10              ; else make min width = 16d
  7174 00:CEAF: 90 45              BCC   TabErr            ; if less do function call error and exit
  7175                        
  7176                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
  Sun Mar  3 2019 22:47                                                                                                    Page 115


  7177                        ; tab size greater than the line length.
  7178                        
  7179 00:CEB1: E4 16              CPX   TabSiz            ; compare with tab size
  7180 00:CEB3: B0 02              BCS   LAB_NSTT          ; branch if >= tab size
  7181                        
  7182 00:CEB5: 86 16              STX   TabSiz            ; else make tab size = terminal width
  7183                        LAB_NSTT
  7184 00:CEB7: 86 08              STX   TWidth            ; set the terminal width
  7185 00:CEB9: 20 AB CF           JSR   LAB_GBYT          ; get BASIC byte back
  7186 00:CEBC: F0 1A              BEQ   WExit             ; exit if no following
  7187                        
  7188 00:CEBE: C9 2C              CMP   #','              ; else is it ","
  7189 00:CEC0: D0 A9              BNE   LAB_MMSE          ; if not do syntax error
  7190                        
  7191                        LAB_TBSZ
  7192 00:CEC2: 20 09 C4           JSR   LAB_SGBY          ; scan and get byte parameter
  7193 00:CEC5: 8A                 TXA                     ; copy TAB size
  7194 00:CEC6: 30 2E              BMI   TabErr            ; if >127 do function call error and exit
  7195                        
  7196 00:CEC8: E0 01              CPX   #$01              ; compare with min-1
  7197 00:CECA: 90 2A              BCC   TabErr            ; if <=1 do function call error and exit
  7198                        
  7199 00:CECC: A5 08              LDA   TWidth            ; set flags for width
  7200 00:CECE: F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
  7201                        
  7202 00:CED0: E4 08              CPX   TWidth            ; compare TAB with width
  7203 00:CED2: F0 02              BEQ   LAB_SVTB          ; ok if =
  7204 00:CED4: B0 20              BCS   TabErr            ; branch if too big
  7205                        
  7206                        LAB_SVTB
  7207 00:CED6: 86 16              STX   TabSiz            ; save TAB size
  7208                        
  7209                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7210                        ; position on a line that still has at least one whole tab width between it
  7211                        ; and the end of the line.
  7212                        
  7213                        WExit
  7214 00:CED8: A5 08              LDA   TWidth            ; get width
  7215 00:CEDA: F0 06              BEQ   LAB_SULP          ; branch if infinite line
  7216                        
  7217 00:CEDC: C5 16              CMP   TabSiz            ; compare with tab size
  7218 00:CEDE: B0 03              BCS   LAB_WDLP          ; branch if >= tab size
  7219                        
  7220 00:CEE0: 85 16              STA   TabSiz            ; else make tab size = terminal width
  7221                        LAB_SULP
  7222 00:CEE2: 38                 SEC                     ; set carry for subtract
  7223                        LAB_WDLP
  7224 00:CEE3: E5 16              SBC   TabSiz            ; subtract tab size
  7225 00:CEE5: B0 FC              BCS   LAB_WDLP          ; loop while no borrow
  7226                        
  7227 00:CEE7: 65 16              ADC   TabSiz            ; add tab size back
  7228 00:CEE9: 18                 CLC                     ; clear carry for add
  7229 00:CEEA: 65 16              ADC   TabSiz            ; add tab size back again
  7230 00:CEEC: 85 09              STA   Iclim             ; save for now
  7231 00:CEEE: A5 08              LDA   TWidth            ; get width back
  7232 00:CEF0: 38                 SEC                     ; set carry for subtract
  7233 00:CEF1: E5 09              SBC   Iclim             ; subtract remainder
  7234 00:CEF3: 85 09              STA   Iclim             ; save tab column limit
  7235                        LAB_NOSQ
  7236 00:CEF5: 60                 RTS
  7237                        
  7238                        TabErr
  7239 00:CEF6: 4C B5 BE           JMP   LAB_FCER          ; do function call error then warm start
  Sun Mar  3 2019 22:47                                                                                                    Page 116


  7240                        
  7241                        ; perform SQR()
  7242                        
  7243                        LAB_SQR
  7244 00:CEF9: A5 62              LDA   FAC1_s            ; get FAC1 sign
  7245 00:CEFB: 30 F9              BMI   TabErr            ; if -ve do function call error
  7246                        
  7247 00:CEFD: A5 5E              LDA   FAC1_e            ; get exponent
  7248 00:CEFF: F0 F4              BEQ   LAB_NOSQ          ; if zero just return
  7249                        
  7250                                                      ; else do root
  7251 00:CF01: 20 3F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  7252                        
  7253 00:CF04: 64 29              STZ   FACt_3            ; clear remainder
  7254 00:CF06: 64 28              STZ   FACt_2            ; ..
  7255 00:CF08: 64 27              STZ   FACt_1            ; ..
  7256 00:CF0A: 64 2A              STZ   TempB             ; ..
  7257                        
  7258 00:CF0C: 64 61              STZ   FAC1_3            ; clear root
  7259 00:CF0E: 64 60              STZ   FAC1_2            ; ..
  7260 00:CF10: 64 5F              STZ   FAC1_1            ; ..
  7261                        
  7262 00:CF12: A2 18              LDX   #$18              ; 24 pairs of bits to do
  7263 00:CF14: A5 65              LDA   FAC2_e            ; get exponent
  7264 00:CF16: 4A                 LSR                     ; check odd/even
  7265 00:CF17: B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
  7266                        
  7267                        LAB_SQE1
  7268 00:CF19: 06 68              ASL   FAC2_3            ; shift highest bit of number ..
  7269 00:CF1B: 26 67              ROL   FAC2_2            ; ..
  7270 00:CF1D: 26 66              ROL   FAC2_1            ; ..
  7271 00:CF1F: 26 29              ROL   FACt_3            ; .. into remainder
  7272 00:CF21: 26 28              ROL   FACt_2            ; ..
  7273 00:CF23: 26 27              ROL   FACt_1            ; ..
  7274 00:CF25: 26 2A              ROL   TempB             ; .. never overflows
  7275                        LAB_SQE2
  7276 00:CF27: 06 68              ASL   FAC2_3            ; shift highest bit of number ..
  7277 00:CF29: 26 67              ROL   FAC2_2            ; ..
  7278 00:CF2B: 26 66              ROL   FAC2_1            ; ..
  7279 00:CF2D: 26 29              ROL   FACt_3            ; .. into remainder
  7280 00:CF2F: 26 28              ROL   FACt_2            ; ..
  7281 00:CF31: 26 27              ROL   FACt_1            ; ..
  7282 00:CF33: 26 2A              ROL   TempB             ; .. never overflows
  7283                        
  7284 00:CF35: 06 61              ASL   FAC1_3            ; root = root * 2
  7285 00:CF37: 26 60              ROL   FAC1_2            ; ..
  7286 00:CF39: 26 5F              ROL   FAC1_1            ; .. never overflows
  7287                        
  7288 00:CF3B: A5 61              LDA   FAC1_3            ; get root low byte
  7289 00:CF3D: 2A                 ROL                     ; *2
  7290 00:CF3E: 85 0D              STA   Temp3             ; save partial low byte
  7291 00:CF40: A5 60              LDA   FAC1_2            ; get root low mid byte
  7292 00:CF42: 2A                 ROL                     ; *2
  7293 00:CF43: 85 0E              STA   Temp3+1           ; save partial low mid byte
  7294 00:CF45: A5 5F              LDA   FAC1_1            ; get root high mid byte
  7295 00:CF47: 2A                 ROL                     ; *2
  7296 00:CF48: 85 0F              STA   Temp3+2           ; save partial high mid byte
  7297 00:CF4A: A9 00              LDA   #$00              ; get root high byte (always $00)
  7298 00:CF4C: 2A                 ROL                     ; *2
  7299 00:CF4D: 85 10              STA   Temp3+3           ; save partial high byte
  7300                        
  7301                                                      ; carry clear for subtract +1
  7302 00:CF4F: A5 29              LDA   FACt_3            ; get remainder low byte
  Sun Mar  3 2019 22:47                                                                                                    Page 117


  7303 00:CF51: E5 0D              SBC   Temp3             ; subtract partial low byte
  7304 00:CF53: 85 0D              STA   Temp3             ; save partial low byte
  7305                        
  7306 00:CF55: A5 28              LDA   FACt_2            ; get remainder low mid byte
  7307 00:CF57: E5 0E              SBC   Temp3+1           ; subtract partial low mid byte
  7308 00:CF59: 85 0E              STA   Temp3+1           ; save partial low mid byte
  7309                        
  7310 00:CF5B: A5 27              LDA   FACt_1            ; get remainder high mid byte
  7311 00:CF5D: E5 0F              SBC   Temp3+2           ; subtract partial high mid byte
  7312 00:CF5F: A8                 TAY                     ; copy partial high mid byte
  7313                        
  7314 00:CF60: A5 2A              LDA   TempB             ; get remainder high byte
  7315 00:CF62: E5 10              SBC   Temp3+3           ; subtract partial high byte
  7316 00:CF64: 90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
  7317                        
  7318 00:CF66: 85 2A              STA   TempB             ; save remainder high byte
  7319                        
  7320 00:CF68: 84 27              STY   FACt_1            ; save remainder high mid byte
  7321                        
  7322 00:CF6A: A5 0E              LDA   Temp3+1           ; get remainder low mid byte
  7323 00:CF6C: 85 28              STA   FACt_2            ; save remainder low mid byte
  7324                        
  7325 00:CF6E: A5 0D              LDA   Temp3             ; get partial low byte
  7326 00:CF70: 85 29              STA   FACt_3            ; save remainder low byte
  7327                        
  7328 00:CF72: E6 61              INC   FAC1_3            ; increment root low byte (never any rollover)
  7329                        LAB_SQNS
  7330 00:CF74: CA                 DEX                     ; decrement bit pair count
  7331 00:CF75: D0 A2              BNE   LAB_SQE1          ; loop if not all done
  7332                        
  7333 00:CF77: 38                 SEC                     ; set carry for subtract
  7334 00:CF78: A5 65              LDA   FAC2_e            ; get exponent
  7335 00:CF7A: E9 80              SBC   #$80              ; normalise
  7336 00:CF7C: 6A                 ROR                     ; /2 and re-bias to $80
  7337 00:CF7D: 69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
  7338 00:CF7F: 85 5E              STA   FAC1_e            ; save it
  7339 00:CF81: 4C AC C5           JMP   LAB_24D5          ; normalise FAC1 and return
  7340                        
  7341                        ; perform VARPTR()
  7342                        
  7343                        LAB_VARPTR
  7344 00:CF84: 20 A5 CF           JSR   LAB_IGBY          ; increment and scan memory
  7345 00:CF87: 20 39 BD           JSR   LAB_GVAR          ; get var address
  7346 00:CF8A: 20 86 BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  7347 00:CF8D: A4 47              LDY   Cvaral            ; get var address low byte
  7348 00:CF8F: A5 48              LDA   Cvarah            ; get var address high byte
  7349 00:CF91: 4C E5 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  7350                        
  7351                        ; perform PI
  7352                        
  7353                        LAB_PI
  7354 00:CF94: A9 59              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7355 00:CF96: A0 D0              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7356 00:CF98: 20 F2 C7           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  7357 00:CF9B: C6 5E              DEC   FAC1_e            ; make result = PI
  7358 00:CF9D: 60                 RTS
  7359                        
  7360                        ; perform TWOPI
  7361                        
  7362                        LAB_TWOPI
  7363 00:CF9E: A9 59              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7364 00:CFA0: A0 D0              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7365 00:CFA2: 4C F2 C7           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
  Sun Mar  3 2019 22:47                                                                                                    Page 118


  7366                        
  7367                        ; character get subroutine - ROM based
  7368                        
  7369                        ; the target address for the LDA at LAB_GBYT is the BASIC execute pointer.
  7370                        ; block is no longer copied to page zero and uses a CMOS instruction/address mode.
  7371                        ; 16-bit pointer is located in page zero.
  7372                        
  7373                        ; increment and scan memory
  7374                        LAB_IGBY
  7375 00:CFA5: E6 6E              INC   Bpntrl            ; increment BASIC execute pointer low byte
  7376 00:CFA7: D0 02              BNE   LAB_GBYT          ; branch if no carry, else
  7377 00:CFA9: E6 6F              INC   Bpntrh            ; increment BASIC execute pointer high byte
  7378                        
  7379                        ; scan memory
  7380                        
  7381                        LAB_GBYT
  7382 00:CFAB: B2 6E              LDA	(Bpntrl)            ; get byte to scan (addr set by call routine)
  7383 00:CFAD: C9 A9              CMP   #TK_ELSE          ; compare with the token for ELSE
  7384 00:CFAF: F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
  7385                        
  7386 00:CFB1: C9 3A              CMP   #':'              ; compare with ":"
  7387 00:CFB3: B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
  7388                        
  7389 00:CFB5: C9 20              CMP   #' '              ; compare with " "
  7390 00:CFB7: F0 EC              BEQ   LAB_IGBY          ; if " " go do next
  7391                        
  7392 00:CFB9: 38                 SEC                     ; set carry for SBC
  7393 00:CFBA: E9 30              SBC   #'0'              ; subtract "0"
  7394 00:CFBC: 38                 SEC                     ; set carry for SBC
  7395 00:CFBD: E9 D0              SBC   #$D0              ; subtract -"0"
  7396                                                      ; clear carry if byte = "0"-"9"
  7397                        LAB_2D05
  7398 00:CFBF: 60                 RTS
  7399                        
  7400                        LAB_EXIT
  7401 00:CFC0: 4C CF CF          JMP    V_EXIT            ; exit back to C02 Monitor Warm start soft vector
  7402                        
  7403                        ; system dependant i/o vectors
  7404                        ; these are in RAM and are set by the monitor at start-up
  7405                        
  7406                        V_INPT
  7407 00:CFC3: 6C 84 04           JMP   (VEC_IN)          ; non halting scan input device
  7408                        V_OUTP
  7409 00:CFC6: 6C 86 04           JMP   (VEC_OUT)         ; send byte to output device
  7410                        V_LOAD
  7411 00:CFC9: 6C 88 04           JMP   (VEC_LD)          ; load BASIC program
  7412                        V_SAVE
  7413 00:CFCC: 6C 8A 04           JMP   (VEC_SV)          ; save BASIC program
  7414                        V_EXIT
  7415 00:CFCF: 6C 8C 04           JMP   (VEC_EXIT)        ; warm start C02 Monitor
  7416                        
  7417                        ; The rest are tables messages and code for RAM
  7418                        
  7419                        ; the rest of the code is tables and BASIC start-up code
  7420                        ; monitor routines required are added below for initialization
  7421                        
  7422                        PG4_TABS
  7423 00:CFD2: 00                 .byte $00               ; ctrl-c flag           -     $00 = enabled
  7424 00:CFD3: 00                 .byte $00               ; ctrl-c byte           -     GET needs this
  7425 00:CFD4: 00                 .byte $00               ; ctrl-c byte timeout   -     GET needs this
  7426 00:CFD5: 0A CE              .word CTRLC             ; ctrl c check vector
  7427                        ;
  7428 00:CFD7: 48 FF              .word $FF48           	; byte in from C02BIOS (no waiting)
  Sun Mar  3 2019 22:47                                                                                                    Page 119


  7429 00:CFD9: 4E FF              .word $FF4E           	; byte out from C02BIOS
  7430 00:CFDB: 45 FF              .word $FF45           	; null load JMP for EhBASIC (Reserve)
  7431 00:CFDD: 45 FF              .word $FF45           	; null save JMP for EhBASIC (Reserve)
  7432 00:CFDF: 72 FF              .word $FF72             ; Warm start JMP for C02 Monitor
  7433                        
  7434                        PG4_TABE
  7435                        
  7436                        ; page zero initialisation table $00-$0B inclusive
  7437                        
  7438                        StrTab
  7439 00:CFE1: 4C                 .byte $4C               ; JMP opcode
  7440 00:CFE2: 00 B0              .word LAB_COLD          ; initial warm start vector (cold start)
  7441                        
  7442 00:CFE4: 4C                 .byte $4C               ; JMP opcode
  7443 00:CFE5: B5 BE              .word LAB_FCER          ; initial user function vector ("Function call" error)
  7444                        
  7445 00:CFE7: 00                 .byte $00               ; default NULL count
  7446 00:CFE8: 00                 .byte $00               ; clear terminal position
  7447 00:CFE9: 50                 .byte $50               ; default terminal width byte = 80
  7448 00:CFEA: F2                 .byte $F2               ; default limit for TAB = 14
  7449 00:CFEB: 00 08              .word Ram_base          ; start of user RAM
  7450                        EndTab
  7451                        
  7452                        LAB_SMSG
  7453 00:CFED: 20 42 79 74        .byte " Bytes free",$0D,$00
       00:CFF1: 65 73 20 66 
       00:CFF5: 72 65 65 0D 
       00:CFF9: 00 
  7454                        
  7455                        ; numeric constants and series
  7456                        ; cleaned up to removed commented lines which were replaced
  7457                        
  7458                                                      ; constants and series for LOG(n)
  7459                        LAB_25A0
  7460 00:CFFA: 02                 .byte $02               ; counter
  7461 00:CFFB: 80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
  7462 00:CFFF: 80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
  7463 00:D003: 82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
  7464                        
  7465                        LAB_25AD
  7466 00:D007: 80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
  7467                        LAB_25B1
  7468 00:D00B: 81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
  7469                        LAB_25B5
  7470 00:D00F: 80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
  7471                        LAB_25B9
  7472 00:D013: 80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
  7473                        
  7474                                                      ; numeric PRINT constants
  7475                        LAB_2947
  7476 00:D017: 91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
  7477                        LAB_294B
  7478 00:D01B: 94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
  7479                        LAB_294F
  7480 00:D01F: 94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
  7481                        
  7482                                                      ; EXP(n) constants and series
  7483                        LAB_2AFA
  7484 00:D023: 81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
  7485                        LAB_2AFE
  7486 00:D027: 06                 .byte $06               ; counter
  7487 00:D028: 74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
  7488 00:D02C: 77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
  Sun Mar  3 2019 22:47                                                                                                    Page 120


  7489 00:D030: 7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
  7490 00:D034: 7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
  7491 00:D038: 7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
  7492 00:D03C: 80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
  7493 00:D040: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
  7494                        
  7495                                                      ; trigonometric constants and series
  7496                        LAB_2C78
  7497 00:D044: 81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
  7498                        LAB_2C84
  7499 00:D048: 04                 .byte $04               ; counter
  7500 00:D049: 86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
  7501 00:D04D: 87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
  7502 00:D051: 87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
  7503 00:D055: 86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
  7504                        LAB_2C7C
  7505 00:D059: 83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
  7506                        
  7507                        LAB_2CC9
  7508 00:D05D: 08                 .byte $08               ; counter
  7509 00:D05E: 78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
  7510 00:D062: 7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
  7511 00:D066: 7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
  7512 00:D06A: 7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
  7513 00:D06E: 7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
  7514 00:D072: 7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
  7515 00:D076: 7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
  7516 00:D07A: 7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
  7517                        
  7518             0000D07F   LAB_1D96    .EQU *+1             ; $00,$00 used for undefined variables
  7519                        LAB_259C
  7520 00:D07E: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
  7521                        LAB_2AFD
  7522 00:D082: 81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
  7523                        
  7524                                                      ; misc constants
  7525                        LAB_1DF7
  7526 00:D086: 90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
  7527                        LAB_2A96
  7528 00:D087: 80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
  7529                        LAB_2C80
  7530 00:D08B: 7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
  7531                        LAB_26B5
  7532 00:D08F: 84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
  7533                        
  7534                        ; This table is used in converting numbers to ASCII.
  7535                        
  7536                        LAB_2A9A
  7537             0000D094   LAB_2A9B .EQU LAB_2A9A+1
  7538             0000D095   LAB_2A9C .EQU LAB_2A9B+1
  7539 00:D093: FE 79 60           .byte $FE,$79,$60       ; -100000
  7540 00:D096: 00 27 10           .byte $00,$27,$10       ; 10000
  7541 00:D099: FF FC 18           .byte $FF,$FC,$18       ; -1000
  7542 00:D09C: 00 00 64           .byte $00,$00,$64       ; 100
  7543 00:D09F: FF FF F6           .byte $FF,$FF,$F6       ; -10
  7544 00:D0A2: 00 00 01           .byte $00,$00,$01       ; 1
  7545                        
  7546                        LAB_CTBL
  7547 00:D0A5: DB B4              .word LAB_END-1         ; END
  7548 00:D0A7: 1D B4              .word LAB_FOR-1         ; FOR
  7549 00:D0A9: FD B9              .word LAB_NEXT-1        ; NEXT
  7550 00:D0AB: 3E B6              .word LAB_DATA-1        ; DATA
  7551 00:D0AD: E3 B8              .word LAB_INPUT-1       ; INPUT
  Sun Mar  3 2019 22:47                                                                                                    Page 121


  7552 00:D0AF: ED BC              .word LAB_DIM-1         ; DIM
  7553 00:D0B1: 02 B9              .word LAB_READ-1        ; READ
  7554 00:D0B3: 59 B7              .word LAB_LET-1         ; LET
  7555 00:D0B5: 2B B7              .word LAB_DEC-1         ; DEC             new command
  7556 00:D0B7: 9D B5              .word LAB_GOTO-1        ; GOTO
  7557 00:D0B9: 5C B5              .word LAB_RUN-1         ; RUN
  7558 00:D0BB: 6D B6              .word LAB_IF-1          ; IF
  7559 00:D0BD: FC B4              .word LAB_RESTORE-1     ; RESTORE         modified command
  7560 00:D0BF: 80 B5              .word LAB_GOSUB-1       ; GOSUB
  7561 00:D0C1: 29 B6              .word LAB_RETURN-1      ; RETURN
  7562 00:D0C3: D2 B6              .word LAB_REM-1         ; REM
  7563 00:D0C5: D9 B4              .word LAB_STOP-1        ; STOP
  7564 00:D0C7: DB B6              .word LAB_ON-1          ; ON              modified command
  7565 00:D0C9: 3A B5              .word LAB_NULL-1        ; NULL            modified command
  7566 00:D0CB: 2F B7              .word LAB_INC-1         ; INC             new command
  7567 00:D0CD: 05 C5              .word LAB_WAIT-1        ; WAIT
  7568 00:D0CF: C8 CF              .word V_LOAD-1          ; LOAD
  7569 00:D0D1: CB CF              .word V_SAVE-1          ; SAVE
  7570 00:D0D3: FF BF              .word LAB_DEF-1         ; DEF
  7571 00:D0D5: 8A C4              .word LAB_POKE-1        ; POKE
  7572 00:D0D7: A6 C4              .word LAB_DOKE-1        ; DOKE            new command
  7573 00:D0D9: F3 C4              .word LAB_CALL-1        ; CALL            new command
  7574 00:D0DB: 66 B5              .word LAB_DO-1          ; DO              new command
  7575 00:D0DD: CF B5              .word LAB_LOOP-1        ; LOOP            new command
  7576 00:D0DF: F4 B7              .word LAB_PRINT-1       ; PRINT
  7577 00:D0E1: 40 B5              .word LAB_CONT-1        ; CONT
  7578 00:D0E3: 68 B3              .word LAB_LIST-1        ; LIST
  7579 00:D0E5: 65 B3              .word LAB_CLEAR-1       ; CLEAR
  7580 00:D0E7: 18 B3              .word LAB_NEW-1         ; NEW
  7581 00:D0E9: A2 CE              .word LAB_WDTH-1        ; WIDTH           new command
  7582 00:D0EB: C6 B7              .word LAB_GET-1         ; GET             new command
  7583 00:D0ED: CB C4              .word LAB_SWAP-1        ; SWAP            new command
  7584 00:D0EF: E1 CC              .word LAB_BITSET-1      ; BITSET          new command
  7585 00:D0F1: F5 CC              .word LAB_BITCLR-1      ; BITCLR          new command
  7586 00:D0F3: BF CF              .word LAB_EXIT-1        ; EXIT            new command (exits to C02 Monitor)
  7587                        
  7588                        ; function pre process routine table
  7589                        
  7590                        LAB_FTPL
  7591             0000D0F6   LAB_FTPM    .EQU LAB_FTPL+$01
  7592 00:D0F5: F8 BB              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
  7593 00:D0F7: F8 BB              .word LAB_PPFN-1        ; INT(n)          "
  7594 00:D0F9: F8 BB              .word LAB_PPFN-1        ; ABS(n)          "
  7595 00:D0FB: 82 BA              .word LAB_EVEZ-1        ; USR(x)    process any expression
  7596 00:D0FD: 82 BB              .word LAB_1BF7-1        ; FRE(x)          "
  7597 00:D0FF: 82 BB              .word LAB_1BF7-1        ; POS(x)          "
  7598 00:D101: F8 BB              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
  7599 00:D103: F8 BB              .word LAB_PPFN-1        ; RND(n)          "
  7600 00:D105: F8 BB              .word LAB_PPFN-1        ; LOG(n)          "
  7601 00:D107: F8 BB              .word LAB_PPFN-1        ; EXP(n)          "
  7602 00:D109: F8 BB              .word LAB_PPFN-1        ; COS(n)          "
  7603 00:D10B: F8 BB              .word LAB_PPFN-1        ; SIN(n)          "
  7604 00:D10D: F8 BB              .word LAB_PPFN-1        ; TAN(n)          "
  7605 00:D10F: F8 BB              .word LAB_PPFN-1        ; ATN(n)          "
  7606 00:D111: F8 BB              .word LAB_PPFN-1        ; PEEK(n)         "
  7607 00:D113: F8 BB              .word LAB_PPFN-1        ; DEEK(n)         "
  7608 00:D115: 00 00              .word $0000             ; SADD()    none
  7609 00:D117: F2 BB              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
  7610 00:D119: F8 BB              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
  7611 00:D11B: F2 BB              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
  7612 00:D11D: F2 BB              .word LAB_PPFS-1        ; ASC($)          "
  7613 00:D11F: F2 BB              .word LAB_PPFS-1        ; UCASE$($)       "
  7614 00:D121: F2 BB              .word LAB_PPFS-1        ; LCASE$($)       "
  Sun Mar  3 2019 22:47                                                                                                    Page 122


  7615 00:D123: F8 BB              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
  7616 00:D125: 1B BC              .word LAB_BHSS-1        ; HEX$(n)         "
  7617 00:D127: 1B BC              .word LAB_BHSS-1        ; BIN$(n)         "
  7618 00:D129: 00 00              .word $0000             ; BITTST()  none
  7619 00:D12B: 39 CE              .word LAB_MMPP-1        ; MAX()     process numeric expression
  7620 00:D12D: 39 CE              .word LAB_MMPP-1        ; MIN()           "
  7621 00:D12F: FE BB              .word LAB_PPBI-1        ; PI        advance pointer
  7622 00:D131: FE BB              .word LAB_PPBI-1        ; TWOPI           "
  7623 00:D133: 00 00              .word $0000             ; VARPTR()  none
  7624 00:D135: 03 BC              .word LAB_LRMS-1        ; LEFT$()   process string expression
  7625 00:D137: 03 BC              .word LAB_LRMS-1        ; RIGHT$()        "
  7626 00:D139: 03 BC              .word LAB_LRMS-1        ; MID$()          "
  7627                        
  7628                        ; action addresses for functions
  7629                        
  7630                        LAB_FTBL
  7631             0000D13C   LAB_FTBM    .EQU LAB_FTBL+$01
  7632 00:D13B: 6B C8              .word LAB_SGN-1         ; SGN()
  7633 00:D13D: F0 C8              .word LAB_INT-1         ; INT()
  7634 00:D13F: 84 C8              .word LAB_ABS-1         ; ABS()
  7635 00:D141: AC CC              .word LAB_USR-1         ; USR()
  7636 00:D143: D0 BF              .word LAB_FRE-1         ; FRE()
  7637 00:D145: EF BF              .word LAB_POS-1         ; POS()
  7638 00:D147: F8 CE              .word LAB_SQR-1         ; SQR()
  7639 00:D149: 03 CC              .word LAB_RND-1         ; RND()           modified function
  7640 00:D14B: 72 C6              .word LAB_LOG-1         ; LOG()
  7641 00:D14D: 67 CB              .word LAB_EXP-1         ; EXP()
  7642 00:D14F: 37 CC              .word LAB_COS-1         ; COS()
  7643 00:D151: 3E CC              .word LAB_SIN-1         ; SIN()
  7644 00:D153: 85 CC              .word LAB_TAN-1         ; TAN()
  7645 00:D155: B2 CC              .word LAB_ATN-1         ; ATN()
  7646 00:D157: 7F C4              .word LAB_PEEK-1        ; PEEK()
  7647 00:D159: 93 C4              .word LAB_DEEK-1        ; DEEK()          new function
  7648 00:D15B: D6 C3              .word LAB_SADD-1        ; SADD()          new function
  7649 00:D15D: EF C3              .word LAB_LENS-1        ; LEN()
  7650 00:D15F: AF C0              .word LAB_STRS-1        ; STR$()
  7651 00:D161: 1A C4              .word LAB_VAL-1         ; VAL()
  7652 00:D163: FA C3              .word LAB_ASC-1         ; ASC()
  7653 00:D165: B4 C3              .word LAB_UCASE-1       ; UCASE$()        new function
  7654 00:D167: 93 C3              .word LAB_LCASE-1       ; LCASE$()        new function
  7655 00:D169: 0A C3              .word LAB_CHRS-1        ; CHR$()
  7656 00:D16B: 82 CD              .word LAB_HEXS-1        ; HEX$()          new function
  7657 00:D16D: 33 CD              .word LAB_BINS-1        ; BIN$()          new function
  7658 00:D16F: 0B CD              .word LAB_BTST-1        ; BITTST()        new function
  7659 00:D171: 3F CE              .word LAB_MAX-1         ; MAX()           new function
  7660 00:D173: 4F CE              .word LAB_MIN-1         ; MIN()           new function
  7661 00:D175: 93 CF              .word LAB_PI-1          ; PI              new function
  7662 00:D177: 9D CF              .word LAB_TWOPI-1       ; TWOPI           new function
  7663 00:D179: 83 CF              .word LAB_VARPTR-1      ; VARPTR()        new function
  7664 00:D17B: 19 C3              .word LAB_LEFT-1        ; LEFT$()
  7665 00:D17D: 22 C3              .word LAB_RIGHT-1       ; RIGHT$()
  7666 00:D17F: 50 C3              .word LAB_MIDS-1        ; MID$()
  7667                        
  7668                        ; hierarchy and action addresses for operator
  7669                        
  7670                        LAB_OPPT
  7671 00:D181: 79                 .byte $79               ; +
  7672 00:D182: 3C C5              .word LAB_ADD-1
  7673 00:D184: 79                 .byte $79               ; -
  7674 00:D185: 22 C5              .word LAB_SUBTRACT-1
  7675 00:D187: 7B                 .byte $7B               ; *
  7676 00:D188: B3 C6              .word LAB_MULTIPLY-1
  7677 00:D18A: 7B                 .byte $7B               ; /
  Sun Mar  3 2019 22:47                                                                                                    Page 123


  7678 00:D18B: 79 C7              .word LAB_DIVIDE-1
  7679 00:D18D: 7F                 .byte $7F               ; ^
  7680 00:D18E: 23 CB              .word LAB_POWER-1
  7681 00:D190: 50                 .byte $50               ; AND
  7682 00:D191: 64 BC              .word LAB_AND-1
  7683 00:D193: 46                 .byte $46               ; EOR             new operator
  7684 00:D194: 4A BC              .word LAB_EOR-1
  7685 00:D196: 46                 .byte $46               ; OR
  7686 00:D197: 57 BC              .word LAB_OR-1
  7687 00:D199: 56                 .byte $56               ; >>              new operator
  7688 00:D19A: 0F BD              .word LAB_RSHIFT-1
  7689 00:D19C: 56                 .byte $56               ; <<              new operator
  7690 00:D19D: F7 BC              .word LAB_LSHIFT-1
  7691 00:D19F: 7D                 .byte $7D               ; >
  7692 00:D1A0: 5C CB              .word LAB_GTHAN-1
  7693 00:D1A2: 5A                 .byte $5A               ; =
  7694 00:D1A3: AB BB              .word LAB_EQUAL-1
  7695 00:D1A5: 64                 .byte $64               ; <
  7696 00:D1A6: 85 BC              .word LAB_LTHAN-1
  7697                        
  7698                        ; keywords start with ..
  7699                        ; this is the first character table and must be in alphabetic order
  7700                        
  7701                        TAB_1STC
  7702 00:D1A8: 2A                 .byte "*"
  7703 00:D1A9: 2B                 .byte "+"
  7704 00:D1AA: 2D                 .byte "-"
  7705 00:D1AB: 2F                 .byte "/"
  7706 00:D1AC: 3C                 .byte "<"
  7707 00:D1AD: 3D                 .byte "="
  7708 00:D1AE: 3E                 .byte ">"
  7709 00:D1AF: 3F                 .byte "?"
  7710 00:D1B0: 41                 .byte "A"
  7711 00:D1B1: 42                 .byte "B"
  7712 00:D1B2: 43                 .byte "C"
  7713 00:D1B3: 44                 .byte "D"
  7714 00:D1B4: 45                 .byte "E"
  7715 00:D1B5: 46                 .byte "F"
  7716 00:D1B6: 47                 .byte "G"
  7717 00:D1B7: 48                 .byte "H"
  7718 00:D1B8: 49                 .byte "I"
  7719 00:D1B9: 4C                 .byte "L"
  7720 00:D1BA: 4D                 .byte "M"
  7721 00:D1BB: 4E                 .byte "N"
  7722 00:D1BC: 4F                 .byte "O"
  7723 00:D1BD: 50                 .byte "P"
  7724 00:D1BE: 52                 .byte "R"
  7725 00:D1BF: 53                 .byte "S"
  7726 00:D1C0: 54                 .byte "T"
  7727 00:D1C1: 55                 .byte "U"
  7728 00:D1C2: 56                 .byte "V"
  7729 00:D1C3: 57                 .byte "W"
  7730 00:D1C4: 5E                 .byte "^"
  7731 00:D1C5: 00                 .byte $00               ; table terminator
  7732                        
  7733                        ; pointers to keyword tables
  7734                        
  7735                        TAB_CHRT
  7736 00:D1C6: 00 D2              .word TAB_STAR          ; table for "*"
  7737 00:D1C8: 02 D2              .word TAB_PLUS          ; table for "+"
  7738 00:D1CA: 04 D2              .word TAB_MNUS          ; table for "-"
  7739 00:D1CC: 06 D2              .word TAB_SLAS          ; table for "/"
  7740 00:D1CE: 08 D2              .word TAB_LESS          ; table for "<"
  Sun Mar  3 2019 22:47                                                                                                    Page 124


  7741 00:D1D0: 0C D2              .word TAB_EQUL          ; table for "="
  7742 00:D1D2: 0E D2              .word TAB_MORE          ; table for ">"
  7743 00:D1D4: 12 D2              .word TAB_QEST          ; table for "?"
  7744 00:D1D6: 14 D2              .word TAB_ASCA          ; table for "A"
  7745 00:D1D8: 24 D2              .word TAB_ASCB          ; table for "B"
  7746 00:D1DA: 3D D2              .word TAB_ASCC          ; table for "C"
  7747 00:D1DC: 54 D2              .word TAB_ASCD          ; table for "D"
  7748 00:D1DE: 6D D2              .word TAB_ASCE          ; table for "E"
  7749 00:D1E0: 80 D2              .word TAB_ASCF          ; table for "F"
  7750 00:D1E2: 8A D2              .word TAB_ASCG          ; table for "G"
  7751 00:D1E4: 97 D2              .word TAB_ASCH          ; table for "H"
  7752 00:D1E6: 9D D2              .word TAB_ASCI          ; table for "I"
  7753 00:D1E8: AC D2              .word TAB_ASCL          ; table for "L"
  7754 00:D1EA: D1 D2              .word TAB_ASCM          ; table for "M"
  7755 00:D1EC: DF D2              .word TAB_ASCN          ; table for "N"
  7756 00:D1EE: EE D2              .word TAB_ASCO          ; table for "O"
  7757 00:D1F0: F3 D2              .word TAB_ASCP          ; table for "P"
  7758 00:D1F2: 08 D3              .word TAB_ASCR          ; table for "R"
  7759 00:D1F4: 2B D3              .word TAB_ASCS          ; table for "S"
  7760 00:D1F6: 56 D3              .word TAB_ASCT          ; table for "T"
  7761 00:D1F8: 6A D3              .word TAB_ASCU          ; table for "U"
  7762 00:D1FA: 7B D3              .word TAB_ASCV          ; table for "V"
  7763 00:D1FC: 87 D3              .word TAB_ASCW          ; table for "W"
  7764 00:D1FE: 96 D3              .word TAB_POWR          ; table for "^"
  7765                        
  7766                        ; tables for each start character, note if a longer keyword with the same start
  7767                        ; letters as a shorter one exists then it must come first, else the list is in
  7768                        ; alphabetical order as follows ..
  7769                        
  7770                        ; [keyword,token
  7771                        ; [keyword,token]]
  7772                        ; end marker (#$00)
  7773                        
  7774                        TAB_STAR
  7775 00:D200: B4 00              .byte TK_MUL,$00        ; *
  7776                        TAB_PLUS
  7777 00:D202: B2 00              .byte TK_PLUS,$00       ; +
  7778                        TAB_MNUS
  7779 00:D204: B3 00              .byte TK_MINUS,$00      ; -
  7780                        TAB_SLAS
  7781 00:D206: B5 00              .byte TK_DIV,$00        ; /
  7782                        TAB_LESS
  7783                        LBB_LSHIFT
  7784 00:D208: 3C BB              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
  7785 00:D20A: BE                 .byte TK_LT             ; <
  7786 00:D20B: 00                 .byte $00
  7787                        TAB_EQUL
  7788 00:D20C: BD 00              .byte TK_EQUAL,$00      ; =
  7789                        TAB_MORE
  7790                        LBB_RSHIFT
  7791 00:D20E: 3E BA              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
  7792 00:D210: BC                 .byte TK_GT             ; >
  7793 00:D211: 00                 .byte $00
  7794                        TAB_QEST
  7795 00:D212: 9D 00              .byte TK_PRINT,$00      ; ?
  7796                        TAB_ASCA
  7797                        LBB_ABS
  7798 00:D214: 42 53 28 C1        .byte "BS(",TK_ABS      ; ABS(
  7799                        LBB_AND
  7800 00:D218: 4E 44 B7           .byte "ND",TK_AND       ; AND
  7801                        LBB_ASC
  7802 00:D21B: 53 43 28 D3        .byte "SC(",TK_ASC      ; ASC(
  7803                        LBB_ATN
  Sun Mar  3 2019 22:47                                                                                                    Page 125


  7804 00:D21F: 54 4E 28 CC        .byte "TN(",TK_ATN      ; ATN(
  7805 00:D223: 00                 .byte $00
  7806                        TAB_ASCB
  7807                        LBB_BINS
  7808 00:D224: 49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
       00:D228: D8 
  7809                        LBB_BITCLR
  7810 00:D229: 49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
       00:D22D: 52 A6 
  7811                        LBB_BITSET
  7812 00:D22F: 49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
       00:D233: 54 A5 
  7813                        LBB_BITTST
  7814 00:D235: 49 54 54 53        .byte "ITTST(",TK_BITTST
       00:D239: 54 28 D9 
  7815                                                      ; BITTST(
  7816 00:D23C: 00                 .byte $00
  7817                        TAB_ASCC
  7818                        LBB_CALL
  7819 00:D23D: 41 4C 4C 9A        .byte "ALL",TK_CALL     ; CALL
  7820                        LBB_CHRS
  7821 00:D241: 48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
       00:D245: D6 
  7822                        LBB_CLEAR
  7823 00:D246: 4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
       00:D24A: A0 
  7824                        LBB_CONT
  7825 00:D24B: 4F 4E 54 9E        .byte "ONT",TK_CONT     ; CONT
  7826                        LBB_COS
  7827 00:D24F: 4F 53 28 C9        .byte "OS(",TK_COS      ; COS(
  7828 00:D253: 00                 .byte $00
  7829                        TAB_ASCD
  7830                        LBB_DATA
  7831 00:D254: 41 54 41 83        .byte "ATA",TK_DATA     ; DATA
  7832                        LBB_DEC
  7833 00:D258: 45 43 88           .byte "EC",TK_DEC       ; DEC
  7834                        LBB_DEEK
  7835 00:D25B: 45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
       00:D25F: CE 
  7836                        LBB_DEF
  7837 00:D260: 45 46 97           .byte "EF",TK_DEF       ; DEF
  7838                        LBB_DIM
  7839 00:D263: 49 4D 85           .byte "IM",TK_DIM       ; DIM
  7840                        LBB_DOKE
  7841 00:D266: 4F 4B 45 99        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
  7842                        LBB_DO
  7843 00:D26A: 4F 9B              .byte "O",TK_DO         ; DO
  7844 00:D26C: 00                 .byte $00
  7845                        TAB_ASCE
  7846                        LBB_ELSE
  7847 00:D26D: 4C 53 45 A9        .byte "LSE",TK_ELSE     ; ELSE
  7848                        LBB_END
  7849 00:D271: 4E 44 80           .byte "ND",TK_END       ; END
  7850                        LBB_EOR
  7851 00:D274: 4F 52 B8           .byte "OR",TK_EOR       ; EOR
  7852                        LBB_EXP
  7853 00:D277: 58 50 28 C8        .byte "XP(",TK_EXP      ; EXP(
  7854                        LBB_EXIT
  7855 00:D27B: 58 49 54 A7        .byte "XIT",TK_EXIT     ; EXIT
  7856 00:D27F: 00                 .byte $00
  7857                        TAB_ASCF
  7858                        LBB_FN
  7859 00:D280: 4E AB              .byte "N",TK_FN         ; FN
  Sun Mar  3 2019 22:47                                                                                                    Page 126


  7860                        LBB_FOR
  7861 00:D282: 4F 52 81           .byte "OR",TK_FOR       ; FOR
  7862                        LBB_FRE
  7863 00:D285: 52 45 28 C3        .byte "RE(",TK_FRE      ; FRE(
  7864 00:D289: 00                 .byte $00
  7865                        TAB_ASCG
  7866                        LBB_GET
  7867 00:D28A: 45 54 A3           .byte "ET",TK_GET       ; GET
  7868                        LBB_GOSUB
  7869 00:D28D: 4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
       00:D291: 8D 
  7870                        LBB_GOTO
  7871 00:D292: 4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
  7872 00:D296: 00                 .byte $00
  7873                        TAB_ASCH
  7874                        LBB_HEXS
  7875 00:D297: 45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
       00:D29B: D7 
  7876 00:D29C: 00                 .byte $00
  7877                        TAB_ASCI
  7878                        LBB_IF
  7879 00:D29D: 46 8B              .byte "F",TK_IF         ; IF
  7880                        LBB_INC
  7881 00:D29F: 4E 43 93           .byte "NC",TK_INC       ; INC
  7882                        LBB_INPUT
  7883 00:D2A2: 4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
       00:D2A6: 84 
  7884                        LBB_INT
  7885 00:D2A7: 4E 54 28 C0        .byte "NT(",TK_INT      ; INT(
  7886 00:D2AB: 00                 .byte $00
  7887                        TAB_ASCL
  7888                        LBB_LCASES
  7889 00:D2AC: 43 41 53 45        .byte "CASE$(",TK_LCASES
       00:D2B0: 24 28 D5 
  7890                                                      ; LCASE$(
  7891                        LBB_LEFTS
  7892 00:D2B3: 45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
       00:D2B7: 28 DF 
  7893                        LBB_LEN
  7894 00:D2B9: 45 4E 28 D0        .byte "EN(",TK_LEN      ; LEN(
  7895                        LBB_LET
  7896 00:D2BD: 45 54 87           .byte "ET",TK_LET       ; LET
  7897                        LBB_LIST
  7898 00:D2C0: 49 53 54 9F        .byte "IST",TK_LIST     ; LIST
  7899                        LBB_LOAD
  7900 00:D2C4: 4F 41 44 95        .byte "OAD",TK_LOAD     ; LOAD
  7901                        LBB_LOG
  7902 00:D2C8: 4F 47 28 C7        .byte "OG(",TK_LOG      ; LOG(
  7903                        LBB_LOOP
  7904 00:D2CC: 4F 4F 50 9C        .byte "OOP",TK_LOOP     ; LOOP
  7905 00:D2D0: 00                 .byte $00
  7906                        TAB_ASCM
  7907                        LBB_MAX
  7908 00:D2D1: 41 58 28 DA        .byte "AX(",TK_MAX      ; MAX(
  7909                        LBB_MIDS
  7910 00:D2D5: 49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
       00:D2D9: E1 
  7911                        LBB_MIN
  7912 00:D2DA: 49 4E 28 DB        .byte "IN(",TK_MIN      ; MIN(
  7913 00:D2DE: 00                 .byte $00
  7914                        TAB_ASCN
  7915                        LBB_NEW
  7916 00:D2DF: 45 57 A1           .byte "EW",TK_NEW       ; NEW
  Sun Mar  3 2019 22:47                                                                                                    Page 127


  7917                        LBB_NEXT
  7918 00:D2E2: 45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
  7919                        LBB_NOT
  7920 00:D2E6: 4F 54 AE           .byte "OT",TK_NOT       ; NOT
  7921                        LBB_NULL
  7922 00:D2E9: 55 4C 4C 92        .byte "ULL",TK_NULL     ; NULL
  7923 00:D2ED: 00                 .byte $00
  7924                        TAB_ASCO
  7925                        LBB_ON
  7926 00:D2EE: 4E 91              .byte "N",TK_ON         ; ON
  7927                        LBB_OR
  7928 00:D2F0: 52 B9              .byte "R",TK_OR         ; OR
  7929 00:D2F2: 00                 .byte $00
  7930                        TAB_ASCP
  7931                        LBB_PEEK
  7932 00:D2F3: 45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
       00:D2F7: CD 
  7933                        LBB_PI
  7934 00:D2F8: 49 DC              .byte "I",TK_PI         ; PI
  7935                        LBB_POKE
  7936 00:D2FA: 4F 4B 45 98        .byte "OKE",TK_POKE     ; POKE
  7937                        LBB_POS
  7938 00:D2FE: 4F 53 28 C4        .byte "OS(",TK_POS      ; POS(
  7939                        LBB_PRINT
  7940 00:D302: 52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
       00:D306: 9D 
  7941 00:D307: 00                 .byte $00
  7942                        TAB_ASCR
  7943                        LBB_READ
  7944 00:D308: 45 41 44 86        .byte "EAD",TK_READ     ; READ
  7945                        LBB_REM
  7946 00:D30C: 45 4D 8F           .byte "EM",TK_REM       ; REM
  7947                        LBB_RESTORE
  7948 00:D30F: 45 53 54 4F        .byte "ESTORE",TK_RESTORE
       00:D313: 52 45 8C 
  7949                                                      ; RESTORE
  7950                        LBB_RETURN
  7951 00:D316: 45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
       00:D31A: 4E 8E 
  7952                        LBB_RIGHTS
  7953 00:D31C: 49 47 48 54        .byte "IGHT$(",TK_RIGHTS
       00:D320: 24 28 E0 
  7954                                                      ; RIGHT$(
  7955                        LBB_RND
  7956 00:D323: 4E 44 28 C6        .byte "ND(",TK_RND      ; RND(
  7957                        LBB_RUN
  7958 00:D327: 55 4E 8A           .byte "UN",TK_RUN       ; RUN
  7959 00:D32A: 00                 .byte $00
  7960                        TAB_ASCS
  7961                        LBB_SADD
  7962 00:D32B: 41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
       00:D32F: CF 
  7963                        LBB_SAVE
  7964 00:D330: 41 56 45 96        .byte "AVE",TK_SAVE     ; SAVE
  7965                        LBB_SGN
  7966 00:D334: 47 4E 28 BF        .byte "GN(",TK_SGN      ; SGN(
  7967                        LBB_SIN
  7968 00:D338: 49 4E 28 CA        .byte "IN(",TK_SIN      ; SIN(
  7969                        LBB_SPC
  7970 00:D33C: 50 43 28 AC        .byte "PC(",TK_SPC      ; SPC(
  7971                        LBB_SQR
  7972 00:D340: 51 52 28 C5        .byte "QR(",TK_SQR      ; SQR(
  7973                        LBB_STEP
  Sun Mar  3 2019 22:47                                                                                                    Page 128


  7974 00:D344: 54 45 50 AF        .byte "TEP",TK_STEP     ; STEP
  7975                        LBB_STOP
  7976 00:D348: 54 4F 50 90        .byte "TOP",TK_STOP     ; STOP
  7977                        LBB_STRS
  7978 00:D34C: 54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
       00:D350: D1 
  7979                        LBB_SWAP
  7980 00:D351: 57 41 50 A4        .byte "WAP",TK_SWAP     ; SWAP
  7981 00:D355: 00                 .byte $00
  7982                        TAB_ASCT
  7983                        LBB_TAB
  7984 00:D356: 41 42 28 A8        .byte "AB(",TK_TAB      ; TAB(
  7985                        LBB_TAN
  7986 00:D35A: 41 4E 28 CB        .byte "AN(",TK_TAN      ; TAN(
  7987                        LBB_THEN
  7988 00:D35E: 48 45 4E AD        .byte "HEN",TK_THEN     ; THEN
  7989                        LBB_TO
  7990 00:D362: 4F AA              .byte "O",TK_TO         ; TO
  7991                        LBB_TWOPI
  7992 00:D364: 57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
       00:D368: DD 
  7993 00:D369: 00                 .byte $00
  7994                        TAB_ASCU
  7995                        LBB_UCASES
  7996 00:D36A: 43 41 53 45        .byte "CASE$(",TK_UCASES
       00:D36E: 24 28 D4 
  7997                                                      ; UCASE$(
  7998                        LBB_UNTIL
  7999 00:D371: 4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
       00:D375: B0 
  8000                        LBB_USR
  8001 00:D376: 53 52 28 C2        .byte "SR(",TK_USR      ; USR(
  8002 00:D37A: 00                 .byte $00
  8003                        TAB_ASCV
  8004                        LBB_VAL
  8005 00:D37B: 41 4C 28 D2        .byte "AL(",TK_VAL      ; VAL(
  8006                        LBB_VPTR
  8007 00:D37F: 41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
       00:D383: 52 28 DE 
  8008 00:D386: 00                 .byte $00
  8009                        TAB_ASCW
  8010                        LBB_WAIT
  8011 00:D387: 41 49 54 94        .byte "AIT",TK_WAIT     ; WAIT
  8012                        LBB_WHILE
  8013 00:D38B: 48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
       00:D38F: B1 
  8014                        LBB_WIDTH
  8015 00:D390: 49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
       00:D394: A2 
  8016 00:D395: 00                 .byte $00
  8017                        TAB_POWR
  8018 00:D396: B6 00              .byte TK_POWER,$00      ; ^
  8019                        
  8020                        ; new decode table for LIST
  8021                        ; Table is ..
  8022                        ; byte - keyword length, keyword first character
  8023                        ; word - pointer to rest of keyword from dictionary
  8024                        
  8025                        ; note if length is 1 then the pointer is ignored
  8026                        
  8027                        LAB_KEYT
  8028 00:D398: 03 45              .byte 3,'E'
  8029 00:D39A: 71 D2              .word LBB_END           ; END
  Sun Mar  3 2019 22:47                                                                                                    Page 129


  8030 00:D39C: 03 46              .byte 3,'F'
  8031 00:D39E: 82 D2              .word LBB_FOR           ; FOR
  8032 00:D3A0: 04 4E              .byte 4,'N'
  8033 00:D3A2: E2 D2              .word LBB_NEXT          ; NEXT
  8034 00:D3A4: 04 44              .byte 4,'D'
  8035 00:D3A6: 54 D2              .word LBB_DATA          ; DATA
  8036 00:D3A8: 05 49              .byte 5,'I'
  8037 00:D3AA: A2 D2              .word LBB_INPUT         ; INPUT
  8038 00:D3AC: 03 44              .byte 3,'D'
  8039 00:D3AE: 63 D2              .word LBB_DIM           ; DIM
  8040 00:D3B0: 04 52              .byte 4,'R'
  8041 00:D3B2: 08 D3              .word LBB_READ          ; READ
  8042 00:D3B4: 03 4C              .byte 3,'L'
  8043 00:D3B6: BD D2              .word LBB_LET           ; LET
  8044 00:D3B8: 03 44              .byte 3,'D'
  8045 00:D3BA: 58 D2              .word LBB_DEC           ; DEC
  8046 00:D3BC: 04 47              .byte 4,'G'
  8047 00:D3BE: 92 D2              .word LBB_GOTO          ; GOTO
  8048 00:D3C0: 03 52              .byte 3,'R'
  8049 00:D3C2: 27 D3              .word LBB_RUN           ; RUN
  8050 00:D3C4: 02 49              .byte 2,'I'
  8051 00:D3C6: 9D D2              .word LBB_IF            ; IF
  8052 00:D3C8: 07 52              .byte 7,'R'
  8053 00:D3CA: 0F D3              .word LBB_RESTORE       ; RESTORE
  8054 00:D3CC: 05 47              .byte 5,'G'
  8055 00:D3CE: 8D D2              .word LBB_GOSUB         ; GOSUB
  8056 00:D3D0: 06 52              .byte 6,'R'
  8057 00:D3D2: 16 D3              .word LBB_RETURN        ; RETURN
  8058 00:D3D4: 03 52              .byte 3,'R'
  8059 00:D3D6: 0C D3              .word LBB_REM           ; REM
  8060 00:D3D8: 04 53              .byte 4,'S'
  8061 00:D3DA: 48 D3              .word LBB_STOP          ; STOP
  8062 00:D3DC: 02 4F              .byte 2,'O'
  8063 00:D3DE: EE D2              .word LBB_ON            ; ON
  8064 00:D3E0: 04 4E              .byte 4,'N'
  8065 00:D3E2: E9 D2              .word LBB_NULL          ; NULL
  8066 00:D3E4: 03 49              .byte 3,'I'
  8067 00:D3E6: 9F D2              .word LBB_INC           ; INC
  8068 00:D3E8: 04 57              .byte 4,'W'
  8069 00:D3EA: 87 D3              .word LBB_WAIT          ; WAIT
  8070 00:D3EC: 04 4C              .byte 4,'L'
  8071 00:D3EE: C4 D2              .word LBB_LOAD          ; LOAD
  8072 00:D3F0: 04 53              .byte 4,'S'
  8073 00:D3F2: 30 D3              .word LBB_SAVE          ; SAVE
  8074 00:D3F4: 03 44              .byte 3,'D'
  8075 00:D3F6: 60 D2              .word LBB_DEF           ; DEF
  8076 00:D3F8: 04 50              .byte 4,'P'
  8077 00:D3FA: FA D2              .word LBB_POKE          ; POKE
  8078 00:D3FC: 04 44              .byte 4,'D'
  8079 00:D3FE: 66 D2              .word LBB_DOKE          ; DOKE
  8080 00:D400: 04 43              .byte 4,'C'
  8081 00:D402: 3D D2              .word LBB_CALL          ; CALL
  8082 00:D404: 02 44              .byte 2,'D'
  8083 00:D406: 6A D2              .word LBB_DO            ; DO
  8084 00:D408: 04 4C              .byte 4,'L'
  8085 00:D40A: CC D2              .word LBB_LOOP          ; LOOP
  8086 00:D40C: 05 50              .byte 5,'P'
  8087 00:D40E: 02 D3              .word LBB_PRINT         ; PRINT
  8088 00:D410: 04 43              .byte 4,'C'
  8089 00:D412: 4B D2              .word LBB_CONT          ; CONT
  8090 00:D414: 04 4C              .byte 4,'L'
  8091 00:D416: C0 D2              .word LBB_LIST          ; LIST
  8092 00:D418: 05 43              .byte 5,'C'
  Sun Mar  3 2019 22:47                                                                                                    Page 130


  8093 00:D41A: 46 D2              .word LBB_CLEAR         ; CLEAR
  8094 00:D41C: 03 4E              .byte 3,'N'
  8095 00:D41E: DF D2              .word LBB_NEW           ; NEW
  8096 00:D420: 05 57              .byte 5,'W'
  8097 00:D422: 90 D3              .word LBB_WIDTH         ; WIDTH
  8098 00:D424: 03 47              .byte 3,'G'
  8099 00:D426: 8A D2              .word LBB_GET           ; GET
  8100 00:D428: 04 53              .byte 4,'S'
  8101 00:D42A: 51 D3              .word LBB_SWAP          ; SWAP
  8102 00:D42C: 06 42              .byte 6,'B'
  8103 00:D42E: 2F D2              .word LBB_BITSET        ; BITSET
  8104 00:D430: 06 42              .byte 6,'B'
  8105 00:D432: 29 D2              .word LBB_BITCLR        ; BITCLR
  8106 00:D434: 04 45              .byte 4,"E"
  8107 00:D436: 7B D2              .word LBB_EXIT          ; EXIT
  8108                        
  8109                        ; secondary commands (can't start a statement)
  8110                        
  8111 00:D438: 04 54              .byte 4,'T'
  8112 00:D43A: 56 D3              .word LBB_TAB           ; TAB
  8113 00:D43C: 04 45              .byte 4,'E'
  8114 00:D43E: 6D D2              .word LBB_ELSE          ; ELSE
  8115 00:D440: 02 54              .byte 2,'T'
  8116 00:D442: 62 D3              .word LBB_TO            ; TO
  8117 00:D444: 02 46              .byte 2,'F'
  8118 00:D446: 80 D2              .word LBB_FN            ; FN
  8119 00:D448: 04 53              .byte 4,'S'
  8120 00:D44A: 3C D3              .word LBB_SPC           ; SPC
  8121 00:D44C: 04 54              .byte 4,'T'
  8122 00:D44E: 5E D3              .word LBB_THEN          ; THEN
  8123 00:D450: 03 4E              .byte 3,'N'
  8124 00:D452: E6 D2              .word LBB_NOT           ; NOT
  8125 00:D454: 04 53              .byte 4,'S'
  8126 00:D456: 44 D3              .word LBB_STEP          ; STEP
  8127 00:D458: 05 55              .byte 5,'U'
  8128 00:D45A: 71 D3              .word LBB_UNTIL         ; UNTIL
  8129 00:D45C: 05 57              .byte 5,'W'
  8130 00:D45E: 8B D3              .word LBB_WHILE         ; WHILE
  8131                        
  8132                        ; opperators
  8133                        
  8134 00:D460: 01 2B              .byte 1,'+'
  8135 00:D462: 00 00              .word $0000             ; +
  8136 00:D464: 01 2D              .byte 1,'-'
  8137 00:D466: 00 00              .word $0000             ; -
  8138 00:D468: 01 2A              .byte 1,'*'
  8139 00:D46A: 00 00              .word $0000             ; *
  8140 00:D46C: 01 2F              .byte 1,'/'
  8141 00:D46E: 00 00              .word $0000             ; /
  8142 00:D470: 01 5E              .byte 1,'^'
  8143 00:D472: 00 00              .word $0000             ; ^
  8144 00:D474: 03 41              .byte 3,'A'
  8145 00:D476: 18 D2              .word LBB_AND           ; AND
  8146 00:D478: 03 45              .byte 3,'E'
  8147 00:D47A: 74 D2              .word LBB_EOR           ; EOR
  8148 00:D47C: 02 4F              .byte 2,'O'
  8149 00:D47E: F0 D2              .word LBB_OR            ; OR
  8150 00:D480: 02 3E              .byte 2,'>'
  8151 00:D482: 0E D2              .word LBB_RSHIFT        ; >>
  8152 00:D484: 02 3C              .byte 2,'<'
  8153 00:D486: 08 D2              .word LBB_LSHIFT        ; <<
  8154 00:D488: 01 3E              .byte 1,'>'
  8155 00:D48A: 00 00              .word $0000             ; >
  Sun Mar  3 2019 22:47                                                                                                    Page 131


  8156 00:D48C: 01 3D              .byte 1,'='
  8157 00:D48E: 00 00              .word $0000             ; =
  8158 00:D490: 01 3C              .byte 1,'<'
  8159 00:D492: 00 00              .word $0000             ; <
  8160                        
  8161                        ; functions
  8162                        
  8163 00:D494: 04 53              .byte 4,'S'             ;
  8164 00:D496: 34 D3              .word LBB_SGN           ; SGN
  8165 00:D498: 04 49              .byte 4,'I'             ;
  8166 00:D49A: A7 D2              .word LBB_INT           ; INT
  8167 00:D49C: 04 41              .byte 4,'A'             ;
  8168 00:D49E: 14 D2              .word LBB_ABS           ; ABS
  8169 00:D4A0: 04 55              .byte 4,'U'             ;
  8170 00:D4A2: 76 D3              .word LBB_USR           ; USR
  8171 00:D4A4: 04 46              .byte 4,'F'             ;
  8172 00:D4A6: 85 D2              .word LBB_FRE           ; FRE
  8173 00:D4A8: 04 50              .byte 4,'P'             ;
  8174 00:D4AA: FE D2              .word LBB_POS           ; POS
  8175 00:D4AC: 04 53              .byte 4,'S'             ;
  8176 00:D4AE: 40 D3              .word LBB_SQR           ; SQR
  8177 00:D4B0: 04 52              .byte 4,'R'             ;
  8178 00:D4B2: 23 D3              .word LBB_RND           ; RND
  8179 00:D4B4: 04 4C              .byte 4,'L'             ;
  8180 00:D4B6: C8 D2              .word LBB_LOG           ; LOG
  8181 00:D4B8: 04 45              .byte 4,'E'             ;
  8182 00:D4BA: 77 D2              .word LBB_EXP           ; EXP
  8183 00:D4BC: 04 43              .byte 4,'C'             ;
  8184 00:D4BE: 4F D2              .word LBB_COS           ; COS
  8185 00:D4C0: 04 53              .byte 4,'S'             ;
  8186 00:D4C2: 38 D3              .word LBB_SIN           ; SIN
  8187 00:D4C4: 04 54              .byte 4,'T'             ;
  8188 00:D4C6: 5A D3              .word LBB_TAN           ; TAN
  8189 00:D4C8: 04 41              .byte 4,'A'             ;
  8190 00:D4CA: 1F D2              .word LBB_ATN           ; ATN
  8191 00:D4CC: 05 50              .byte 5,'P'             ;
  8192 00:D4CE: F3 D2              .word LBB_PEEK          ; PEEK
  8193 00:D4D0: 05 44              .byte 5,'D'             ;
  8194 00:D4D2: 5B D2              .word LBB_DEEK          ; DEEK
  8195 00:D4D4: 05 53              .byte 5,'S'             ;
  8196 00:D4D6: 2B D3              .word LBB_SADD          ; SADD
  8197 00:D4D8: 04 4C              .byte 4,'L'             ;
  8198 00:D4DA: B9 D2              .word LBB_LEN           ; LEN
  8199 00:D4DC: 05 53              .byte 5,'S'             ;
  8200 00:D4DE: 4C D3              .word LBB_STRS          ; STR$
  8201 00:D4E0: 04 56              .byte 4,'V'             ;
  8202 00:D4E2: 7B D3              .word LBB_VAL           ; VAL
  8203 00:D4E4: 04 41              .byte 4,'A'             ;
  8204 00:D4E6: 1B D2              .word LBB_ASC           ; ASC
  8205 00:D4E8: 07 55              .byte 7,'U'             ;
  8206 00:D4EA: 6A D3              .word LBB_UCASES        ; UCASE$
  8207 00:D4EC: 07 4C              .byte 7,'L'             ;
  8208 00:D4EE: AC D2              .word LBB_LCASES        ; LCASE$
  8209 00:D4F0: 05 43              .byte 5,'C'             ;
  8210 00:D4F2: 41 D2              .word LBB_CHRS          ; CHR$
  8211 00:D4F4: 05 48              .byte 5,'H'             ;
  8212 00:D4F6: 97 D2              .word LBB_HEXS          ; HEX$
  8213 00:D4F8: 05 42              .byte 5,'B'             ;
  8214 00:D4FA: 24 D2              .word LBB_BINS          ; BIN$
  8215 00:D4FC: 07 42              .byte 7,'B'             ;
  8216 00:D4FE: 35 D2              .word LBB_BITTST        ; BITTST
  8217 00:D500: 04 4D              .byte 4,'M'             ;
  8218 00:D502: D1 D2              .word LBB_MAX           ; MAX
  Sun Mar  3 2019 22:47                                                                                                    Page 132


  8219 00:D504: 04 4D              .byte 4,'M'             ;
  8220 00:D506: DA D2              .word LBB_MIN           ; MIN
  8221 00:D508: 02 50              .byte 2,'P'             ;
  8222 00:D50A: F8 D2              .word LBB_PI            ; PI
  8223 00:D50C: 05 54              .byte 5,'T'             ;
  8224 00:D50E: 64 D3              .word LBB_TWOPI         ; TWOPI
  8225 00:D510: 07 56              .byte 7,'V'             ;
  8226 00:D512: 7F D3              .word LBB_VPTR          ; VARPTR
  8227 00:D514: 06 4C              .byte 6,'L'             ;
  8228 00:D516: B3 D2              .word LBB_LEFTS         ; LEFT$
  8229 00:D518: 07 52              .byte 7,'R'             ;
  8230 00:D51A: 1C D3              .word LBB_RIGHTS        ; RIGHT$
  8231 00:D51C: 05 4D              .byte 5,'M'             ;
  8232 00:D51E: D5 D2              .word LBB_MIDS          ; MID$
  8233                        
  8234                        ; BASIC messages, mostly error messages
  8235                        
  8236                        LAB_BAER
  8237 00:D520: 44 D5              .word ERR_NF            ;$00 NEXT without FOR
  8238 00:D522: 55 D5              .word ERR_SN            ;$02 syntax
  8239 00:D524: 5C D5              .word ERR_RG            ;$04 RETURN without GOSUB
  8240 00:D526: 71 D5              .word ERR_OD            ;$06 out of data
  8241 00:D528: 7D D5              .word ERR_FC            ;$08 function call
  8242 00:D52A: 8B D5              .word ERR_OV            ;$0A overflow
  8243 00:D52C: 94 D5              .word ERR_OM            ;$0C out of memory
  8244 00:D52E: A2 D5              .word ERR_US            ;$0E undefined statement
  8245 00:D530: B6 D5              .word ERR_BS            ;$10 array bounds
  8246 00:D532: C3 D5              .word ERR_DD            ;$12 double dimension array
  8247 00:D534: D4 D5              .word ERR_D0            ;$14 divide by 0
  8248 00:D536: E3 D5              .word ERR_ID            ;$16 illegal direct
  8249 00:D538: F2 D5              .word ERR_TM            ;$18 type mismatch
  8250 00:D53A: 00 D6              .word ERR_LS            ;$1A long string
  8251 00:D53C: 10 D6              .word ERR_ST            ;$1C string too complex
  8252 00:D53E: 23 D6              .word ERR_CN            ;$1E continue error
  8253 00:D540: 32 D6              .word ERR_UF            ;$20 undefined function
  8254 00:D542: 45 D6              .word ERR_LD            ;$22 LOOP without DO
  8255                        
  8256                        ; I may implement these two errors to force definition of variables and
  8257                        ; dimensioning of arrays before use.
  8258                        
  8259                        ;     .word ERR_UV            ;$24 undefined variable
  8260                        
  8261                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8262                        
  8263                        ;     .word ERR_UA            ;$26 undimensioned array
  8264                        
  8265 00:D544: 4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
       00:D548: 20 77 69 74 
       00:D54C: 68 6F 75 74 
       00:D550: 20 46 4F 52 
       00:D554: 00 
  8266 00:D555: 53 79 6E 74  ERR_SN      .byte "Syntax",$00
       00:D559: 61 78 00 
  8267 00:D55C: 52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
       00:D560: 52 4E 20 77 
       00:D564: 69 74 68 6F 
       00:D568: 75 74 20 47 
       00:D56C: 4F 53 55 42 
       00:D570: 00 
  8268 00:D571: 4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
       00:D575: 6F 66 20 44 
       00:D579: 41 54 41 00 
  8269 00:D57D: 46 75 6E 63  ERR_FC      .byte "Function call",$00
  Sun Mar  3 2019 22:47                                                                                                    Page 133


       00:D581: 74 69 6F 6E 
       00:D585: 20 63 61 6C 
       00:D589: 6C 00 
  8270 00:D58B: 4F 76 65 72  ERR_OV      .byte "Overflow",$00
       00:D58F: 66 6C 6F 77 
       00:D593: 00 
  8271 00:D594: 4F 75 74 20  ERR_OM      .byte "Out of memory",$00
       00:D598: 6F 66 20 6D 
       00:D59C: 65 6D 6F 72 
       00:D5A0: 79 00 
  8272 00:D5A2: 55 6E 64 65  ERR_US      .byte "Undefined statement",$00
       00:D5A6: 66 69 6E 65 
       00:D5AA: 64 20 73 74 
       00:D5AE: 61 74 65 6D 
       00:D5B2: 65 6E 74 00 
  8273 00:D5B6: 41 72 72 61  ERR_BS      .byte "Array bounds",$00
       00:D5BA: 79 20 62 6F 
       00:D5BE: 75 6E 64 73 
       00:D5C2: 00 
  8274 00:D5C3: 44 6F 75 62  ERR_DD      .byte "Double dimension",$00
       00:D5C7: 6C 65 20 64 
       00:D5CB: 69 6D 65 6E 
       00:D5CF: 73 69 6F 6E 
       00:D5D3: 00 
  8275 00:D5D4: 44 69 76 69  ERR_D0      .byte "Divide by zero",$00
       00:D5D8: 64 65 20 62 
       00:D5DC: 79 20 7A 65 
       00:D5E0: 72 6F 00 
  8276 00:D5E3: 49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
       00:D5E7: 67 61 6C 20 
       00:D5EB: 64 69 72 65 
       00:D5EF: 63 74 00 
  8277 00:D5F2: 54 79 70 65  ERR_TM      .byte "Type mismatch",$00
       00:D5F6: 20 6D 69 73 
       00:D5FA: 6D 61 74 63 
       00:D5FE: 68 00 
  8278 00:D600: 53 74 72 69  ERR_LS      .byte "String too long",$00
       00:D604: 6E 67 20 74 
       00:D608: 6F 6F 20 6C 
       00:D60C: 6F 6E 67 00 
  8279 00:D610: 53 74 72 69  ERR_ST      .byte "String too complex",$00
       00:D614: 6E 67 20 74 
       00:D618: 6F 6F 20 63 
       00:D61C: 6F 6D 70 6C 
       00:D620: 65 78 00 
  8280 00:D623: 43 61 6E 27  ERR_CN      .byte "Can't continue",$00
       00:D627: 74 20 63 6F 
       00:D62B: 6E 74 69 6E 
       00:D62F: 75 65 00 
  8281 00:D632: 55 6E 64 65  ERR_UF      .byte "Undefined function",$00
       00:D636: 66 69 6E 65 
       00:D63A: 64 20 66 75 
       00:D63E: 6E 63 74 69 
       00:D642: 6F 6E 00 
  8282 00:D645: 4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
       00:D649: 20 77 69 74 
       00:D64D: 68 6F 75 74 
       00:D651: 20 44 4F 00 
  8283                        
  8284                        ;ERR_UV     .byte "Undefined variable",$00
  8285                        
  8286                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8287                        
  Sun Mar  3 2019 22:47                                                                                                    Page 134


  8288                        ;ERR_UA     .byte "Undimensioned array",$00
  8289                        
  8290 00:D655: 0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
       00:D659: 65 61 6B 00 
  8291 00:D65D: 20 45 72 72  LAB_EMSG    .byte " Error",$00
       00:D661: 6F 72 00 
  8292 00:D664: 20 69 6E 20  LAB_LMSG    .byte " in line ",$00
       00:D668: 6C 69 6E 65 
       00:D66C: 20 00 
  8293 00:D66E: 0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
       00:D672: 61 64 79 0D 
       00:D676: 0A 00 
  8294                        
  8295 00:D678: 20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
       00:D67C: 72 61 20 69 
       00:D680: 67 6E 6F 72 
       00:D684: 65 64 0D 0A 
       00:D688: 00 
  8296 00:D689: 20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
       00:D68D: 6F 20 66 72 
       00:D691: 6F 6D 20 73 
       00:D695: 74 61 72 74 
       00:D699: 0D 0A 00 
  8297                        
  8298                         .END


      Lines assembled: 8298
      Errors: 0
