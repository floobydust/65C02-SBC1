  Sun Mar  3 2019 23:01                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;
     2                        ;***************************************************
     3                        ;*  C02Monitor 1.4 (c)2013-2017 by Kevin E. Maier  *
     4                        ;*    Extendable BIOS and Monitor for 65C02 CPU    *
     5                        ;*                                                 *
     6                        ;* Basic functions include:                        *
     7                        ;*  - Byte/Text memory search                      *
     8                        ;*  - CPU register display/modify                  *
     9                        ;*  - Memory fill, move, compare, examine/edit     *
    10                        ;*  - Xmodem/CRC Loader with S-Record support      *
    11                        ;*  - Input buffer Macro utility up to 127 bytes   *
    12                        ;*  - EEPROM Program utility (Atmel Byte-write)    *
    13                        ;*  - RTC via 65C22 showing time since boot        *
    14                        ;*  - 1ms timer delay via 65C22                    *
    15                        ;*  - Table-driven Disassembler for W65C02S        *
    16                        ;*  - Monitor space increased for future expansion *
    17                        ;*  - Monitor version change to match BIOS version *
    18                        ;*  - Added Loop Counter for Macro operation       *
    19                        ;*                                                 *
    20                        ;*                  07/11/17 KM                    *
    21                        ;*   Uses <6KB EEPROM - JMP table page at $FF00    *
    22                        ;*     Uses one page for I/O: default at $FE00     *
    23                        ;*         Default assembly start at $E000:        *
    24                        ;*                                                 *
    25                        ;*  C02BIOS 1.4 (c)2013-2017 by Kevin E. Maier     *
    26                        ;*  - BIOS in pages $F8-$FD, $FF                   *
    27                        ;*  - Full duplex interrupt-driven/buffered I/O    *
    28                        ;*  - extendable BIOS structure with soft vectors  *
    29                        ;*  - soft config parameters for all I/O devices   *
    30                        ;*  - monitor cold/warm start soft vectored        *
    31                        ;*  - fully relocatable code (sans page $FF)       *
    32                        ;*  - precision timer services 1ms accuracy        *
    33                        ;*  - delays from 1ms to 49.71 days                *
    34                        ;*  - basic port services for 6522 VIA             *
    35                        ;*  - moved BEEP to main Monitor, CHRIN_NW in BIOS *
    36                        ;*  - BIOS space increased for future expansion    *
    37                        ;*                                                 * 
    38                        ;*   Note default HW system memory map as:         *
    39                        ;*         RAM - $0000 - $7FFF                     *
    40                        ;*         ROM - $8000 - $FDFF                     *
    41                        ;*         I/O - $FE00 - $FEFF                     *
    42                        ;*         ROM - $FF00 - $FFFF                     *
    43                        ;*                                                 *
    44                        ;***************************************************
    45                        ;
    46                        	PL	66	;Page Length
    47                        	PW	132	;Page Width (# of char/line)
    48                        	CHIP	W65C02S	;Enable WDC 65C02 instructions
    49                        	PASS1	OFF	;Set ON when used for debug
    50                        ;
    51                        ;******************************************************************************
    52                        ;*************************
    53                        ;* Page Zero definitions *
    54                        ;*************************
    55                        ;Reserved from $00 to $AF for user routines
    56                        ;NOTES:
    57                        ;	locations $00 and $01 are used to zero RAM (calls CPU reset)
  Sun Mar  3 2019 23:01                                                                                                    Page 2


    58                        ;	EEPROM Byte Write routine loaded into Page Zero at $00-$14
    59                        ;
    60             000000B0   PGZERO_ST	.EQU	$B0	;Start of Page Zero usage
    61                        ;
    62                        ;	Page Zero Buffers used by the default Monitor code
    63                        ; - Two buffers are required;
    64                        ;	DATABUFF is used by the HEX2ASC routine (6 bytes)
    65                        ;	INBUFF is used by RDLINE routine (4 bytes)
    66             000000B0   BUFF_PG0	.EQU	PGZERO_ST	;Default Page zero location for Monitor buffers
    67                        ;
    68                        ;INBUFF is used for conversion from 4 HEX characters to a 16-bit address
    69             000000B0   INBUFF		.EQU	BUFF_PG0	;4 bytes ($B0-$B3)
    70                        ;
    71                        ;DATABUFF is used for conversion of 16-bit binary to ASCII decimal output
    72                        ; note string is terminated by null character
    73             000000B4   DATABUFF	.EQU	BUFF_PG0+4	;6 bytes ($B4-$B9)
    74                        ;
    75                        ;16-bit variables:
    76             000000BA   HEXDATAH	.EQU	PGZERO_ST+10	;Hexadecimal input
    77             000000BB   HEXDATAL	.EQU	PGZERO_ST+11
    78             000000BC   BINVALL		.EQU	PGZERO_ST+12	;Binary Value for HEX2ASC
    79             000000BD   BINVALH		.EQU	PGZERO_ST+13
    80             000000BE   COMLO			.EQU	PGZERO_ST+14	;User command address
    81             000000BF   COMHI			.EQU	PGZERO_ST+15
    82             000000C0   INDEXL		.EQU	PGZERO_ST+16	;Index for address - multiple routines
    83             000000C1   INDEXH		.EQU	PGZERO_ST+17
    84             000000C2   TEMP1L		.EQU	PGZERO_ST+18	;Index for word temp value used by Memdump
    85             000000C3   TEMP1H		.EQU	PGZERO_ST+19
    86             000000C4   TEMP2L		.EQU	PGZERO_ST+20	;Index for Text entry
    87             000000C5   TEMP2H		.EQU	PGZERO_ST+21
    88             000000C6   PROMPTL		.EQU	PGZERO_ST+22	;Prompt string address
    89             000000C7   PROMPTH		.EQU	PGZERO_ST+23
    90             000000C8   SRCL			.EQU	PGZERO_ST+24	;Source address for memory operations
    91             000000C9   SRCH			.EQU	PGZERO_ST+25
    92             000000CA   TGTL			.EQU	PGZERO_ST+26	;Target address for memory operations
    93             000000CB   TGTH			.EQU	PGZERO_ST+27
    94             000000CC   LENL			.EQU	PGZERO_ST+28	;Length address for memory operations
    95             000000CD   LENH			.EQU	PGZERO_ST+29
    96                        ;
    97                        ;8-bit variables and constants:
    98             000000CE   BUFIDX		.EQU	PGZERO_ST+30	;Buffer index
    99             000000CF   BUFLEN		.EQU	PGZERO_ST+31	;Buffer length
   100             000000D0   IDX				.EQU	PGZERO_ST+32	;Temp Indexing
   101             000000D1   IDY				.EQU	PGZERO_ST+33	;Temp Indexing
   102             000000D2   TEMP1			.EQU	PGZERO_ST+34	;Temp - Code Conversion routines
   103             000000D3   TEMP2			.EQU	PGZERO_ST+35	;Temp - Memory/EEPROM/SREC routines - Disassembler
   104             000000D4   TEMP3			.EQU	PGZERO_ST+36	;Temp - EEPROM/SREC routines
   105             000000D5   CMDFLAG		.EQU	PGZERO_ST+37	;Command Flag - used by RDLINE & others
   106             000000D6   OPCODE		.EQU	PGZERO_ST+38	;Saved Opcode
   107                        ;
   108                        ;Xmodem transfer variables
   109             000000D7   CRCHI			.EQU	PGZERO_ST+39	;CRC hi byte  (two byte variable)
   110             000000D8   CRCLO			.EQU	PGZERO_ST+40	;CRC lo byte - Operand in Disassembler
   111             000000D9   CRCCNT		.EQU	PGZERO_ST+41	;CRC retry count - Operand in Disassembler
   112                        ;
   113             000000DA   PTRL			.EQU	PGZERO_ST+42	;Data pointer lo byte - Mnemonic in Disassembler
   114             000000DB   PTRH			.EQU	PGZERO_ST+43	;Data pointer hi byte - Mnemonic in Disassembler
   115             000000DC   BLKNO			.EQU	PGZERO_ST+44	;Block number
   116             000000DD   LPCNTL		.EQU	PGZERO_ST+45	;Loop Count low byte
   117             000000DE   LPCNTH		.EQU	PGZERO_ST+46	;Loop Count high byte
   118             000000DF   LPCNTF		.EQU	PGZERO_ST+47	;Loop Count flag byte
   119                        ;
   120                        ;	BIOS variables, pointers, flags located at top of Page Zero.
  Sun Mar  3 2019 23:01                                                                                                    Page 3


   121             000000E0   BIOS_PG0	.EQU	$E0	;PGZERO_ST+96	;Start of BIOS page zero use ($E0-$FF)
   122                        ;	- BRK handler routine
   123             000000E0   PCL				.EQU	BIOS_PG0+0	;Program Counter Low index
   124             000000E1   PCH				.EQU	BIOS_PG0+1	;Program Counter High index
   125             000000E2   PREG			.EQU	BIOS_PG0+2	;Temp Status reg
   126             000000E3   SREG			.EQU	BIOS_PG0+3	;Temp Stack ptr
   127             000000E4   YREG			.EQU	BIOS_PG0+4	;Temp Y reg
   128             000000E5   XREG			.EQU	BIOS_PG0+5	;Temp X reg
   129             000000E6   AREG			.EQU	BIOS_PG0+6	;Temp A reg
   130                        ;
   131                        ;	- 6551 IRQ handler pointers and status
   132             000000E7   ICNT			.EQU	BIOS_PG0+7	;Input buffer count
   133             000000E8   IHEAD			.EQU	BIOS_PG0+8	;Input buffer head pointer
   134             000000E9   ITAIL			.EQU	BIOS_PG0+9	;Input buffer tail pointer
   135             000000EA   OCNT			.EQU	BIOS_PG0+10	;Output buffer count
   136             000000EB   OHEAD			.EQU	BIOS_PG0+11	;Output buffer head pointer
   137             000000EC   OTAIL			.EQU	BIOS_PG0+12	;Output buffer tail pointer
   138             000000ED   STTVAL		.EQU	BIOS_PG0+13	;6551 BIOS status byte
   139                        ;
   140                        ;	- Real-Time Clock variables
   141             000000EE   TICKS			.EQU	BIOS_PG0+14	;# timer countdowns for 1 second (250)
   142             000000EF   SECS			.EQU	BIOS_PG0+15	;Seconds: 0-59
   143             000000F0   MINS			.EQU	BIOS_PG0+16	;Minutes: 0-59
   144             000000F1   HOURS			.EQU	BIOS_PG0+17	;Hours: 0-23
   145             000000F2   DAYSL			.EQU	BIOS_PG0+18	;Days: (2 bytes) 0-65535 >179 years
   146             000000F3   DAYSH			.EQU	BIOS_PG0+19	;High order byte
   147                        ;
   148                        ;	- Delay Timer variables
   149             000000F4   MSDELAY		.EQU	BIOS_PG0+20	;Timer delay countdown byte (255 > 0)
   150             000000F5   MATCH			.EQU	BIOS_PG0+21	;Delay Match flag, $FF is set, $00 is cleared
   151             000000F6   SETIM			.EQU	BIOS_PG0+22	;Set timeout for delay routines - BIOS use only
   152             000000F7   DELLO			.EQU	BIOS_PG0+23	;Delay value BIOS use only
   153             000000F8   DELHI			.EQU	BIOS_PG0+24	;Delay value BIOS use only
   154             000000F9   XDL				.EQU	BIOS_PG0+25	;XL Delay count
   155             000000FA   STVVAL		.EQU	BIOS_PG0+26	;Status for VIA IRQ flags
   156                        ;
   157                        ;	- I/O port variables
   158             000000FB   IO_DIR		.EQU	BIOS_PG0+27	;I/O port direction temp
   159             000000FC   IO_IN			.EQU	BIOS_PG0+28	;I/O port Input temp
   160             000000FD   IO_OUT		.EQU	BIOS_PG0+29	;I/O port Output temp
   161                        ;
   162                        ; - Xmodem variables
   163             000000FE   XMFLAG		.EQU	BIOS_PG0+30	;Xmodem transfer active flag
   164             000000FF   SPARE_B0	.EQU	BIOS_PG0+31	;Spare BIOS page zero byte
   165                        ;
   166                        ;******************************************************************************
   167                        ;Character input buffer address: $0200-$027F - 128 bytes
   168                        ;Character output buffer address: $0280-$02FF - 128 bytes
   169                        ;Managed by full-duplex IRQ service routine
   170                        ;
   171             00000200   IBUF			.EQU	$0200	;INPUT BUFFER  128 BYTES - BIOS use only
   172             00000280   OBUF			.EQU	$0280	;OUTPUT BUFFER 128 BYTES - BIOS use only
   173                        ;
   174                        ;******************************************************************************
   175             00000300   SOFTVEC		.EQU	$0300	;Start of soft vectors
   176                        ;
   177                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM
   178                        ; The soft vectors are structured to allow inserting additional routines either before
   179                        ; or after the core routines. This allows flexibility and changing of routine priority
   180                        ;
   181                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   182                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   183                        ; returns to the ROM handler for each. The following 2 vectors are the cold and warm
  Sun Mar  3 2019 23:01                                                                                                    Page 4


   184                        ; entry points for the Monitor. After the basic initialization, the monitor is entered
   185                        ;
   186                        ;The following vector set allows inserts for any of the above vectors
   187                        ; there are a total of 8 Inserts which occupy 16 bytes. They can be used as required
   188                        ; note that the first two are used for the 6522 timer routines
   189                        ;
   190             00000300   NMIVEC0		.EQU	SOFTVEC	;NMI Interrupt Vector 0
   191             00000302   BRKVEC0		.EQU	SOFTVEC+2	;BRK Interrupt Vector 0
   192             00000304   IRQVEC0		.EQU	SOFTVEC+4	;INTERRUPT VECTOR 0
   193                        ;
   194             00000306   NMIRTVEC0	.EQU	SOFTVEC+6	;NMI Return Handler 0
   195             00000308   BRKRTVEC0	.EQU	SOFTVEC+8	;BRK Return Handler 0
   196             0000030A   IRQRTVEC0	.EQU	SOFTVEC+10	;IRQ Return Handler 0
   197                        ;
   198             0000030C   CLDMNVEC0	.EQU	SOFTVEC+12	;Cold Monitor Entry Vector 0
   199             0000030E   WRMMNVEC0	.EQU	SOFTVEC+14	;Warm Monitor Entry Vector 0
   200                        ;
   201             00000310   VECINSRT0	.EQU	SOFTVEC+16	;1st Vector Insert (Timer support)
   202             00000312   VECINSRT1	.EQU	SOFTVEC+18	;1st Vector Insert (Timer support)
   203             00000314   VECINSRT2	.EQU	SOFTVEC+20	;1st Vector Insert
   204             00000316   VECINSRT3	.EQU	SOFTVEC+22	;1st Vector Insert
   205             00000318   VECINSRT4	.EQU	SOFTVEC+24	;1st Vector Insert
   206             0000031A   VECINSRT5	.EQU	SOFTVEC+26	;1st Vector Insert
   207             0000031C   VECINSRT6	.EQU	SOFTVEC+28	;1st Vector Insert
   208             0000031E   VECINSRT7	.EQU	SOFTVEC+30	;1st Vector Insert
   209                        ;
   210                        ;******************************************************************************
   211             00000320   SOFTCFG		.EQU SOFTVEC+32	;Start of hardware config parameters
   212                        ;
   213                        ;Soft Config values below are loaded from ROM and are the default I/O setup
   214                        ;configuration data that the INIT_65xx routines use. As a result, you can write a
   215                        ;routine to change the I/O configuration data and use the standard ROM routines
   216                        ;to initialize the I/O without restarting or changing ROM. A Reset (cold or coded)
   217                        ;will reinitialize the I/O with the ROM default I/O configuration
   218                        ;
   219                        ;There are a total of 32 Bytes configuration data reserved starting at $0320
   220                        ;
   221             00000320   LOAD_6551	.EQU	SOFTCFG	;6551 SOFT config data start
   222             00000322   LOAD_6522	.EQU	SOFTCFG+2	;6522 SOFT config data start
   223                        ;
   224                        ;Defaults for RTC ticks - number of IRQs for 1 second
   225             000000FA   DF_TICKS	.EQU	#250	;clock timer set for 4 milliseconds, so 250 x 4ms = 1 second
   226                        ;
   227                        ; Search Buffer is 16 bytes in length
   228                        ; Used to hold search string for text and hex data
   229             00000340   SRCHBUFF	.EQU	$340	;Located in Page $03 following HW config data
   230                        ;
   231                        ; Xmodem/CRC Loader also provides Motorola S19 Record sense and load
   232                        ; Designed to handle the S19 records from the WDC Assembler/Linker package
   233                        ; This requires a 44 byte buffer to parse each valid S1 record
   234                        ; Located just before the 132 Byte Xmodem frame buffer
   235                        ; There are a total of 176 bytes of Buffer associated with the Xmodem/CRC Loader
   236                        ;
   237                        ; Valid S-record headers are "S1" and "S9"
   238                        ; For S1, the maximum length is "19" hex. The last S1 record can be less
   239                        ; S9 record is always the last record with no data
   240                        ; WDC Linker also appends a CR/LF to the end of each record for a total 44 bytes
   241                        ;
   242             00000350   SRBUFF		.EQU	$0350	;Start of Motorola S-record buffer, 44 bytes in length
   243                        ;
   244                        ; Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked
   245                        ; for proper header and frame number, CRC-16 on the data, then moved to user RAM
   246                        ;
  Sun Mar  3 2019 23:01                                                                                                    Page 5


   247             0000037C   RBUFF			.EQU	$037C	;Xmodem temp 132 byte receive buffer
   248                        ;
   249                        ;Additional Xmodem variables, etc.
   250                        ;
   251                        ; XMODEM Control Character Constants
   252             00000001   SOH				.EQU	$01	;Start of Block Header
   253             00000004   EOT				.EQU	$04	;End of Text marker
   254             00000006   ACK				.EQU	$06	;Good Block Acknowledge
   255             00000015   NAK				.EQU	$15	;Bad Block acknowledged
   256             00000018   CAN				.EQU	$18	;Cancel character
   257                        ;
   258                        ;******************************************************************************
   259                        ;
   260             00000000   BURN_BYTE	.EQU	$0000	;Location in RAM for BYTE write routine
   261                        ;
   262                        ;******************************************************************************
   263                        ;I/O Page Base Address
   264             0000FE00   IOPAGE		.EQU	$FE00  
   265                        ;
   266                        ;VIA device address:
   267             0000FE00   Via1Base	.EQU	IOPAGE	;65C22 VIA base address here
   268             0000FE00   Via1PRB		.EQU  Via1Base+0	;Port B I/O register
   269             0000FE01   Via1PRA		.EQU  Via1Base+1	;Port A I/O register
   270             0000FE02   Via1DDRB	.EQU  Via1Base+2	;Port B data direction
   271             0000FE03   Via1DDRA  .EQU  Via1Base+3	;Port A data direction
   272             0000FE04   Via1T1CL  .EQU  Via1Base+4	;Timer 1 Low byte count
   273             0000FE05   Via1T1CH  .EQU  Via1Base+5	;Timer 1 High byte count
   274             0000FE06   Via1T1LL  .EQU  Via1Base+6	;Timer 1 Low byte latch
   275             0000FE07   Via1TALH  .EQU  Via1Base+7	;Timer 1 High byte latch
   276             0000FE08   Via1T2CL  .EQU  Via1Base+8	;Timer 2 Low byte count/latch
   277             0000FE09   Via1T2CH  .EQU  Via1Base+9	;Timer 2 High byte count
   278             0000FE0A   Via1SR    .EQU  Via1Base+10	;Shift Register
   279             0000FE0B   Via1ACR   .EQU  Via1Base+11	;Aux control register
   280             0000FE0C   Via1PCR   .EQU  Via1Base+12	;Peripheral control register
   281             0000FE0D   Via1IFR   .EQU  Via1Base+13	;Interrupt flag register
   282             0000FE0E   Via1IER   .EQU  Via1Base+14	;Interrupt enable register
   283             0000FE0F   Via1PRA1  .EQU  Via1Base+15	;Port A echo register
   284                        ;
   285                        ;ACIA device address:
   286             0000FE20   SIOBase		.EQU	IOPAGE+$20	;6551 Base HW address
   287             0000FE20   SIODAT		.EQU	SIOBase+0	;ACIA data register
   288             0000FE21   SIOSTAT		.EQU	SIOBase+1	;ACIA status register
   289             0000FE22   SIOCOM		.EQU	SIOBase+2 ;ACIA command register
   290             0000FE23   SIOCON		.EQU	SIOBase+3 ;ACIA control register
   291                        ;
   292                        ;******************************************************************************
   293                        					.ORG $E000    ;6KB reserved for monitor $E000 through $F7FF
   294                        ;******************************************************************************
   295                        ;START OF MONITOR CODE
   296                        ;
   297                        ;*******************************************
   298                        ;*                C02 Monitor              *
   299                        ;*******************************************
   300                        ;*  This is the Monitor Cold start vector  *
   301                        ;*******************************************
   302 00:E000: A9 14        MONITOR		LDA	#$14	;Get intro msg / BEEP
   303 00:E002: 20 35 E7     					JSR	PROMPT	;Send to terminal
   304                        ;
   305                        ;*******************************************
   306                        ;*           Command input loop            *
   307                        ;*******************************************
   308                        ;*  This in the Monitor Warm start vector  *
   309                        ;*******************************************
  Sun Mar  3 2019 23:01                                                                                                    Page 6


   310 00:E005: A2 FF        WRM_MON		LDX	#$FF	;Initialize Stack pointer
   311 00:E007: 9A           					TXS	;Xfer to stack
   312 00:E008: 64 D5        					STZ	CMDFLAG	;Clear Command flag
   313 00:E00A: A9 16        					LDA	#$16	;Get prompt msg
   314 00:E00C: 20 35 E7     					JSR	PROMPT	;Send to terminal
   315                        ;
   316 00:E00F: 20 B0 E1     CMON			JSR	RDCHAR	;Wait for keystroke (converts to upper-case)
   317 00:E012: A2 1D        					LDX	#MONTAB-MONCMD-1	;Get command list count
   318 00:E014: DD 9A E9     CMD_LP		CMP	MONCMD,X	;Compare to command list
   319 00:E017: D0 0D        					BNE	CMD_DEC	;Check for next command and loop
   320 00:E019: 48           					PHA	;Save keystroke
   321 00:E01A: 8A           					TXA	;Xfer Command index to A reg
   322 00:E01B: 0A           					ASL	A	;Multiply keystroke value by 2
   323 00:E01C: AA           					TAX	;Get monitor command processor address from table MONTAB
   324 00:E01D: 68           					PLA	;Restore keystroke (some commands send keystroke to terminal
                    )
   325 00:E01E: 20 23 E0     					JSR	DOCMD	;Call selected monitor command processor as a subrou
                    tine
   326 00:E021: 80 E2        					BRA	WRM_MON	;Command processed, branch and wait for next command
   327 00:E023: 7C B8 E9     DOCMD			JMP	(MONTAB,X)	;Execute CMD from Table
   328                        ;
   329 00:E026: CA           CMD_DEC		DEX	;Decrement index count
   330 00:E027: 10 EB        					BPL	CMD_LP	;If more to check, loop back
   331 00:E029: 20 FE E0     					JSR	BEEP	;Beep for error,
   332 00:E02C: 80 E1        					BRA	CMON	;re-enter monitor
   333                        ;
   334                        ;***********************************************
   335                        ;* Basic Subroutines used by multiple routines *
   336                        ;***********************************************
   337                        ;
   338                        ;ASC2BIN subroutine: Convert 2 ASCII HEX digits to a binary (byte) value
   339                        ;Enter: A register = high digit, Y register = low digit
   340                        ;Return: A register = binary value
   341 00:E02E: 20 3E E0     ASC2BIN		JSR	BINARY	;Convert high digit to 4-bit nibble
   342 00:E031: 0A           					ASL	A	;Shift to high nibble
   343 00:E032: 0A           					ASL	A
   344 00:E033: 0A           					ASL	A
   345 00:E034: 0A           					ASL	A
   346 00:E035: 85 D2        					STA	TEMP1	;Store it in temp area
   347 00:E037: 98           					TYA	;Get Low digit
   348 00:E038: 20 3E E0     					JSR	BINARY	;Convert low digit to 4-bit nibble
   349 00:E03B: 05 D2        					ORA	TEMP1	;OR in the high nibble
   350 00:E03D: 60           					RTS	;Return to caller
   351                        ;
   352 00:E03E: 38           BINARY		SEC	;Set carry for subtraction
   353 00:E03F: E9 30        					SBC	#$30	;Subtract $30 from ASCII HEX digit
   354 00:E041: C9 0A        					CMP	#$0A	;Check for result < 10     
   355 00:E043: 90 02        					BCC	BNOK	;Branch if 0-9
   356 00:E045: E9 07        					SBC	#$07	;Else, subtract 7 for A-F
   357 00:E047: 60           BNOK			RTS	;Return to caller
   358                        ;
   359                        ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
   360                        ;Enter: A register contains byte value to convert
   361                        ;Return: A register = high digit, Y register = low digit
   362 00:E048: 48           BIN2ASC		PHA	;Save A Reg on stack
   363 00:E049: 29 0F        					AND	#$0F	;Mask off high nibble
   364 00:E04B: 20 54 E0     					JSR	ASCII	;Convert nibble to ASCII HEX digit
   365 00:E04E: A8           					TAY	;Move to Y Reg
   366 00:E04F: 68           					PLA	;Get character back from stack
   367 00:E050: 4A           					LSR	A	;Shift high nibble to lower 4 bits
   368 00:E051: 4A           					LSR	A
   369 00:E052: 4A           					LSR	A
   370 00:E053: 4A           					LSR	A
  Sun Mar  3 2019 23:01                                                                                                    Page 7


   371                        ;
   372 00:E054: C9 0A        ASCII			CMP	#$0A	;Check for 10 or less
   373 00:E056: 90 03        					BCC	ASOK	;Branch if less than 10
   374 00:E058: 18           					CLC	;Clear carry for addition
   375 00:E059: 69 07        					ADC	#$07	;Add $07 for A-F
   376 00:E05B: 69 30        ASOK			ADC	#$30	;Add $30 for ASCII
   377 00:E05D: 60           					RTS	;Return to caller
   378                        ;
   379                        ;HEX2ASC - Accepts 16-bit Hexadecimal value and converts to an ASCII decimal string
   380                        ;Input is via the A and Y registers and output is up to 5 ASCII digits in DATABUFF
   381                        ;The High Byte is in the Y register and Low Byte is in the A register
   382                        ;Output data is placed in variable DATABUFF and terminated with an null character
   383                        ;PROMPTR routine is used to print the ASCII decimal value
   384                        ;Routine based on Michael Barry's code. Saved many bytes ;-)
   385                        ;
   386 00:E05E: 85 BC        HEX2ASC		STA	BINVALL	;Save Low byte
   387 00:E060: 84 BD        					STY	BINVALH	;Save High byte
   388 00:E062: A2 05        					LDX	#5	;Get ASCII buffer offset
   389 00:E064: 74 B4        					STZ	DATABUFF,X	;Zero last buffer byte for null end
   390                        ;
   391 00:E066: A9 00        CNVERT		LDA	#$00	;Clear remainder
   392 00:E068: A0 10        					LDY	#16	;Set loop count for 16-bits
   393                        ;
   394 00:E06A: C9 05        DVLOOP		CMP	#$05	;Partial remainder >= 10/2
   395 00:E06C: 90 02        					BCC	DVLOOP2	;Branch if less
   396 00:E06E: E9 05        					SBC	#$05	;Update partial, set carry
   397                        ;
   398 00:E070: 26 BC        DVLOOP2		ROL	BINVALL	;Shift carry into dividend
   399 00:E072: 26 BD        					ROL	BINVALH	;Which will be quotient
   400 00:E074: 2A           					ROL	A	;Rotate A reg
   401 00:E075: 88           					DEY	;Decrement count
   402 00:E076: D0 F2        					BNE	DVLOOP	;Branch back until done
   403 00:E078: 09 30        					ORA	#$30	;Or in bits for ASCII
   404                        ;
   405 00:E07A: CA           					DEX	;Decrement buffer index
   406 00:E07B: 95 B4        					STA	DATABUFF,X	;Store value into buffer
   407                        ;
   408 00:E07D: A5 BC        					LDA	BINVALL	;Get the Low byte
   409 00:E07F: 05 BD        					ORA	BINVALH	;OR in the High byte (check for zero)
   410 00:E081: D0 E3        					BNE	CNVERT	;Branch back until done
   411 00:E083: 86 D2        					STX	TEMP1	;Save buffer offset
   412                        ;
   413                        ;Conversion is complete, get the string address,
   414                        ;add offset, then call prompt routine and return
   415                        ; note DATABUFF is fixed location in Page 0
   416                        ; carry flag need not be cleared as result can never
   417                        ; set flag after ADC instruction, Y Reg always zero
   418                        ;
   419 00:E085: A9 B4        					LDA	#<DATABUFF	;Get Low byte Address
   420 00:E087: 65 D2        					ADC	TEMP1	;Add in buffer offset (no leading zeros)
   421 00:E089: A0 00        					LDY	#>DATABUFF	;Get High byte address
   422 00:E08B: 4C 2D E7     					JMP	PROMPTR	;Send to terminal and return
   423                        ;
   424                        ;SETUP subroutine: Request HEX address input from terminal
   425 00:E08E: 20 19 F8     SETUP			JSR	CHROUT	;Send command keystroke to terminal
   426 00:E091: 20 1C E1     					JSR	SPC	;Send [SPACE] to terminal
   427 00:E094: 80 03        					BRA	HEXIN4	;Request a 0-4 digit HEX address input from terminal
   428                        ;
   429                        ;HEX input subroutines:
   430                        ;Request 1 to 4 ASCII HEX digits from terminal, then convert digits into a binary value
   431                        ;HEXIN2 - returns value in A reg and Y reg only (Y reg always $00)
   432                        ;HEXIN4 - returns values in A reg, Y reg and INDEXL/INDEXH
   433                        ;For 1 to 4 digits entered, HEXDATAH and HEXDATAL contain the output
  Sun Mar  3 2019 23:01                                                                                                    Page 8


   434                        ;Variable BUFIDX will contain the number of digits entered
   435                        ;HEX2 - Prints MSG# in A reg then calls HEXIN2
   436                        ;HEX4 - Prints MSG# in A reg then calls HEXIN4
   437                        ;
   438 00:E096: 20 35 E7     HEX4			JSR	PROMPT	;Print MSG # from A reg
   439 00:E099: A2 04        HEXIN4		LDX	#$04	;Set for number of characters allowed
   440 00:E09B: 20 A8 E0     					JSR	HEXINPUT	;Convert digits
   441 00:E09E: 84 C1        					STY	INDEXH	;Store to INDEXH
   442 00:E0A0: 85 C0        					STA	INDEXL	;Store to INDEXL
   443 00:E0A2: 60           					RTS	;Return to caller
   444                        ;
   445 00:E0A3: 20 35 E7     HEX2			JSR	PROMPT	;Print MSG # from A reg
   446 00:E0A6: A2 02        HEXIN2		LDX	#$02	;Set for number of characters allowed
   447                        ;
   448                        ;HEXINPUT subroutine: request 1 to 4 HEX digits from terminal,
   449                        ;then convert ASCII HEX to HEX
   450                        ;Setup RDLINE subroutine parameters:
   451 00:E0A8: 20 21 E1     HEXINPUT	JSR	DOLLAR	;Send "$" to console
   452 00:E0AB: 20 6C E1     					JSR	RDLINE	;Request ASCII HEX input from terminal
   453 00:E0AE: F0 28        					BEQ	HINEXIT	;Exit if none (Z flag already set)
   454 00:E0B0: 64 BA        					STZ	HEXDATAH	;Clear Upper HEX byte
   455 00:E0B2: 64 BB        					STZ	HEXDATAL	;Clear Lower HEX byte
   456 00:E0B4: A0 02        					LDY	#$02	;Set index for 2 bytes
   457 00:E0B6: 5A           ASCLOOP		PHY	;Save it to stack
   458 00:E0B7: B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
   459 00:E0B9: A8           					TAY	;Xfer to Y Reg (LSD)
   460 00:E0BA: CA           					DEX	;Decrement input count
   461 00:E0BB: F0 04        					BEQ	NO_UPNB	;Branch if no upper nibble
   462 00:E0BD: B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
   463 00:E0BF: 80 02        					BRA	DO_UPNB	;Branch to include upper nibble
   464 00:E0C1: A9 30        NO_UPNB		LDA	#$30	;Load ASCII "0" (MSD)
   465 00:E0C3: 20 2E E0     DO_UPNB		JSR	ASC2BIN	;Convert ASCII digits to binary value
   466 00:E0C6: 7A           					PLY	;Get index from stack
   467 00:E0C7: 99 B9 00     					STA	HEXDATAH-1,Y	;Write byte to indexed HEX input buffer loca
                    tion
   468 00:E0CA: E0 00        					CPX	#$00	;Any more digits?
   469 00:E0CC: F0 04        					BEQ	HINDONE	;If not, exit
   470 00:E0CE: 88           					DEY	;Else, decrement to next byte set
   471 00:E0CF: CA           					DEX	;Decrement index count
   472 00:E0D0: D0 E4        					BNE	ASCLOOP	;Loop back for next byte
   473 00:E0D2: A4 BA        HINDONE		LDY	HEXDATAH	;Get High Byte
   474 00:E0D4: A5 BB        					LDA	HEXDATAL	;Get Low Byte
   475 00:E0D6: A6 CE        					LDX	BUFIDX	;Get input count (Z flag)
   476 00:E0D8: 60           HINEXIT		RTS	;And return to caller
   477                        ;
   478                        ;Routines to update pointers for memory operations
   479                        ;
   480                        ;UPD_STL subroutine: Increments Source and Target pointers
   481                        ;UPD_TL subroutine: Increments Target pointers only
   482                        ; then drops into decrement length pointer. Used by multiple commands
   483 00:E0D9: E6 C8        UPD_STL		INC	SRCL	;Increment source low byte
   484 00:E0DB: D0 02        					BNE	UPD_TL	;Check for rollover
   485 00:E0DD: E6 C9        					INC	SRCH	;Increment source high byte
   486 00:E0DF: E6 CA        UPD_TL		INC	TGTL	;Increment target low byte
   487 00:E0E1: D0 02        					BNE	DECLEN	;Check for rollover
   488 00:E0E3: E6 CB        					INC	TGTH	;Increment target high byte
   489                        ;
   490                        ;DECLEN subroutine: decrement 16-bit variable LENL/LENH
   491 00:E0E5: A5 CC        DECLEN		LDA	LENL	;Get length low byte
   492 00:E0E7: D0 02        					BNE	SKP_LENH	;Test for LENL = zero
   493 00:E0E9: C6 CD        					DEC	LENH	;Else decrement length high byte
   494 00:E0EB: C6 CC        SKP_LENH	DEC	LENL	;Decrement length low byte
   495 00:E0ED: 60           					RTS	;Return to caller
  Sun Mar  3 2019 23:01                                                                                                    Page 9


   496                        ;
   497                        ;DECINDEX subroutine: decrement 16 bit variable INDEXL/INDEXH
   498 00:E0EE: A5 C0        DECINDEX	LDA	INDEXL	;Get index low byte
   499 00:E0F0: D0 02        					BNE	SKP_IDXH	;Test for INDEXL = zero
   500 00:E0F2: C6 C1        					DEC	INDEXH	;Decrement index high byte
   501 00:E0F4: C6 C0        SKP_IDXH	DEC	INDEXL	;Decrement index low byte
   502 00:E0F6: 60           					RTS	;Return to caller
   503                        ;
   504                        ;INCINDEX subroutine: increment 16 bit variable INDEXL/INDEXH
   505 00:E0F7: E6 C0        INCINDEX	INC	INDEXL	;Increment index low byte
   506 00:E0F9: D0 02        					BNE	SKP_IDX	;If not zero, skip high byte
   507 00:E0FB: E6 C1        					INC	INDEXH	;Increment index high byte
   508 00:E0FD: 60           SKP_IDX		RTS	;Return to caller
   509                        ;
   510                        ;Output routines for formatting, backspaces, CR/LF, BEEP, etc.
   511                        ; all routines preserve the A reg on exit.
   512                        ;
   513                        ;BEEP subroutine: Send ASCII [BELL] to terminal
   514 00:E0FE: 48           BEEP			PHA	;Save A reg on Stack
   515 00:E0FF: A9 07        					LDA	#$07	;Get ASCII [BELL] to terminal
   516 00:E101: 80 2E        					BRA	SENDIT	;Branch to send
   517                        ;
   518                        ;BSOUT subroutine: send a Backspace to terminal
   519 00:E103: 20 09 E1     BSOUT			JSR	BSOUT2	;Send an ASCII backspace
   520 00:E106: 20 1C E1     					JSR	SPC	;Send space to clear out character
   521 00:E109: 48           BSOUT2		PHA	;Save character in A reg
   522 00:E10A: A9 08        					LDA	#$08	;Send another Backspace to return
   523 00:E10C: 80 23        BRCHOUT		BRA	SENDIT	;Branch to send
   524                        ;
   525 00:E10E: 20 09 E1     BSOUT3T		JSR	BSOUT2	;Send a Backspace 3 times
   526 00:E111: 20 09 E1     BSOUT2T		JSR	BSOUT2	;Send a Backspace 2 times
   527 00:E114: 80 F3        					BRA	BSOUT2	;Send a Backspace and return
   528                        ;
   529                        ;SPC subroutines: Send a Space to terminal 1,2 or 4 times
   530 00:E116: 20 19 E1     SPC4			JSR	SPC2	;Send 4 Spaces to terminal
   531 00:E119: 20 1C E1     SPC2			JSR	SPC	;Send 2 Spaces to terminal
   532 00:E11C: 48           SPC				PHA	;Save character in A reg
   533 00:E11D: A9 20        					LDA	#$20	;Get ASCII Space
   534 00:E11F: 80 10        					BRA	SENDIT	;Branch to send
   535                        ;
   536                        ;DOLLAR subroutine: Send "$" to terminal
   537 00:E121: 48           DOLLAR		PHA	;Save A reg on STACK
   538 00:E122: A9 24        					LDA	#$24	;Get ASCII "$"
   539 00:E124: 80 0B        					BRA	SENDIT	;Branch to send
   540                        ;
   541                        ;Send CR,LF to terminal
   542 00:E126: 20 29 E1     CR2				JSR	CROUT	;Send CR,LF to terminal
   543 00:E129: 48           CROUT			PHA	;Save A reg
   544 00:E12A: A9 0D        					LDA	#$0D	;Get ASCII Return
   545 00:E12C: 20 19 F8     					JSR	CHROUT	;Send to terminal
   546 00:E12F: A9 0A        					LDA	#$0A	;Get ASCII Linefeed
   547 00:E131: 20 19 F8     SENDIT		JSR	CHROUT	;Send to terminal
   548 00:E134: 68           					PLA	;Restore A reg
   549 00:E135: 60           					RTS	;Return to caller
   550                        ;
   551                        ;GLINE subroutine: Send a horizontal line to terminal
   552                        ; used by memory display only, does not preserve any registers
   553                        ;
   554 00:E136: A2 4F        GLINE			LDX	#$4F	;Load index for 79 decimal
   555 00:E138: A9 7E        					LDA	#$7E	;Get "~" character
   556 00:E13A: 20 19 F8     GLINEL		JSR	CHROUT	;Send to terminal (draw a line)
   557 00:E13D: CA           					DEX	;Decrement count
   558 00:E13E: D0 FA        					BNE	GLINEL	;Branch back until done
  Sun Mar  3 2019 23:01                                                                                                    Page 10


   559 00:E140: 60           					RTS	;Return to caller
   560                        ;
   561                        ;Routines to output 8/16-bit Binary Data and Ascii characters
   562                        ;
   563                        ;PRASC subroutine: Print A-reg as ASCII, else print "."
   564                        ;Printable ASCII byte values = $20 through $7E
   565 00:E141: C9 7F        PRASC			CMP	#$7F	;Check for first 128
   566 00:E143: B0 04        					BCS	PERIOD	;If = or higher, branch
   567 00:E145: C9 20        					CMP	#$20	;Check for control characters
   568 00:E147: B0 02        					BCS	ASCOUT	;If space or higher, branch and print
   569 00:E149: A9 2E        PERIOD		LDA	#$2E	;Else, print a "."
   570 00:E14B: 4C 19 F8     ASCOUT		JMP	CHROUT	;Send byte in A-Reg, then return
   571                        ;
   572                        ;PRBYTE subroutine:
   573                        ; Converts a single Byte to 2 HEX ASCII characters and sends to console
   574                        ; on entry, A reg contains the Byte to convert/send
   575                        ; Register contents are preserved on entry/exit
   576 00:E14E: 48           PRBYTE		PHA	;Save A register
   577 00:E14F: 5A           					PHY	;Save Y register
   578 00:E150: 20 48 E0     PRBYT2		JSR	BIN2ASC	;Convert A reg to 2 ASCII Hex characters
   579 00:E153: 20 19 F8     					JSR	CHROUT	;Print high nibble from A reg
   580 00:E156: 98           					TYA	;Transfer low nibble to A reg
   581 00:E157: 20 19 F8     					JSR	CHROUT	;Print low nibble from A reg
   582 00:E15A: 7A           					PLY	;Restore Y Register
   583 00:E15B: 68           					PLA	;Restore A Register
   584 00:E15C: 60           					RTS	;And return to caller
   585                        ;
   586                        ;PRINDEX	subroutine:
   587                        ; Used by Memory Dump and Text Entry routines
   588                        ; Prints a $ sign followed by the current value of INDEXH/L
   589 00:E15D: 20 21 E1     PRINDEX		JSR	DOLLAR	;Print a $ sign
   590 00:E160: A5 C1        					LDA	INDEXH	;Get Index high byte
   591 00:E162: A4 C0        					LDY	INDEXL	;Get Index low byte
   592                        ;
   593                        ;PRWORD	subroutine:
   594                        ;	Converts a 16-bit word to 4 HEX ASCII characters and sends to console
   595                        ; on entry, A reg contains High Byte, Y reg contains Low Byte
   596                        ; Register contents are preserved on entry/exit
   597 00:E164: 48           PRWORD		PHA	;Save A register
   598 00:E165: 5A           					PHY	;Save Y register
   599 00:E166: 20 4E E1     					JSR	PRBYTE	;Convert and print one HEX character (00-FF)
   600 00:E169: 98           					TYA	;Get Low byte value
   601 00:E16A: 80 E4        					BRA	PRBYT2	;Finish up Low Byte and exit
   602                        ;
   603                        ;RDLINE subroutine: Store keystrokes in buffer until [RETURN] key it struck
   604                        ;Used only for Hex entry, so only (0-9,A-F) are accepted entries
   605                        ;Lower-case alpha characters are converted to upper-case.
   606                        ;On entry, X reg = buffer length. On exit, X reg = buffer count
   607                        ;[BACKSPACE] key removes keystrokes from buffer.
   608                        ;[ESCAPE] key aborts then re-enters monitor. 
   609 00:E16C: 86 CF        RDLINE		STX	BUFLEN	;Store buffer length   
   610 00:E16E: 64 CE        					STZ	BUFIDX	;Zero buffer index
   611 00:E170: 20 B0 E1     RDLOOP		JSR	RDCHAR	;Get character from terminal, convert LC2UC
   612 00:E173: C9 1B        					CMP	#$1B	;Check for ESC key
   613 00:E175: F0 36        					BEQ	RDNULL	;If yes, exit back to Monitor
   614 00:E177: C9 0D        NOTESC		CMP	#$0D	;Check for C/R
   615 00:E179: F0 2B        					BEQ	EXITRD	;Exit if yes
   616 00:E17B: C9 08        					CMP	#$08	;Check for Backspace
   617 00:E17D: F0 1C        					BEQ	RDBKSP	;If yes handle backspace
   618 00:E17F: C9 30        TSTHEX		CMP	#$30	;Check for '0' or higher
   619 00:E181: 90 0A        					BCC	INPERR	;Branch to error if less than '0'
   620 00:E183: C9 47        					CMP	#$47	;Check for 'G' ('F'+1)
   621 00:E185: B0 06        					BCS	INPERR	;Branch to error if 'G' or higher
  Sun Mar  3 2019 23:01                                                                                                    Page 11


   622 00:E187: A6 CE        FULTST		LDX	BUFIDX	;Get the current buffer index
   623 00:E189: E4 CF        					CPX	BUFLEN	;Compare to length for space
   624 00:E18B: 90 05        					BCC	STRCHR	;Branch to store in buffer
   625 00:E18D: 20 FE E0     INPERR		JSR	BEEP	;Else, error, send Bell to terminal
   626 00:E190: 80 DE        					BRA	RDLOOP	;Branch back to RDLOOP
   627 00:E192: 95 B0        STRCHR		STA	INBUFF,X	;Store keystroke in buffer
   628 00:E194: 20 19 F8     					JSR	CHROUT	;Send keystroke to terminal
   629 00:E197: E6 CE        					INC	BUFIDX	;Increment buffer index
   630 00:E199: 80 D5        					BRA	RDLOOP	;Branch back to RDLOOP
   631 00:E19B: A5 CE        RDBKSP		LDA	BUFIDX	;Check if buffer is empty
   632 00:E19D: F0 EE        					BEQ	INPERR	;Branch if yes
   633 00:E19F: C6 CE        					DEC	BUFIDX	;Else, decrement buffer index
   634 00:E1A1: 20 03 E1     					JSR	BSOUT	;Send Backspace to terminal
   635 00:E1A4: 80 CA        					BRA	RDLOOP	;Loop back and continue
   636 00:E1A6: A6 CE        EXITRD		LDX	BUFIDX	;Get keystroke count (Z flag)
   637 00:E1A8: D0 0F        					BNE	AOK	;If data entered, normal exit
   638 00:E1AA: FF D5 0C     					BBS7	CMDFLAG,AOK	;Branch if CMD flag active
   639 00:E1AD: 6C 0E 03     RDNULL		JMP	(WRMMNVEC0)	;Quit to Monitor warm start
   640                        ;
   641                        ;RDCHAR subroutine: Waits for a keystroke to be entered.
   642                        ; if keystroke is a lower-case alphabetical, convert it to upper-case
   643 00:E1B0: 20 06 F8     RDCHAR		JSR	CHRIN	;Request keystroke input from terminal
   644 00:E1B3: C9 61        					CMP	#$61	;Check for lower case value range
   645 00:E1B5: 90 02        					BCC	AOK	;Branch if < $61, control code/upper-case/numeric
   646 00:E1B7: E9 20        					SBC	#$20	;Subtract $20 to convert to upper case
   647 00:E1B9: 60           AOK				RTS	;Character received, return to caller
   648                        ;
   649                        ;Continue routine, called by commands to confirm execution
   650                        ;when No is confirmed, return address removed from stack
   651                        ;and the exit goes back to the monitor loop.
   652                        ;Short version prompts for (Y/N) only.
   653 00:E1BA: A9 00        CONTINUE	LDA	#$00	;Get msg "cont? (Y/N)" to terminal
   654 00:E1BC: 80 02        					BRA	SH_CONT	;Branch down
   655 00:E1BE: A9 01        CONTINUE2	LDA	#$01	;Get short msg "(Y/N)" only
   656 00:E1C0: 20 35 E7     SH_CONT		JSR	PROMPT	;Send to terminal
   657 00:E1C3: 20 B0 E1     TRY_AGN		JSR	RDCHAR	;Get keystroke from terminal
   658 00:E1C6: C9 59        					CMP	#$59	;"Y" key?
   659 00:E1C8: F0 0B        					BEQ	DOCONT	;if yes, continue/exit
   660 00:E1CA: C9 4E        					CMP	#$4E	;if "N", quit/exit
   661 00:E1CC: F0 05        					BEQ	DONTCNT	;Return if not ESC
   662 00:E1CE: 20 FE E0     					JSR	BEEP	;Send Beep to console
   663 00:E1D1: 80 F0        					BRA	TRY_AGN	;Loop back, try again
   664 00:E1D3: 68           DONTCNT		PLA	;Else remove return address
   665 00:E1D4: 68           					PLA	;discard it,
   666 00:E1D5: 60           DOCONT		RTS	;Return
   667                        ;
   668                        ;******************************
   669                        ;* Monitor command processors *
   670                        ;******************************
   671                        ;
   672                        ;[,] Delay Setup Routine
   673                        ;	This routine gets hex input via the console
   674                        ;	- first is a hex byte ($00-$FF) for the millisecond count
   675                        ;	- second is a hex word ($0000-$FFFF) for the delay multiplier
   676                        ;		these are stored in variables SETIM, DELLO/DELHI
   677                        ;
   678 00:E1D6: A9 17        SET_DELAY	LDA	#$17	;Get millisecond delay message
   679 00:E1D8: 20 A3 E0     					JSR	HEX2	;Use short cut version for print and input
   680 00:E1DB: 85 F6        					STA	SETIM	;Else store millisecond count in variable
   681 00:E1DD: A9 18        GETMULT		LDA	#$18	;Get Multiplier message
   682 00:E1DF: 20 96 E0     					JSR	HEX4	;Use short cut version for print and input
   683 00:E1E2: 85 F7        					STA	DELLO	;Store Low byte
   684 00:E1E4: 84 F8        					STY	DELHI	;Store High byte
  Sun Mar  3 2019 23:01                                                                                                    Page 12


   685 00:E1E6: 60           					RTS	;Return to caller
   686                        ;
   687                        ;[\] Execute XL Delay
   688                        ; Get an 8-bit value for extra long delay, execute is entered
   689 00:E1E7: A9 19        SET_XLDLY	LDA	#$19	;Get XL Loop message
   690 00:E1E9: 20 A3 E0     					JSR	HEX2	;Use short cut version for print and input
   691 00:E1EC: 85 F9        					STA	XDL	;Save delay value
   692 00:E1EE: A9 0D        					LDA	#$0D	;Get ASCII C/R
   693 00:E1F0: 20 19 F8     					JSR	CHROUT	;Send C/R (shows delay has been executed, no L/F)
   694 00:E1F3: 4C 5E F8     					JMP	EXE_XLDLY	;Execute Extra Long delay loop
   695                        ;
   696                        ;[(] INIMACRO command: Initialize keystroke input buffer
   697                        ;initializes buffer head/tail pointers and resets buffer count to zero
   698                        ;input buffer appears empty so command macro starts at the head of the buffer
   699 00:E1F6: 64 DD        INIMACRO	STZ	LPCNTL	;Zero Loop count low byte
   700 00:E1F8: 64 DE        					STZ	LPCNTH	;Zero Loop count high byte
   701 00:E1FA: 64 DF        					STZ	LPCNTF	;Zero Loop count flag
   702                        ;
   703 00:E1FC: A9 2D        LP_CNT_FL	LDA	#$2D	;Get Loop Count msg
   704 00:E1FE: 20 35 E7     					JSR	PROMPT	:send to console
   705 00:E201: A9 01        					LDA	#$01	;Get short msg "(Y/N)" only
   706 00:E203: 20 35 E7     					JSR	PROMPT	;Send to terminal
   707 00:E206: 20 B0 E1     					JSR	RDCHAR	;Get keystroke from terminal
   708 00:E209: C9 59        					CMP	#$59	;"Y" key?
   709 00:E20B: F0 09        					BEQ	DOLOOPS	;if yes, set loop flag
   710 00:E20D: C9 4E        					CMP	#$4E	;if "N", quit/exit
   711 00:E20F: F0 07        					BEQ	NOLOOPS	;if no, don't set loop flag
   712 00:E211: 20 FE E0     					JSR	BEEP	;Neither y/n selected, sound bell
   713 00:E214: 80 E6        					BRA	LP_CNT_FL	;Branch back, try again
   714                        ;
   715 00:E216: F7 DF        DOLOOPS		SMB7	LPCNTF	;Set high order bit of Loop flag
   716 00:E218: 64 E7        NOLOOPS		STZ	ICNT	;Zero Input buffer count
   717 00:E21A: 64 E9        					STZ	ITAIL	;Zero Input buffer tail pointer
   718 00:E21C: 64 E8        MACINI		STZ	IHEAD	;Zero Input buffer head pointer
   719 00:E21E: 60           DONEFILL	RTS	;Return to caller
   720                        ;
   721                        ;[)] RUNMACRO command: Run monitor command macro. This will indicate that there
   722                        ;are 128 keystrokes in the keystroke input buffer. The monitor will process these
   723                        ;as if they were received from the terminal (typed-in by the user). Because the
   724                        ;last keystroke stored in the keystroke buffer was ")", this will loop continuously
   725                        ;Use [BREAK] to exit macro
   726 00:E21F: A9 7F        RUNMACRO	LDA	#$7F	;Set keystroke buffer tail pointer to $7F
   727 00:E221: 85 E9        					STA	ITAIL	;Push tail pointer to end
   728 00:E223: 1A           					INC	A	;Increment to $80 for buffer count (full)
   729 00:E224: 85 E7        					STA	ICNT	;Make count show as full
   730 00:E226: 7F DF 15     					BBR7	LPCNTF,NOLP_CNT	;If Loop flag clear, branch around it
   731 00:E229: E6 DD        					INC	LPCNTL	;Increment loops low byte
   732 00:E22B: D0 02        					BNE	SKP_LPC	;If not zero, skip high byte
   733 00:E22D: E6 DE        					INC	LPCNTH	;Increment loops high byte
   734 00:E22F: A9 2E        SKP_LPC		LDA	#$2E	;Get Loops msg
   735 00:E231: 20 35 E7     					JSR	PROMPT	;Send to console
   736 00:E234: A5 DD        					LDA	LPCNTL	;Get Loop count low
   737 00:E236: A4 DE        					LDY	LPCNTH	;Get Loop count high
   738 00:E238: 20 5E E0     					JSR	HEX2ASC	;Print Loop count
   739 00:E23B: 20 29 E1     					JSR	CROUT	;Send C/R to console
   740 00:E23E: 80 DC        NOLP_CNT	BRA	MACINI	;Zero Head pointer and exit
   741                        ;
   742                        ;[C] Compare one memory range to another and display any addresses which do not match
   743                        ;[M] Move routine uses this section for parameter input, then branches to MOVER below
   744                        ;[F] Fill routine uses this section for parameter input but requires a fill byte value
   745                        ;[CTRL-P] Program EEPROM uses this section for parameter input and to write the EEPROM
   746                        ;Uses source, target and length input parameters. errors in compare are shown in target space
   747                        ;
  Sun Mar  3 2019 23:01                                                                                                    Page 13


   748 00:E240: A9 05        FM_INPUT	LDA	#$05	;Send "val: " to terminal
   749 00:E242: 20 A3 E0     					JSR	HEX2	;Use short cut version for print and input
   750 00:E245: AA           					TAX	;Xfer fill byte to X reg
   751 00:E246: 20 BA E1     					JSR	CONTINUE	;Handle continue prompt
   752                        ;
   753                        ;Memory fill routine: parameter gathered below with Move/Fill, then a jump to here
   754                        ;Xreg contains fill byte value
   755 00:E249: A5 CC        FILL_LP		LDA	LENL	;Get length low byte
   756 00:E24B: 05 CD        					ORA	LENH	;OR in length high byte
   757 00:E24D: F0 CF        					BEQ	DONEFILL	;Exit if zero
   758 00:E24F: 8A           					TXA	;Get fill byte
   759 00:E250: 92 CA        					STA	(TGTL)	;Store in target location
   760 00:E252: 20 DF E0     					JSR	UPD_TL	;Update Target/Length pointers
   761 00:E255: 80 F2        					BRA	FILL_LP	;Loop back until done
   762                        ;
   763                        ;Compare/Move/Fill memory operations enter here, branches as required
   764                        ;
   765 00:E257: 85 D3        CPMVFL		STA	TEMP2	;Save command character
   766 00:E259: 20 19 F8     					JSR	CHROUT	;Print command character (C/M/F)
   767 00:E25C: C9 46        					CMP	#$46	;Check for F - fill memory
   768 00:E25E: D0 0B        					BNE	PRGE_E	;If not continue normal parameter input
   769 00:E260: A9 03        					LDA	#$03	;Get msg " addr:"
   770 00:E262: 80 12        					BRA	F_INPUT	;Branch to handle parameter input
   771                        ;
   772                        ;EEPROM wrte operation enters here
   773                        ;
   774 00:E264: A9 21        PROGEE		LDA	#$21	;Get PRG_EE msg
   775 00:E266: 20 35 E7     					JSR	PROMPT	;send to terminal
   776 00:E269: 64 D3        					STZ	TEMP2	;Clear (Compare/Fill/Move) / error flag
   777                        ;
   778 00:E26B: A9 06        PRGE_E		LDA	#$06	;Send " src:" to terminal
   779 00:E26D: 20 96 E0     					JSR	HEX4	;Use short cut version for print and input
   780 00:E270: 85 C8        					STA	SRCL	;Else, store source address in variable SRCL,SRCH
   781 00:E272: 84 C9        					STY	SRCH	;Store high address
   782 00:E274: A9 07        					LDA	#$07	;Send " tgt:" to terminal
   783 00:E276: 20 96 E0     F_INPUT		JSR	HEX4	;Use short cut version for print and input
   784 00:E279: 85 CA        					STA	TGTL	;Else, store target address in variable TGTL,TGTH
   785 00:E27B: 84 CB        					STY	TGTH	;Store high address
   786 00:E27D: A9 04        					LDA	#$04	;Send " len:" to terminal
   787 00:E27F: 20 96 E0     					JSR	HEX4	;Use short cut version for print and input
   788 00:E282: 85 CC        					STA	LENL	;ELSE, store length address in variable LENL,LENH
   789 00:E284: 84 CD        					STY	LENH	;Store high address
   790                        ;
   791                        ; All input parameters for Source, Target and Length entered
   792 00:E286: A5 D3        					LDA	TEMP2	;Get Command character
   793 00:E288: C9 46        					CMP	#$46	;Check for fill memory
   794 00:E28A: F0 B4        					BEQ	FM_INPUT	;Handle the remaining input
   795 00:E28C: C9 43        					CMP	#$43	;Test for Compare
   796 00:E28E: F0 35        					BEQ	COMPLP	;Branch if yes
   797 00:E290: C9 4D        					CMP	#$4D	;Check for Move
   798 00:E292: F0 5A        					BEQ	MOVER	;Branch if yes
   799                        ;
   800 00:E294: A9 22        PROG_EE		LDA	#$22	;Get warning msg
   801 00:E296: 20 35 E7     					JSR	PROMPT	;Send to console
   802 00:E299: 20 BE E1     					JSR	CONTINUE2	;Prompt for y/n
   803                        ;
   804                        ;Programming of the EEPROM is now confirmed by user
   805                        ; This routine will copy the core move and test routine
   806                        ; from ROM to RAM, then call COMPLP to write and compare
   807                        ; as I/O can generate interrupts which point to ROM routines,
   808                        ; all interrupts must be disabled during the sequence.
   809                        ;
   810                        ;Send message to console for writing EEPROM
  Sun Mar  3 2019 23:01                                                                                                    Page 14


   811 00:E29C: A9 23        					LDA	#$23	;Get write message
   812 00:E29E: 20 35 E7     					JSR	PROMPT	;Send to console
   813 00:E2A1: A5 EA        OC_LOOP		LDA	OCNT	;Check output buffer count
   814 00:E2A3: D0 FC        					BNE	OC_LOOP	;Loop back until buffer sent
   815                        ;
   816                        ;Xfer byte write code to RAM for execution
   817 00:E2A5: A2 15        					LDX	#BYTE_WRE-BYTE_WRS+1	;Get length of byte write code
   818 00:E2A7: BD 3C E3     BYTE_XFER	LDA	BYTE_WRS-1,X	;Get code
   819 00:E2AA: 95 FF        					STA	BURN_BYTE-1,X	;Write code to RAM
   820 00:E2AC: CA           					DEX	;Decrement index
   821 00:E2AD: D0 F8        					BNE	BYTE_XFER	;Loop back until done
   822                        ;
   823 00:E2AF: F7 D3        PROG_EEP	SMB7	TEMP2	;Set EEPROM write active mask
   824 00:E2B1: 20 C5 E2     					JSR	COMPLP	;Call routine to write/compare
   825 00:E2B4: 6F D3 04     					BBR6	TEMP2,PRG_GOOD	;Skip down if no error
   826 00:E2B7: A9 25        					LDA	#$25	;Get Prog failed message
   827 00:E2B9: 80 07        					BRA	BRA_PRMPT	;Branch to Prompt routine
   828                        ;
   829 00:E2BB: A9 24        PRG_GOOD	LDA	#$24	;Get completed message
   830 00:E2BD: 20 35 E7     					JSR	PROMPT	;Send to console
   831 00:E2C0: A9 26        					LDA	#$26	;Get warning message for RTC and Reset
   832 00:E2C2: 4C 35 E7     BRA_PRMPT	JMP	PROMPT	;Send to console and exit
   833                        ;
   834 00:E2C5: A5 CC        COMPLP		LDA	LENL	;Get low byte of length
   835 00:E2C7: 05 CD        					ORA	LENH	;OR in High byte of length
   836 00:E2C9: F0 71        					BEQ	QUITMV	;If zero, nothing to compare/write
   837 00:E2CB: 7F D3 03     					BBR7	TEMP2,SKP_BURN	;Skip burn if bit 7 clear
   838 00:E2CE: 20 00 00     					JSR	BURN_BYTE	;Else Burn a byte to EEPROM
   839 00:E2D1: B2 C8        SKP_BURN	LDA	(SRCL)	;Else load source
   840 00:E2D3: D2 CA        					CMP	(TGTL)	;Compare to source
   841 00:E2D5: F0 12        					BEQ	CMP_OK	;If compare is good, continue
   842                        ;
   843 00:E2D7: E7 D3        					SMB6	TEMP2	;Set bit 6 of TEMP2 flag (compare error)
   844 00:E2D9: 20 19 E1     					JSR	SPC2	;Send 2 spaces
   845 00:E2DC: 20 21 E1     					JSR	DOLLAR	;Print $ sign
   846 00:E2DF: A5 CB        					LDA	TGTH	;Get high byte of address
   847 00:E2E1: A4 CA        					LDY	TGTL	;Get Low byte of address
   848 00:E2E3: 20 64 E1     					JSR	PRWORD	;Print word
   849 00:E2E6: 20 1C E1     					JSR	SPC	;Add 1 space for formatting
   850                        ;
   851 00:E2E9: 20 D9 E0     CMP_OK		JSR	UPD_STL	;Update pointers
   852 00:E2EC: 80 D7        					BRA	COMPLP	;Loop back until done
   853                        ;
   854                        ;Parameters for move memory entered and validated
   855                        ; now make decision on which direction to do the actual move
   856                        ; if overlapping, move from end to start, else from start to end
   857 00:E2EE: 20 BA E1     MOVER			JSR	CONTINUE	;Prompt to continue move
   858 00:E2F1: 38           					SEC	;Set carry flag for subtract
   859 00:E2F2: A5 CA        					LDA	TGTL	;Get target lo byte
   860 00:E2F4: E5 C8        					SBC	SRCL	;Subtract source lo byte
   861 00:E2F6: AA           					TAX	;Move to X reg temporarily
   862 00:E2F7: A5 CB        					LDA	TGTH	;Get target hi byte
   863 00:E2F9: E5 C9        					SBC	SRCH	;Subtract source hi byte
   864 00:E2FB: A8           					TAY	;Move to Y reg temporarily
   865 00:E2FC: 8A           					TXA	;Xfer lo byte difference to A reg
   866 00:E2FD: C5 CC        					CMP	LENL	;Compare to lo byte length
   867 00:E2FF: 98           					TYA	;Xfer hi byte difference to A reg
   868 00:E300: E5 CD        					SBC	LENH	;Subtract length lo byte
   869 00:E302: 90 0F        					BCC	RIGHT	;If carry is clear, overwrite condition exists
   870                        ;Move memory block first byte to last byte, no overlap condition
   871 00:E304: A5 CC        MVNO_LP		LDA	LENL	;Get length low byte
   872 00:E306: 05 CD        					ORA	LENH	;OR in length high byte
   873 00:E308: F0 32        					BEQ	QUITMV	;Exit if zero bytes to move
  Sun Mar  3 2019 23:01                                                                                                    Page 15


   874 00:E30A: B2 C8        					LDA	(SRCL)	;Load source data
   875 00:E30C: 92 CA        					STA	(TGTL)	;Store as target data
   876 00:E30E: 20 D9 E0     					JSR	UPD_STL	;Update Source/Target/Length variables
   877 00:E311: 80 F1        					BRA	MVNO_LP	;Branch back until length is zero
   878                        ;
   879                        ;Move memory block last byte to first byte
   880                        ; avoids overwrite in source/target overlap
   881 00:E313: A6 CD        RIGHT			LDX	LENH	;Get the length hi byte count
   882 00:E315: 18           					CLC	;Clear carry flag for add
   883 00:E316: 8A           					TXA	;Xfer High page to A reg
   884 00:E317: 65 C9        					ADC	SRCH	;Add in source hi byte
   885 00:E319: 85 C9        					STA	SRCH	;Store in source hi byte
   886 00:E31B: 18           					CLC	;Clear carry for add
   887 00:E31C: 8A           					TXA	;Xfer High page to A reg 
   888 00:E31D: 65 CB        					ADC	TGTH	;Add to target hi byte
   889 00:E31F: 85 CB        					STA	TGTH	;Store to target hi byte
   890 00:E321: E8           					INX	;Increment high page value for use below in loop
   891 00:E322: A4 CC        					LDY	LENL	;Get length lo byte
   892 00:E324: F0 0E        					BEQ	MVPG	;If zero no partial page to move
   893 00:E326: 88           					DEY	;Else, decrement page byte index
   894 00:E327: F0 07        					BEQ	MVPAG	;If zero, no pages to move
   895 00:E329: B1 C8        MVPRT			LDA	(SRCL),Y	;Load source data
   896 00:E32B: 91 CA        					STA	(TGTL),Y	;Store to target data
   897 00:E32D: 88           					DEY	;Decrement index
   898 00:E32E: D0 F9        					BNE  MVPRT	;Branch back until partial page moved
   899 00:E330: B1 C8        MVPAG			LDA	(SRCL),Y	;Load source data
   900 00:E332: 91 CA        					STA	(TGTL),Y	;Store to target data
   901 00:E334: 88           MVPG			DEY	;Decrement page count
   902 00:E335: C6 C9        					DEC	SRCH	;Decrement source hi page
   903 00:E337: C6 CB        					DEC	TGTH	;Decrement target hi page
   904 00:E339: CA           					DEX	;Decrement page count
   905 00:E33A: D0 ED        					BNE	MVPRT	;Loop back until all pages moved
   906 00:E33C: 60           QUITMV		RTS	;Return to caller
   907                        ;
   908 00:E33D: 78           BYTE_WRS	SEI	;Disable interrupts
   909 00:E33E: B2 C8        					LDA	(SRCL)	;Get source byte
   910 00:E340: 92 CA        					STA	(TGTL)	;Write to target byte
   911 00:E342: B2 CA        					LDA	(TGTL)	;Read target byte (EEPROM)
   912 00:E344: 29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
   913 00:E346: 85 D4        BYTE_WLP	STA	TEMP3	;Store in Temp location
   914 00:E348: B2 CA        					LDA	(TGTL)	;Read target byte again (EEPROM)
   915 00:E34A: 29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
   916 00:E34C: C5 D4        					CMP	TEMP3	;Compare to last read (toggles if write mode)
   917 00:E34E: D0 F6        					BNE	BYTE_WLP	;Branch back if not done
   918 00:E350: 58           					CLI	;Re-enable interrupts
   919 00:E351: 60           BYTE_WRE	RTS	;Return to caller
   920                        ;
   921                        ;[D] HEX/TEXT DUMP command:
   922                        ; Display in HEX followed by TEXT the contents of 256 consecutive memory addresses
   923 00:E352: F7 D5        MDUMP			SMB7	CMDFLAG	;Set Command flag
   924 00:E354: 20 8E E0     					JSR	SETUP	;Request HEX address input from terminal
   925 00:E357: D0 08        					BNE	LINED	;Branch if new address entered (Z flag set already)
   926 00:E359: A5 C2        					LDA	TEMP1L	;Else, point to next consecutive memory page
   927 00:E35B: 85 C0        					STA	INDEXL	;address saved during last memory dump
   928 00:E35D: A5 C3        					LDA	TEMP1H	;xfer high byte of address
   929 00:E35F: 85 C1        					STA	INDEXH	;save in pointer
   930 00:E361: 20 A3 E3     LINED			JSR	DMPGR	;Send address offsets to terminal 
   931 00:E364: 20 36 E1     					JSR	GLINE	;Send horizontal line to terminal
   932 00:E367: 20 29 E1     					JSR	CROUT	;Send CR,LF to terminal
   933 00:E36A: A2 10        					LDX	#$10	;Set line count for 16 rows
   934 00:E36C: 20 16 E1     DLINE			JSR	SPC4	;Send 4 Spaces to terminal
   935 00:E36F: 20 5D E1     					JSR	PRINDEX	;Print INDEX value
   936 00:E372: 20 19 E1     					JSR	SPC2	;Send 2 Spaces to terminal
  Sun Mar  3 2019 23:01                                                                                                    Page 16


   937 00:E375: A0 00        					LDY	#$00	;Initialize line byte counter
   938 00:E377: B1 C0        GETBYT		LDA	(INDEXL),Y	;Read indexed byte
   939 00:E379: 20 4E E1     					JSR	PRBYTE	;Display byte as a HEX value
   940 00:E37C: 20 1C E1     					JSR	SPC	;Send Space to terminal
   941 00:E37F: C8           					INY	;Increment index
   942 00:E380: C0 10        					CPY	#$10	;Check for all 16
   943 00:E382: D0 F3        					BNE	GETBYT	;loop back until 16 bytes have been displayed
   944 00:E384: 20 1C E1     					JSR	SPC	;Send a space
   945 00:E387: B2 C0        GETBYT2		LDA	(INDEXL)	;Read indexed byte
   946 00:E389: 20 41 E1     					JSR	PRASC	;Print ASCII character
   947 00:E38C: 20 F7 E0     					JSR	INCINDEX	;Increment index
   948 00:E38F: 88           					DEY	;Decrement count (from 16)
   949 00:E390: D0 F5        					BNE	GETBYT2	;loop back until 16 bytes have been displayed		
                    			
   950 00:E392: 20 29 E1     					JSR	CROUT	;else, send CR,LF to terminal
   951 00:E395: A5 C0        					LDA	INDEXL	;Get current index low
   952 00:E397: 85 C2        					STA	TEMP1L	;Save to temp1 low
   953 00:E399: A5 C1        					LDA	INDEXH	;Get current index high
   954 00:E39B: 85 C3        					STA	TEMP1H	;Save to temp1 high
   955 00:E39D: CA           					DEX	;Decrement line count
   956 00:E39E: D0 CC        					BNE	DLINE	;Branch back until all 16 done
   957 00:E3A0: 20 36 E1     					JSR	GLINE	;Send horizontal line to terminal
   958                        ;DMPGR subroutine: Send address offsets to terminal
   959 00:E3A3: A9 02        DMPGR			LDA	#$02	;Get msg for "addr:" to terminal
   960 00:E3A5: 20 35 E7     					JSR	PROMPT	;Send to terminal
   961 00:E3A8: 20 19 E1     					JSR	SPC2	;Add two additional spaces
   962 00:E3AB: A2 00        					LDX	#$00	;Zero index count
   963 00:E3AD: 8A           MDLOOP		TXA	;Send "00" thru "0F", separated by 1 Space, to terminal
   964 00:E3AE: 20 4E E1     					JSR	PRBYTE	;Print byte value
   965 00:E3B1: 20 1C E1     					JSR	SPC	;Add a space
   966 00:E3B4: E8           					INX	;Increment the count
   967 00:E3B5: E0 10        					CPX	#$10	;Check for 16
   968 00:E3B7: D0 F4        					BNE	MDLOOP	;Loop back until done
   969                        ;	Print the ASCII text header "0123456789ABCDEF"
   970 00:E3B9: 20 1C E1     					JSR	SPC	;Send a space
   971 00:E3BC: A2 00        					LDX	#$00	;Zero X reg for "0"
   972 00:E3BE: 8A           MTLOOP		TXA	;Xfer to A reg
   973 00:E3BF: 20 48 E0     					JSR	BIN2ASC	;Convert Byte to two ASCII digits
   974 00:E3C2: 98           					TYA	;Xfer the low nibble character to A reg
   975 00:E3C3: 20 19 F8     					JSR	CHROUT	;Send least significant HEX to terminal
   976 00:E3C6: E8           					INX	;Increment to next HEX character
   977 00:E3C7: E0 10        					CPX	#$10	;Check for 16
   978 00:E3C9: D0 F3        					BNE	MTLOOP	:branch back till done
   979 00:E3CB: 4C 29 E1     					JMP	CROUT	;Do a CR/LF and return
   980                        ;
   981                        ;[E] Examine/Edit command: Display in HEX then change the contents of a specified memory address
   982 00:E3CE: 20 8E E0     CHANGE		JSR	SETUP	;Request HEX address input from terminal
   983 00:E3D1: 20 19 E1     CHNG_LP		JSR	SPC2	;Send 2 spaces
   984 00:E3D4: B2 C0        					LDA	(INDEXL)	;Read specified address
   985 00:E3D6: 20 4E E1     					JSR	PRBYTE	;Display HEX value read
   986 00:E3D9: 20 0E E1     					JSR	BSOUT3T ;Send 3 Backspaces
   987 00:E3DC: 20 A6 E0     					JSR	HEXIN2	;Get input, result in A reg
   988 00:E3DF: 92 C0        					STA	(INDEXL)	;Save entered value at Index pointer
   989 00:E3E1: D2 C0        					CMP	(INDEXL)	;Compare to ensure a match
   990 00:E3E3: F0 05        					BEQ	CHOK	;Branch if compare is good
   991 00:E3E5: A9 3F        					LDA	#$3F	;Get "?" for bad compare
   992 00:E3E7: 20 19 F8     					JSR	CHROUT	;Send to terminal
   993 00:E3EA: 20 F7 E0     CHOK			JSR	INCINDEX	;Increment Index
   994 00:E3ED: 80 E2        					BRA	CHNG_LP	;Loop to continue command
   995                        ;
   996                        ;[G] GO command: Begin executing program code at a specified address
   997                        ;Prompts the user for a start address, places it in COMLO/COMHI
   998                        ;If no address entered, uses default address at COMLO/COMHI
  Sun Mar  3 2019 23:01                                                                                                    Page 17


   999                        ;Loads the A,X,Y,P registers from presets and does a JSR to the routine
  1000                        ;Upon return, registers are saved back to presets for display later
  1001                        ;Also saves the stack pointer and status register upon return
  1002                        ;Stack pointer is not changed due to constant IRQ service routines
  1003 00:E3EF: F7 D5        GO				SMB7	CMDFLAG	;Set Command flag
  1004 00:E3F1: 20 8E E0     					JSR	SETUP	;Get HEX address (A/Y regs hold 16-bit value)
  1005 00:E3F4: F0 04        					BEQ	EXEC_GO	;If not, setup registers and execute (Z flag set alr
                    eady)
  1006 00:E3F6: 85 BE        					STA	COMLO	;Save entered address to pointer low byte
  1007 00:E3F8: 84 BF        					STY	COMHI	;Save entered address to pointer hi byte
  1008                        ;Preload all 65C02 MPU registers from monitor's preset/result variables
  1009 00:E3FA: A5 E2        EXEC_GO		LDA	PREG	;Load processor status register preset
  1010 00:E3FC: 48           					PHA	;Push it to the stack
  1011 00:E3FD: A5 E6        					LDA	AREG	;Load A-Reg preset
  1012 00:E3FF: A6 E5        					LDX	XREG	;Load X-Reg preset
  1013 00:E401: A4 E4        					LDY	YREG	;Load Y-Reg preset
  1014 00:E403: 28           					PLP	;Pull the processor status register
  1015                        ;Call user program code as a subroutine
  1016 00:E404: 20 16 E4     					JSR	DOCOM	;Execute code at specified address
  1017                        ;Store all 65C02 MPU registers to monitor's preset/result variables: store results
  1018 00:E407: 08           					PHP	;Save the processor status register to the stack
  1019 00:E408: 85 E6        					STA	AREG	;Store A-Reg result
  1020 00:E40A: 86 E5        					STX	XREG	;Store X-Reg result
  1021 00:E40C: 84 E4        					STY	YREG	;Store Y-Reg result
  1022 00:E40E: 68           					PLA	;Get the processor status register
  1023 00:E40F: 85 E2        					STA	PREG	;Store the result
  1024 00:E411: BA           					TSX	;Xfer stack pointer to X-reg
  1025 00:E412: 86 E3        					STX	SREG	;Store the result
  1026 00:E414: D8           					CLD	;Clear BCD mode in case of sloppy user code ;-)
  1027 00:E415: 60           TXT_EXT		RTS	;Return to caller
  1028 00:E416: 6C BE 00     DOCOM			JMP	(COMLO)	;Execute the command
  1029                        ;
  1030                        ;[T] LOCATE TEXT STRING command: search memory for an entered text string
  1031                        ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
  1032                        ;SRCHTXT subroutine: request 1 - 16 character text string from terminal, followed by Return
  1033                        ;[ESCAPE] aborts, [BACKSPACE] erases last keystroke. String will be stored in SRCHBUFF
  1034 00:E419: A9 08        SRCHTXT		LDA	#$08	;Get msg " find text:"
  1035 00:E41B: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1036 00:E41E: A2 00        					LDX	#$00	;Initialize index/byte counter
  1037 00:E420: 20 06 F8     STLOOP		JSR	CHRIN	;Get input from terminal
  1038 00:E423: C9 0D        					CMP	#$0D	;Check for C/R
  1039 00:E425: F0 3B        					BEQ	SRCHRDY	;Branch to search engine
  1040 00:E427: C9 1B        					CMP	#$1B	;Check for ESC
  1041 00:E429: F0 EA        					BEQ	TXT_EXT	;Exit to borrowed RTS
  1042 00:E42B: C9 08        					CMP	#$08	;Check for B/S
  1043 00:E42D: D0 09        					BNE	STBRA	;If not, store character into buffer
  1044 00:E42F: 8A           					TXA	;Xfer count to A reg
  1045 00:E430: F0 EE        					BEQ	STLOOP	;Branch to input if zero
  1046 00:E432: 20 03 E1     					JSR	BSOUT	;Else, send B/S to terminal
  1047 00:E435: CA           					DEX	;Decrement index/byte counter
  1048 00:E436: 80 E8        					BRA	STLOOP	;Branch back and continue
  1049 00:E438: 9D 40 03     STBRA			STA	SRCHBUFF,X	;Store character in buffer location
  1050 00:E43B: 20 19 F8     					JSR	CHROUT	;Send character to terminal
  1051 00:E43E: E8           					INX	;Increment counter
  1052 00:E43F: E0 10        					CPX	#$10	;Check count for 16
  1053 00:E441: D0 DD        					BNE	STLOOP	;Loop back for another character
  1054 00:E443: 80 1D        					BRA	SRCHRDY	;Branch to search engine
  1055                        ;
  1056                        ;[H] LOCATE BYTE STRING command: search memory for an entered byte string
  1057                        ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
  1058                        ;SRCHBYT subroutine: request 0 - 16 byte string from terminal, each byte followed by Return
  1059                        ;[ESCAPE] aborts. HEX data will be stored in SRCHBUFF
  1060 00:E445: F7 D5        SRCHBYT		SMB7	CMDFLAG	;Set Command flag
  Sun Mar  3 2019 23:01                                                                                                    Page 18


  1061 00:E447: A9 09        					LDA	#$09	;Get msg " find bin:"
  1062 00:E449: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1063 00:E44C: A2 00        					LDX	#$00	;Initialize index
  1064 00:E44E: DA           SBLOOP		PHX	;Save index on stack
  1065 00:E44F: 20 A6 E0     					JSR	HEXIN2	;Request HEX byte
  1066 00:E452: 20 1C E1     					JSR	SPC	;Send space to terminal
  1067 00:E455: FA           					PLX	;Restore index from stack
  1068 00:E456: A4 CE        					LDY	BUFIDX	;Get # of characters entered 
  1069 00:E458: F0 08        					BEQ	SRCHRDY ;Branch if no characters
  1070 00:E45A: 9D 40 03     					STA	SRCHBUFF,X ;Else, store in buffer
  1071 00:E45D: E8           					INX	;Increment index
  1072 00:E45E: E0 10        					CPX	#$10	;Check for 16 (max)
  1073 00:E460: D0 EC        					BNE	SBLOOP	;Loop back until done/full
  1074 00:E462: 86 D0        SRCHRDY		STX	IDX	;Save input character count
  1075 00:E464: E0 00        					CPX	#$00	;Check buffer count
  1076 00:E466: F0 AD        					BEQ	TXT_EXT	;Exit if no bytes in buffer
  1077 00:E468: A9 0C        					LDA	#$0C	;Else, get msg "Searching.."
  1078 00:E46A: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1079                        ;
  1080                        ;SENGINE subroutine: Scan memory range $0800 through $FFFF for exact match to string
  1081                        ;contained in buffer SRCHBUFF (1 to 16 bytes/characters). Display address of first
  1082                        ;byte/character of each match found until the end of memory is reached.
  1083 00:E46D: A9 08        SENGINE		LDA	#$08	;Initialize address to $0800: skip over $0000 through $07FF
  1084 00:E46F: 85 C1        					STA	INDEXH	;Store high byte
  1085 00:E471: 64 C0        					STZ	INDEXL ;Zero low byte
  1086 00:E473: A2 00        SENGBR2		LDX	#$00	;Initialize buffer index
  1087 00:E475: B2 C0        SENGBR3		LDA	(INDEXL)	;Read current memory location
  1088 00:E477: DD 40 03     					CMP	SRCHBUFF,X	;Compare to search buffer
  1089 00:E47A: F0 05        					BEQ	SENGBR1	;Branch for a match
  1090 00:E47C: 20 B4 E4     					JSR	SINCPTR	;Increment pointer, test for end of memory
  1091 00:E47F: 80 F2        					BRA	SENGBR2	;Loop back to continue
  1092 00:E481: 20 B4 E4     SENGBR1		JSR	SINCPTR	;Increment pointer, test for end of memory
  1093 00:E484: E8           					INX	;Increment buffer index
  1094 00:E485: E4 D0        					CPX	IDX	;Compare buffer index to address index
  1095 00:E487: D0 EC        					BNE	SENGBR3	;Loop back until done
  1096 00:E489: 38           					SEC	;Subtract buffer index from memory pointer; Set carry
  1097 00:E48A: A5 C0        					LDA	INDEXL	;Get current address for match lo byte
  1098 00:E48C: E5 D0        					SBC	IDX	;Subtract from buffer index
  1099 00:E48E: 85 C0        					STA	INDEXL	;Save it back to lo address pointer
  1100 00:E490: A5 C1        					LDA	INDEXH	;Get current address for match hi byte
  1101 00:E492: E9 00        					SBC	#$00	;Subtract carry flag
  1102 00:E494: 85 C1        					STA	INDEXH	;Save it back to hi address pointer
  1103 00:E496: A9 0B        					LDA	#$0B	;Get msg "found"
  1104 00:E498: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1105 00:E49B: A9 3A        					LDA	#':'	;Get Ascii colon
  1106 00:E49D: 20 19 F8     					JSR	CHROUT	;Send to console
  1107 00:E4A0: 20 5D E1     					JSR	PRINDEX	;Print Index address
  1108 00:E4A3: A9 0D        					LDA	#$0D	;Get msg "(n)ext? "
  1109 00:E4A5: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1110 00:E4A8: 20 B0 E1     					JSR	RDCHAR	;Get input from terminal
  1111 00:E4AB: C9 4E        					CMP	#$4E	;Check for "(n)ext"
  1112 00:E4AD: D0 38        					BNE	NCAREG	;Exit if not requesting next
  1113 00:E4AF: 20 B4 E4     					JSR	SINCPTR	;Increment address pointer, test for end of memory
  1114 00:E4B2: 80 BF        					BRA	SENGBR2	;Branch back and continue till done
  1115                        ;
  1116                        ;Increment memory address pointer. If pointer high byte = 00 (end of searchable ROM memory),
  1117                        ;send "not found" to terminal then return to monitor 
  1118 00:E4B4: 20 F7 E0     SINCPTR		JSR	INCINDEX	;Increment Index pointer
  1119 00:E4B7: A5 C1        					LDA	INDEXH	;Check for wrap to $0000
  1120 00:E4B9: D0 2C        					BNE	NCAREG	;If not, return
  1121 00:E4BB: 68           					PLA	;Else, Pull return address from stack
  1122 00:E4BC: 68           					PLA	;and exit with msg
  1123 00:E4BD: A9 0A        					LDA	#$0A	;Get msg "not found"
  Sun Mar  3 2019 23:01                                                                                                    Page 19


  1124 00:E4BF: 4C 35 E7     					JMP	PROMPT	;Send msg to terminal and exit
  1125                        ;
  1126                        ;[P] Processor Status command: Display then change PS preset/result
  1127 00:E4C2: A9 0E        PRG				LDA	#$0E	;Get MSG # for Processor Status register
  1128 00:E4C4: 80 0E        					BRA	REG_UPT	;Finish register update
  1129                        ;
  1130                        ;[S] Stack Pointer command: Display then change SP preset/result
  1131 00:E4C6: A9 0F        SRG				LDA	#$0F	;Get MSG # for Stack register
  1132 00:E4C8: 80 0A        					BRA	REG_UPT	;Finish Register update
  1133                        ;
  1134                        ;[Y] Y-Register command: Display then change Y-reg preset/result
  1135 00:E4CA: A9 10        YRG				LDA	#$10	;Get MSG # for Y Reg
  1136 00:E4CC: 80 06        					BRA	REG_UPT	;Finish register update
  1137                        ;
  1138                        ;[X] X-Register command: Display then change X-reg preset/result
  1139 00:E4CE: A9 11        XRG				LDA	#$11	;Get MSG # for X Reg
  1140 00:E4D0: 80 02        					BRA	REG_UPT	;Finish register update
  1141                        ;
  1142                        ;[A] A-Register command: Display then change A-reg preset/result
  1143 00:E4D2: A9 12        ARG				LDA	#$12	;Get MSG # for A reg
  1144                        ;
  1145 00:E4D4: 48           REG_UPT		PHA	;Save MSG # to stack
  1146 00:E4D5: AA           					TAX	;Xfer to X reg
  1147 00:E4D6: 20 35 E7     					JSR	PROMPT	;Print Register message
  1148 00:E4D9: B5 D4        					LDA	PREG-$0E,X	;Read Register (A,X,Y,S,P) preset/result
  1149 00:E4DB: 20 4E E1     					JSR	PRBYTE	;Display HEX value of register
  1150 00:E4DE: 20 1C E1     					JSR	SPC	;Send [SPACE] to terminal
  1151 00:E4E1: 20 A6 E0     					JSR	HEXIN2	;Get up to 2 HEX characters
  1152 00:E4E4: FA           					PLX	;Get MSG # from stack
  1153 00:E4E5: 95 D4        					STA	PREG-$0E,X	;Write register (A,X,Y,S,P) preset/result
  1154 00:E4E7: 60           NCAREG		RTS	;Return to caller
  1155                        ;
  1156                        ;[R] REGISTERS command: Display contents of all preset/result memory locations
  1157 00:E4E8: 20 19 F8     PRSTAT		JSR	CHROUT	;Send "R" to terminal
  1158 00:E4EB: A9 13        PRSTAT1		LDA	#$13	;Get Header msg
  1159 00:E4ED: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1160 00:E4F0: A5 E1        					LDA	PCH	;Get PC high byte
  1161 00:E4F2: A4 E0        					LDY	PCL	;Get PC low byte
  1162 00:E4F4: 20 64 E1     					JSR	PRWORD	;Print 16-bit word
  1163 00:E4F7: 20 1C E1     					JSR	SPC	;Send 1 space
  1164                        ;
  1165 00:E4FA: A2 04        					LDX	#$04	;Set for count of 4
  1166 00:E4FC: B5 E2        REGPLOOP	LDA	PREG,X	;Start with A reg variable
  1167 00:E4FE: 20 4E E1     					JSR	PRBYTE	;Print it
  1168 00:E501: 20 1C E1     					JSR	SPC	;Send 1 space
  1169 00:E504: CA           					DEX	;Decrement count
  1170 00:E505: D0 F5        					BNE	REGPLOOP	;Loop back till all 4 are sent
  1171                        ;
  1172 00:E507: A5 E2        					LDA	PREG	;Get Status register preset
  1173 00:E509: A2 08        					LDX	#$08	;Get the index count for 8 bits
  1174 00:E50B: 0A           SREG_LP		ASL	A	;Shift bit into Carry
  1175 00:E50C: 48           					PHA	;Save current (shifted) SR value
  1176 00:E50D: A9 30        					LDA	#$30	;Load an Ascii zero
  1177 00:E50F: 69 00        					ADC	#$00	;Add zero (with Carry)
  1178 00:E511: 20 19 F8     					JSR	CHROUT	;Print bit value (0 or 1)
  1179 00:E514: 68           					PLA	;Get current (shifted) SR value
  1180 00:E515: CA           					DEX	;Decrement bit count
  1181 00:E516: D0 F3        					BNE	SREG_LP	;Loop back until all 8 printed
  1182 00:E518: 4C 29 E1     					JMP	CROUT	;Send CR/LF and return
  1183                        ;
  1184                        ;[I] command: TEXT ENTRY enter ASCII text beginning at a specified address
  1185 00:E51B: 20 8E E0     TEXT			JSR	SETUP	;Send "I" command, handle setup
  1186 00:E51E: 20 29 E1     EDJMP1		JSR	CROUT	;Send CR,LF to terminal
  Sun Mar  3 2019 23:01                                                                                                    Page 20


  1187 00:E521: 85 C4        					STA	TEMP2L	;Save current edit address
  1188 00:E523: 84 C5        					STY	TEMP2H	;Save high byte
  1189 00:E525: 20 06 F8     EDJMP2		JSR	CHRIN	;Request a keystroke from terminal
  1190 00:E528: C9 1B        					CMP	#$1B	;Check for end text entry
  1191 00:E52A: F0 3C        					BEQ	EDITDUN	;Branch and close out if yes
  1192 00:E52C: C9 0D        					CMP	#$0D	;Else, check for Return key
  1193 00:E52E: D0 12        					BNE	ENOTRET	;Branch if not
  1194 00:E530: 92 C0        					STA	(INDEXL)	;Save CR to current Index pointer
  1195 00:E532: 20 F7 E0     					JSR	INCINDEX	;Increment edit memory address pointer
  1196 00:E535: A9 0A        					LDA	#$0A	;Get a LF character
  1197 00:E537: 92 C0        					STA	(INDEXL)	;Store it in memory
  1198 00:E539: 20 F7 E0     					JSR	INCINDEX	;Increment edit memory address pointer
  1199 00:E53C: A5 C0        					LDA	INDEXL	;Get Start of next line
  1200 00:E53E: A4 C1        					LDY	INDEXH	;and the high byte
  1201 00:E540: 80 DC        					BRA	EDJMP1	;Loop back to continue 
  1202 00:E542: C9 08        ENOTRET		CMP	#$08	;Check for backspace character
  1203 00:E544: F0 0A        					BEQ	EDBKSPC	;Branch if yes
  1204 00:E546: 92 C0        					STA	(INDEXL)	;Else, save to current Index pointer
  1205 00:E548: 20 19 F8     					JSR	CHROUT	;Send keystroke to terminal
  1206 00:E54B: 20 F7 E0     					JSR	INCINDEX	;Increment edit memory address pointer
  1207 00:E54E: 80 D5        					BRA	EDJMP2	;Loop back to EDJMP2
  1208                        ;Handle Backspace, don't allow past starting address
  1209 00:E550: A5 C0        EDBKSPC		LDA	INDEXL	;Get current index low byte
  1210 00:E552: C5 C4        					CMP	TEMP2L	;Compare to initial start address
  1211 00:E554: D0 06        					BNE	EDDOBKS	;if not equal, perform backspace
  1212 00:E556: A5 C1        					LDA	INDEXH	;Get current index high byte
  1213 00:E558: C5 C5        					CMP	TEMP2H	;Compare to initial start address
  1214 00:E55A: F0 C9        					BEQ	EDJMP2	;If same, branch to input loop
  1215 00:E55C: 20 03 E1     EDDOBKS		JSR	BSOUT	;Send backspace to terminal
  1216 00:E55F: 20 EE E0     					JSR	DECINDEX	;Decrement edit memory address pointer
  1217 00:E562: A9 00        					LDA	#$00	;Get a null character
  1218 00:E564: 92 C0        					STA	(INDEXL)	;Store in place of character
  1219 00:E566: 80 BD        					BRA	EDJMP2	;LOOP back to EDJMP2
  1220 00:E568: 20 26 E1     EDITDUN		JSR	CR2	;Send 2 CR,LF to terminal
  1221 00:E56B: 4C 5D E1     					JMP	PRINDEX	;Print INDEX value
  1222                        ;
  1223                        ;[CTRL-B] Start Enhanced Basic:
  1224 00:E56E: A9 2F        EHBASIC		LDA	#$2F	;Get EhBasic intro Msg
  1225 00:E570: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1226                        ;
  1227 00:E573: 20 B0 E1     EHB_TRY2	JSR	RDCHAR	;Get character (LC2UC)
  1228 00:E576: C9 43        					CMP	#"C"	;Check for Cold start
  1229 00:E578: F0 09        					BEQ	EHB_COLD	;If yes, go Cold Start
  1230 00:E57A: C9 57        					CMP	#"W"	;Check for Warm start
  1231 00:E57C: F0 08        					BEQ	EHB_WARM	;If yes. go Warm start
  1232 00:E57E: 20 FE E0     					JSR	BEEP	;Else, beep for entry error
  1233 00:E581: 80 F0        					BRA	EHB_TRY2	;Branch back and try again
  1234                        ;
  1235 00:E583: 4C 00 B0     EHB_COLD	JMP	$B000	;Cold start ROM vector
  1236                        ;
  1237 00:E586: 4C 00 00     EHB_WARM	JMP	$0000	;Warm start soft vector
  1238                        ;
  1239                        ;[CTRL-D]	Disassembler
  1240 00:E589: A9 2B        DSSMBLR		LDA	#$2B	;Intro Message
  1241 00:E58B: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1242 00:E58E: A9 03        					LDA	#$03	;Msg 03 -" addr:"
  1243 00:E590: 20 96 E0     					JSR	HEX4	;Print msg and get address
  1244 00:E593: 20 29 E1     					JSR	CROUT	;Send CR,LF to terminal
  1245 00:E596: A2 16        RPT_LST		LDX	#$16	;Set list count to 22
  1246 00:E598: DA           DIS_LOOP	PHX	;Push count to stack
  1247 00:E599: 20 B0 E5     					JSR	DIS_LINE	;Disassemble 1 instruction
  1248 00:E59C: FA           					PLX	;Pull count from stack
  1249 00:E59D: CA           					DEX	;Decrement count
  Sun Mar  3 2019 23:01                                                                                                    Page 21


  1250 00:E59E: D0 F8        					BNE	DIS_LOOP	;Loop back till list count is zero
  1251 00:E5A0: 20 06 F8     LST_LOOP	JSR	CHRIN	;Get input from terminal
  1252 00:E5A3: C9 0D        					CMP	#$0D	;Check for Return key
  1253 00:E5A5: F0 32        					BEQ	EXT_LIST	;Exit if Return
  1254 00:E5A7: C9 20        					CMP	#$20	;Check for Space
  1255 00:E5A9: D0 EB        					BNE	RPT_LST	;If not, go back and list another page
  1256 00:E5AB: 20 B0 E5     					JSR	DIS_LINE	;Else, Disassemble one line
  1257 00:E5AE: 80 F0        					BRA	LST_LOOP	;Branch back and continue
  1258                        ;
  1259                        ;DISASSEMBLE LINE: disassemble 1 instruction from working address
  1260 00:E5B0: 20 5D E1     DIS_LINE	JSR	PRINDEX	;Print working address
  1261 00:E5B3: 20 19 E1     					JSR	SPC2	;Send 2 spaces to terminal
  1262 00:E5B6: B2 C0        					LDA	(INDEXL)	;Read opcode from working memory pointer
  1263 00:E5B8: 85 D6        					STA	OPCODE	;Save opcode
  1264 00:E5BA: 20 21 E6     					JSR	PRB_SPC2	;Print byte, 2 spaces
  1265 00:E5BD: 4A           					LSR	A	;Divide by 2 / shift low order bit into carry flag
  1266 00:E5BE: AA           					TAX	;Xfer Opcode /2 to X reg
  1267 00:E5BF: BD 5D EE     					LDA	HDLR_IDX,X	;Get Pointer to handler table
  1268 00:E5C2: B0 04        					BCS	USE_RGHT	;If carry set use low nibble (odd)
  1269 00:E5C4: 4A           					LSR	A	;Else shift upper nibble to lower nibble (even)
  1270 00:E5C5: 4A           					LSR	A
  1271 00:E5C6: 4A           					LSR	A
  1272 00:E5C7: 4A           					LSR	A
  1273 00:E5C8: 29 0F        USE_RGHT	AND	#$0F	;Mask off high nibble
  1274 00:E5CA: 0A           					ASL	A	;Multiply by 2 for index
  1275 00:E5CB: AA           					TAX	;Use handler pointer to index handler table
  1276 00:E5CC: 20 DA E5     					JSR	DODISL	;Call disassembler handler 
  1277 00:E5CF: 20 29 E1     					JSR	CROUT	;Send CR,LF to terminal
  1278 00:E5D2: 64 D3        					STZ	TEMP2	;Clear all flag bits
  1279                        ;
  1280                        ;INCNDX routine: increment working address pointer then read it
  1281 00:E5D4: 20 F7 E0     INCNDX		JSR	INCINDEX	;Increment working address pointer
  1282 00:E5D7: B2 C0        					LDA	(INDEXL)	;Read from working memory address
  1283 00:E5D9: 60           EXT_LIST	RTS	;Done, return to caller/exit
  1284                        ;
  1285 00:E5DA: 7C DD EE     DODISL		JMP	(HDLR_TAB,X)	;Execute address mode handler
  1286                        ;
  1287                        ;THREE BYTE routine: display operand bytes then mnemonic for three-byte instruction
  1288                        ;TWO BYTE routine: display operand byte then mnemonic for two-byte instruction
  1289 00:E5DD: F7 D3        TRI_BYTE	SMB7	TEMP2	;Set Flag bit for 3-byte instruction
  1290 00:E5DF: 20 1E E6     TWO_BYTE	JSR	GET_NEXT	;Read, display operand byte
  1291 00:E5E2: 85 D8        					STA	CRCLO	;Save operand byte in CRCLO
  1292 00:E5E4: 7F D3 0A     					BBR7	TEMP2,2BYTSPC	;Branch for 2-byte is clear
  1293 00:E5E7: 20 1E E6     					JSR	GET_NEXT	;Read, display operand high byte
  1294 00:E5EA: 85 D7        					STA	CRCHI	;Save operand high byte in CRCHI
  1295 00:E5EC: 80 06        					BRA	3BYTSPC	;Send 2 spaces, send Mnemonic, return
  1296                        ;
  1297                        ;IMPLIED disassembler handler: single byte instructions: implied mode
  1298                        ;(note: ACC_MODE handler calls this)   
  1299 00:E5EE: 20 16 E1     IMPLIED		JSR	SPC4	;Send 4 spaces
  1300 00:E5F1: 20 16 E1     2BYTSPC		JSR	SPC4	;Send 4 spaces
  1301 00:E5F4: 20 19 E1     3BYTSPC		JSR	SPC2	;Send 2 spaces
  1302                        ;
  1303                        ;PRT_MNEM subroutine: send 3 character mnemonic to terminal
  1304                        ; Mnemonic indexed by opcode byte. Sends "???" if byte is not a valid opcode
  1305 00:E5F7: A4 D6        PRT_MNEM	LDY	OPCODE	;Get current Opcode as index
  1306 00:E5F9: BE FD EE     					LDX	MNE_PTAB,Y	;Get opcode pointer from table
  1307 00:E5FC: BD FD EF     					LDA	DIS_NMEM,X	;Get left byte
  1308 00:E5FF: 85 DA        					STA	PTRL	;Store it to pointer
  1309 00:E601: BD FE EF     					LDA	DIS_NMEM+1,X	;Get right byte
  1310 00:E604: 85 DB        					STA	PTRH	;Store it to pointer
  1311 00:E606: A2 03        					LDX	#$03	;Set count for 3 characters
  1312 00:E608: A9 00        NEXT_NME	LDA	#$00	;Zero A reg
  Sun Mar  3 2019 23:01                                                                                                    Page 22


  1313 00:E60A: A0 05        					LDY	#$05	;Set count for 5 bits per character
  1314 00:E60C: 06 DB        LOOP_NME	ASL	PTRH	;Shift right byte into carry
  1315 00:E60E: 26 DA        					ROL	PTRL	;Rotate left byte byte into A reg
  1316 00:E610: 2A           					ROL	A	;Rotate into A reg
  1317 00:E611: 88           					DEY	;Decrement bit count
  1318 00:E612: D0 F8        					BNE	LOOP_NME	;Loop back till 5 bits in A reg
  1319 00:E614: 69 3F        					ADC	#$3F	;Add $3F to convert to Ascii
  1320 00:E616: 20 19 F8     					JSR	CHROUT	;Send the character to terminal
  1321 00:E619: CA           					DEX	;Decrement character count
  1322 00:E61A: D0 EC        					BNE	NEXT_NME	;Loop back till 3 characters sent
  1323 00:E61C: 80 06        					BRA	BR_SPC2	;Send 2 spaces to terminal, return
  1324                        ;
  1325                        ;GET_NEXT subroutine: increment/read working address
  1326                        ; Display byte, send 2 spaces to terminal (displays operand byte(s))
  1327 00:E61E: 20 D4 E5     GET_NEXT	JSR	INCNDX	;Increment working index
  1328 00:E621: 20 4E E1     PRB_SPC2	JSR	PRBYTE	;Display Byte from working index
  1329 00:E624: 4C 19 E1     BR_SPC2		JMP	SPC2	;Send 2 spaces to terminal and return
  1330                        ;
  1331                        ;Disassembler handlers:
  1332                        ;
  1333                        ;LF_BRKT subroutine: send "(" to terminal
  1334 00:E627: A9 28        LF_BRKT		LDA	#$28	;Get "("
  1335 00:E629: 80 0F        					BRA	BR_COUT	;Send to terminal and return
  1336                        ;
  1337                        ;ZP_IMMEDIATE: two byte instructions: zero-page immediate mode
  1338 00:E62B: 20 DF E5     ZP_IMED		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1339 00:E62E: A9 23        					LDA	#$23	;Get "#" character
  1340 00:E630: 20 19 F8     					JSR	CHROUT	;Send to terminal
  1341 00:E633: 80 1B        					BRA	PRT1_OP	;Display operand byte again, return
  1342                        ;
  1343                        ;ACC_MODE: single byte A reg mode instructions: implied mode 
  1344 00:E635: 20 EE E5     ACC_MODE	JSR	IMPLIED	;Send 10 spaces to terminal then display mnemonic
  1345 00:E638: A9 41        					LDA	#$41	;Get "A" character
  1346 00:E63A: 4C 19 F8     BR_COUT		JMP	CHROUT	;Send it and return
  1347                        ;
  1348                        ;ABSOLUTE: three byte instructions: absolute mode 
  1349 00:E63D: 20 DD E5     ABSOLUTE	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1350                        ;
  1351                        ;Print 2 Operands: display operand bytes of a three-byte instruction
  1352 00:E640: 20 21 E1     PRT2_OP		JSR	DOLLAR	;Send "$" to terminal
  1353 00:E643: A5 D7        					LDA	CRCHI	;Load operand high byte
  1354 00:E645: 20 4E E1     					JSR	PRBYTE	;Send to terminal
  1355 00:E648: A5 D8        BR_PRBTE	LDA	CRCLO	;Load operand low byte
  1356 00:E64A: 4C 4E E1     					JMP	PRBYTE	;Send to terminal and return
  1357                        ;
  1358                        ;ZP_ABS: two byte instructions: zero-page absolute
  1359 00:E64D: 20 DF E5     ZP_ABS		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1360                        ;
  1361                        ;Print 1 Operand byte: display operand byte of a two-byte instruction 
  1362 00:E650: 20 21 E1     PRT1_OP		JSR	DOLLAR	;Send "$" to terminal
  1363 00:E653: 80 F3        					BRA	BR_PRBTE	;Branch to complete
  1364                        ;
  1365                        ;INDIRECT: two or three byte instructions: indirect modes
  1366 00:E655: A5 D6        INDIRECT	LDA	OPCODE	;Read saved opcode byte
  1367 00:E657: C9 6C        					CMP	#$6C	;Check for JMP(INDIRECT)
  1368 00:E659: D0 13        					BNE	ZP_IND	;Branch if not
  1369                        ;
  1370 00:E65B: 20 DD E5     					JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1371 00:E65E: 20 27 E6     					JSR	LF_BRKT	;Send "(" to terminal
  1372 00:E661: 20 40 E6     					JSR	PRT2_OP	;Display operand bytes again
  1373 00:E664: 80 0B        					BRA	RT_BRKT	;Send ")" to terminal, return
  1374                        ;
  1375                        ;Following group is used multiple times, space savings
  Sun Mar  3 2019 23:01                                                                                                    Page 23


  1376 00:E666: 20 DF E5     DSPLY3		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1377 00:E669: 20 27 E6     					JSR	LF_BRKT	;Send "(" to terminal
  1378 00:E66C: 80 E2        					BRA	PRT1_OP	;Display operand byte again, return
  1379                        ;
  1380                        ;this is for a two byte instruction: zero page indirect mode 
  1381 00:E66E: 20 66 E6     ZP_IND		JSR	DSPLY3	;Do the 3 routines
  1382                        ;
  1383                        ;RT_BRKT subroutine: send ")" to terminal
  1384 00:E671: A9 29        RT_BRKT		LDA	#$29	;Get ")"
  1385 00:E673: 80 C5        					BRA	BR_COUT	;Send to terminal and return
  1386                        ;
  1387                        ;ZP_ABS_X: two byte instructions: zero-page absolute indexed by X mode  
  1388 00:E675: 20 4D E6     ZP_ABS_X	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
  1389                        ;
  1390                        ;Print Comma,X: send ",X" to terminal
  1391 00:E678: A9 2C        COM_X			LDA	#$2C	;Get ","
  1392 00:E67A: 20 19 F8     					JSR	CHROUT	;Send to terminal
  1393 00:E67D: A9 58        					LDA	#$58	;Get "X"
  1394 00:E67F: 80 B9        					BRA	BR_COUT	;Send to terminal, return
  1395                        ;
  1396                        ;ZP_ABS_Y: two byte instructions: zero-page absolute indexed by Y mode
  1397 00:E681: 20 4D E6     ZP_ABS_Y	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
  1398                        ;
  1399                        ;Print Comma,Y: send ",Y" to terminal
  1400 00:E684: A9 2C        COM_Y			LDA	#$2C	;Get ","
  1401 00:E686: 20 19 F8     					JSR	CHROUT	;Send to terminal
  1402 00:E689: A9 59        					LDA	#$59	;Get "Y"
  1403 00:E68B: 80 AD        					BRA	BR_COUT	;Send to terminal, return
  1404                        ;
  1405                        ;ABS_Y: three byte instructions: absolute indexed by Y mode
  1406                        ;ABS_X: three byte instructions: absolute indexed by X mode
  1407 00:E68D: E7 D3        ABS_Y			SMB6	TEMP2
  1408 00:E68F: 20 DD E5     ABS_X			JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1409 00:E692: 20 40 E6     					JSR	PRT2_OP	;Display operand bytes again
  1410 00:E695: EF D3 EC     					BBS6	TEMP2,COM_Y
  1411 00:E698: 80 DE        					BRA	COM_X	;Send ",X" to terminal, return
  1412                        ;
  1413                        ;ZP_IND_X: two byte instructions: zero-page indirect pre-indexed by X mode  
  1414 00:E69A: 20 66 E6     ZP_IND_X	JSR	DSPLY3	;Do the 3 routines
  1415 00:E69D: 20 78 E6     					JSR	COM_X	;Send ",X" to terminal
  1416 00:E6A0: 80 CF        					BRA	RT_BRKT	;Send ")" to terminal, return
  1417                        ;
  1418                        ;ZP_IND_Y: two byte instructions: zero-page indirect post-indexed by Y mode 
  1419 00:E6A2: 20 66 E6     ZP_IND_Y	JSR	DSPLY3	Do the 3 routines
  1420 00:E6A5: 20 71 E6     					JSR	RT_BRKT	;Send ")" to terminal
  1421 00:E6A8: 80 DA        					BRA	COM_Y	;Send ",Y" to terminal, return
  1422                        ;
  1423                        ;IND_ABS_X: three byte instruction: JMP (INDIRECT,X) 16 bit indirect
  1424 00:E6AA: 20 DD E5     IND_ABS_X	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
  1425 00:E6AD: 20 27 E6     					JSR	LF_BRKT	;Send "(" to terminal
  1426 00:E6B0: 20 40 E6     					JSR	PRT2_OP	;Display operand bytes again
  1427 00:E6B3: 20 78 E6     					JSR	COM_X	;Send ",X" to terminal
  1428 00:E6B6: 80 B9        					BRA	RT_BRKT	;Send ")" to terminal then done INDABSX handler, RET
                    URN
  1429                        ;
  1430                        ;ZP_XMB: two byte instructions: zero page set/clear memory bit
  1431 00:E6B8: 20 15 E7     ZP_XMB		JSR	SRMB	;Display operand byte, mnemonic, isolate bit selector from opcode
  1432 00:E6BB: C9 08        					CMP	#$08	;Check if 0-7 or 8-F
  1433 00:E6BD: 90 02        					BCC	SRBIT	;Just add $30 (0-7)
  1434 00:E6BF: E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
  1435 00:E6C1: 18           SRBIT			CLC	;Convert bit selector value to an ASCII decimal digit
  1436 00:E6C2: 69 30        					ADC	#$30	;add "0" to bit selector value
  1437 00:E6C4: 20 19 F8     					JSR	CHROUT	;Send digit to terminal
  Sun Mar  3 2019 23:01                                                                                                    Page 24


  1438 00:E6C7: 20 1C E1     					JSR	SPC	;Send a space to terminal
  1439 00:E6CA: 80 84        					BRA	PRT1_OP	;Display operand byte again then return
  1440                        ;
  1441                        ;ZP_BBX: three byte instruction: branch on zero-page bit set/clear
  1442 00:E6CC: 20 0D E7     ZP_BBX		JSR	SRMB2	;Display operand bytes, mnemonic, isolate bit selector from opcode
  1443 00:E6CF: C9 08        					CMP	#$08	;Check if $0-$7 or $8-$F
  1444 00:E6D1: 90 02        					BCC	SRBIT2	;Just add $30 ($0-$7)
  1445 00:E6D3: E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
  1446 00:E6D5: 20 C1 E6     SRBIT2		JSR	SRBIT	;Convert and display bit selector digit
  1447 00:E6D8: A5 D7        					LDA	CRCHI	;Move second operand to first operand position: 
  1448 00:E6DA: 85 D8        					STA	CRCLO	;CRCLO = branch offset
  1449 00:E6DC: 20 1C E1     					JSR	SPC	;Send a space to terminal
  1450 00:E6DF: 80 03        					BRA	BBX_REL	;Display branch target address then return
  1451                        ;
  1452                        ;RELATIVE BRANCH: two byte relative branch mode
  1453                        ;BBX_REL: three byte relative branch mode
  1454                        ;both calculate then display relative branch target address 
  1455 00:E6E1: 20 DF E5     REL_BRA		JSR	TWO_BYTE	;Display operand byte, then mnemonic
  1456 00:E6E4: 20 21 E1     BBX_REL		JSR	DOLLAR	;Send "$" to terminal
  1457 00:E6E7: 20 F7 E0     					JSR	INCINDEX	;Increment working address, ref for branch o
                    ffset
  1458 00:E6EA: A5 D8        					LDA	CRCLO	;Get branch operand value
  1459 00:E6EC: 30 0A        					BMI	BRA_MINUS	;Check for $80 or higher (if branch is + or 
                    -)
  1460 00:E6EE: 18           					CLC	;Clear carry for add
  1461 00:E6EF: 65 C0        					ADC	INDEXL	;Add to Index lo
  1462 00:E6F1: A8           					TAY	;Xfer to Y reg
  1463 00:E6F2: A5 C1        					LDA	INDEXH	;Get Index Hi
  1464 00:E6F4: 69 00        					ADC	#$00	;Add result from Carry flag to A reg
  1465 00:E6F6: 80 0F        					BRA	REL_EXT	;Print offset, cleanup, return
  1466 00:E6F8: 49 FF        BRA_MINUS	EOR	#$FF	;Get 1's complement of offset
  1467 00:E6FA: 1A           					INC	A	;Increment by 1
  1468 00:E6FB: 85 D4        					STA  TEMP3	;Save result
  1469 00:E6FD: 38           					SEC	;Set carry for subtract
  1470 00:E6FE: A5 C0        					LDA	INDEXL	;Get address low
  1471 00:E700: E5 D4        					SBC	TEMP3	;Subtract branch offset
  1472 00:E702: A8           					TAY	;Xfer to Y reg
  1473 00:E703: A5 C1        					LDA	INDEXH	;Get address high
  1474 00:E705: E9 00        					SBC	#$00	;Subtract carry flag
  1475 00:E707: 20 64 E1     REL_EXT		JSR	PRWORD	;Send address to terminal
  1476 00:E70A: 4C EE E0     					JMP	DECINDEX	;Decrement working address, return
  1477                        ;
  1478                        ;SRMB2 subroutine: display 2 operand bytes, mnemonic, isolate bit selector from opcode 
  1479                        ;SRMB subroutine: display 1 operand byte, mnemonic, isolate bit selector from opcode 
  1480 00:E70D: B2 C0        SRMB2			LDA	(INDEXL)	;Read from working index
  1481 00:E70F: 48           					PHA	;Save byte to stack
  1482 00:E710: 20 DD E5     					JSR	TRI_BYTE	;Display operand bytes and mnemonic 
  1483 00:E713: 80 06        					BRA	SRM	;Skip down
  1484 00:E715: B2 C0        SRMB			LDA	(INDEXL)	;Read from working index
  1485 00:E717: 48           					PHA	;Save byte on STACK
  1486 00:E718: 20 DF E5     					JSR	TWO_BYTE	;Display operand byte and mnemonic 
  1487 00:E71B: 20 11 E1     SRM				JSR	BSOUT2T	;Send 2 Backspaces
  1488 00:E71E: 68           					PLA	;Restore byte from stack
  1489 00:E71F: 4A           					LSR	A	;Shift high nibble to low nibble
  1490 00:E720: 4A           					LSR	A
  1491 00:E721: 4A           					LSR	A
  1492 00:E722: 4A           					LSR	A
  1493 00:E723: 60           NOCHAR		RTS	;Done SRMB2/SRMB, return
  1494                        ;
  1495                        ;END OF DISASSEMBLER CODE
  1496                        ;
  1497                        ;[CNTRL-V] Version command:
  1498 00:E724: A9 15        VER				LDA	#$15	;Get Intro substring (version)
  Sun Mar  3 2019 23:01                                                                                                    Page 25


  1499 00:E726: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1500 00:E729: A0 FF        					LDY	#>BIOS_MSG	;Get high offset
  1501 00:E72B: A9 E9        					LDA	#<BIOS_MSG	;Get low offset
  1502 00:E72D: 84 C7        PROMPTR		STY	PROMPTH	;Store hi byte
  1503 00:E72F: 85 C6        					STA	PROMPTL	;Store lo byte
  1504 00:E731: 80 0E        					BRA	PROMPT2	;Print message
  1505                        ;
  1506                        ;[CNTRL-Q] Query command:
  1507 00:E733: A9 2C        QUERY			LDA	#$2C	;Get Query msg #
  1508                        ;
  1509                        ;PROMPT routine: Send indexed text string to terminal. Index is A reg
  1510                        ;string buffer address is stored in variable PROMPTL, PROMPTH
  1511                        ;Routine is placed here in the Commands area to save ROM space
  1512 00:E735: 0A           PROMPT		ASL	A	;Multiply by two for msg table index
  1513 00:E736: A8           					TAY	;Xfer to index
  1514 00:E737: B9 FD ED     					LDA	MSG_TABLE,Y	;Get low byte address
  1515 00:E73A: 85 C6        					STA	PROMPTL	;Store in Buffer pointer
  1516 00:E73C: B9 FE ED     					LDA	MSG_TABLE+1,Y	;Get high byte address
  1517 00:E73F: 85 C7        					STA	PROMPTH	;Store in Buffer pointer
  1518                        ;					
  1519 00:E741: B2 C6        PROMPT2		LDA	(PROMPTL)	;Get string data
  1520 00:E743: F0 DE        					BEQ	NOCHAR	;If null character, exit (borrowed RTS)
  1521 00:E745: 20 19 F8     					JSR	CHROUT	;Send character to terminal
  1522 00:E748: E6 C6        					INC	PROMPTL	;Increment low byte index
  1523 00:E74A: D0 F5        					BNE	PROMPT2	;Loop back for next character
  1524 00:E74C: E6 C7        					INC	PROMPTH	;Increment high byte index
  1525 00:E74E: 80 F1        					BRA	PROMPT2	;Loop back and continue printing
  1526                        ;
  1527                        ;[CNTL-T] UPTIME command: Sends a string to the terminal showing the uptime
  1528                        ; of the system since the last system reset. This routine uses the RTC values
  1529                        ; for Days, Hours, Minutes and seconds. It converts each to BCD and outputs
  1530                        ; to the terminal with text fields. The routine does not calculate months/years
  1531                        ;
  1532 00:E750: A9 1A        UPTIME		LDA	#$1A	;Get Uptime message
  1533 00:E752: 20 35 E7     					JSR	PROMPT	;Send to terminal
  1534                        ;
  1535 00:E755: A2 1B        					LDX	#$1B	;Get Days message
  1536 00:E757: A5 F2        					LDA	DAYSL	;Get Days low byte
  1537 00:E759: A4 F3        					LDY	DAYSH	;Get Days high byte
  1538 00:E75B: 20 72 E7     					JSR	DO16TIME	;Convert and send to terminal
  1539                        ;
  1540 00:E75E: A2 1C        					LDX	#$1C	;Get Hours message
  1541 00:E760: A5 F1        					LDA	HOURS	;Get Current Hours (low byte)
  1542 00:E762: 20 70 E7     					JSR	DO8TIME	;Convert and send to terminal
  1543                        ;
  1544 00:E765: A2 1D        					LDX	#$1D	;Get Minutes message
  1545 00:E767: A5 F0        					LDA	MINS	;Get Current Minutes (low byte)
  1546 00:E769: 20 70 E7     					JSR	DO8TIME	;Convert and send to terminal
  1547                        ;
  1548 00:E76C: A2 1E        					LDX	#$1E	;Get seconds message
  1549 00:E76E: A5 EF        					LDA	SECS	;Get Current Seconds (low byte)
  1550                        ;
  1551 00:E770: A0 00        DO8TIME		LDY	#$00	;Zero high byte
  1552 00:E772: DA           DO16TIME	PHX	;Push message number to stack
  1553 00:E773: 20 5E E0     					JSR	HEX2ASC	;Convert and print ASCII string
  1554 00:E776: 68           					PLA	;Pull message number from stack
  1555 00:E777: 80 BC        					BRA	PROMPT	;Branch to Prompt
  1556                        ;
  1557                        ;[CNTRL-L] Xmodem/CRC Loader command: receives a file from console via Xmodem protocol
  1558                        ; no cable swapping needed, uses existing console port and buffer via the terminal program
  1559                        ; not a full blown Xmodem/CRC implementation, only does CRC-16 checking, no fallback
  1560                        ; designed specifically for direct attach to host machine via com port
  1561                        ; can handle full 8-bit binary transfers without error
  Sun Mar  3 2019 23:01                                                                                                    Page 26


  1562                        ; tested with ExtraPutty and TeraTerm (Note: TeraTerm doesn't respond to CAN properly)
  1563                        ;
  1564                        ; Added support for Motorola S-Record formatted files automatically
  1565                        ; A parameter input is used as either a Load address for any non-S-record file
  1566                        ; If the received file has a valid S-Record format, the parameter is used as a
  1567                        ; positive address Offset applied to the specified load address in the S-record file
  1568                        ; supported format is S19 as created by the WDC Tools linker.
  1569                        ; Note: this code supports the execution address in the final S9 record, but WDC Tools
  1570                        ; does not provide any ability to put this into their code build. WDC are aware of this
  1571                        ;
  1572 00:E779: F7 D5        XMODEM		SMB7	CMDFLAG	;Set Command flag
  1573 00:E77B: 64 FE        					STZ	XMFLAG	;Clear Xmodem flag
  1574 00:E77D: A9 01        					LDA	#$01	;Set block count to one
  1575 00:E77F: 85 DC        					STA	BLKNO	;Save it for starting block #
  1576 00:E781: A9 27        					LDA	#$27	;Get Xmodem intro msg
  1577 00:E783: 20 96 E0     					JSR	HEX4	;Print Msg, get Hex load address/S-record Offset
  1578 00:E786: 20 29 E1     					JSR	CROUT	;Send a C/R to show input entered
  1579 00:E789: E0 00        					CPX	#$00	;Check for input entered (if non-zero, use new data)
  1580 00:E78B: D0 03        					BNE	XLINE	;Branch if data entered
  1581 00:E78D: 8A           					TXA	;Xfer to A reg (LDA #$00)
  1582 00:E78E: A0 08        					LDY	#$08	;Set High byte ($0800)
  1583 00:E790: 85 DA        XLINE			STA	PTRL	;Store to Lo pointer
  1584 00:E792: 84 DB        					STY	PTRH	;Store to Hi pointer
  1585                        ;Wait for 5 seconds for user to setup xfer from terminal
  1586 00:E794: A9 02        					LDA	#$02	;Load milliseconds = 2 ms
  1587 00:E796: A2 0A        					LDX	#$0A	;Load High multipler to 10 decimal
  1588 00:E798: A0 FA        					LDY	#$FA	;Load Low multipler to 250 decimal
  1589 00:E79A: 20 30 F8     					JSR	SET_DLY	;Set Delay parameters
  1590 00:E79D: 20 49 F8     					JSR	EXE_LGDLY	;Call long delay for 5 seconds
  1591                        ;
  1592 00:E7A0: A9 43        STRT_XFER	LDA	#"C"	;Send "C" character for CRC mode
  1593 00:E7A2: 20 19 F8     					JSR	CHROUT	;Send to terminal
  1594 00:E7A5: 20 37 F8     CHR_DLY		JSR	EXE_MSDLY	;Delay 2 milliseconds
  1595 00:E7A8: A5 E7        					LDA	ICNT	;Check input buffer count
  1596 00:E7AA: D0 38        					BNE	STRT_BLK	;If a character is in, branch
  1597 00:E7AC: 88           					DEY	;Decrement loop count (250 1st time only)
  1598 00:E7AD: D0 F6        					BNE	CHR_DLY	;Branch and check again 250/256 times
  1599 00:E7AF: 80 EF        					BRA	STRT_XFER	;Else, branch and send another "C"
  1600                        ;
  1601 00:E7B1: A9 06        XDONE			LDA	#ACK	;Last block, get ACK character
  1602 00:E7B3: 20 19 F8     					JSR	CHROUT	;Send final ACK
  1603 00:E7B6: A0 02        					LDY	#$02	;Get delay count
  1604 00:E7B8: A9 28        					LDA	#$28	;Get Good xfer message number
  1605 00:E7BA: 20 18 E2     FLSH_DLY	JSR NOLOOPS	;Zero input buffer pointers
  1606 00:E7BD: 48           					PHA	;Save Message number
  1607 00:E7BE: A9 FA        					LDA	#$FA	;Load milliseconds = 250 ms
  1608 00:E7C0: A2 00        					LDX	#$00	;Load High multipler to 0 decimal
  1609 00:E7C2: 20 30 F8     					JSR	SET_DLY	;Set Delay parameters
  1610 00:E7C5: 20 49 F8     					JSR	EXE_LGDLY	;Execute delay, (wait to get terminal back)
  1611 00:E7C8: 68           					PLA	;Get message number back
  1612 00:E7C9: C9 29        					CMP	#$29	;Check for error msg#
  1613 00:E7CB: F0 14        					BEQ	SHRT_EXIT	;Do only one message
  1614 00:E7CD: 48           					PHA	;Save MSG number
  1615 00:E7CE: 7F FE 0F     					BBR7	XMFLAG,END_LOAD	;Branch if no S-record
  1616 00:E7D1: A9 2A        					LDA	#$2A	;Get S-Record load address msg
  1617 00:E7D3: 20 35 E7     					JSR	PROMPT	;Printer header msg
  1618 00:E7D6: A5 C9        					LDA	SRCH	;Get source high byte
  1619 00:E7D8: A4 C8        					LDY	SRCL	;Get source low byte
  1620 00:E7DA: 20 64 E1     					JSR	PRWORD	;Print Hex address
  1621 00:E7DD: 20 29 E1     					JSR	CROUT	;Print C/R and return
  1622 00:E7E0: 68           END_LOAD	PLA	;Get Message number
  1623 00:E7E1: 4C 35 E7     SHRT_EXIT	JMP	PROMPT	;Print Message and exit
  1624                        ;
  Sun Mar  3 2019 23:01                                                                                                    Page 27


  1625 00:E7E4: 20 06 F8     STRT_BLK	JSR	CHRIN	;Get a character
  1626 00:E7E7: C9 1B        					CMP	#$1B	;Is it escape - quit?
  1627 00:E7E9: F0 0A        					BEQ	XM_END	;If yes, exit
  1628 00:E7EB: C9 01        					CMP	#SOH	;Start of header?
  1629 00:E7ED: F0 07        					BEQ	GET_BLK	;If yes, branch and receive block
  1630 00:E7EF: C9 04        					CMP	#EOT	;End of Transmission?
  1631 00:E7F1: F0 BE        					BEQ	XDONE	;If yes, branch and exit
  1632 00:E7F3: 80 63        					BRA	STRT_ERR	;Else branch to error
  1633 00:E7F5: 60           XM_END		RTS	;Cancelled by user, return
  1634                        ;
  1635 00:E7F6: E7 FE        GET_BLK		SMB6	XMFLAG	;Set bit 6 for Xmodem xfer
  1636 00:E7F8: A2 00        					LDX	#$00	;Zero index for block receive
  1637                        ;
  1638 00:E7FA: 20 06 F8     GET_BLK1	JSR	CHRIN	;Get a character
  1639 00:E7FD: 9D 7C 03     					STA	RBUFF,X	;Move into buffer
  1640 00:E800: E8           					INX	;Increment buffer index
  1641 00:E801: E0 84        					CPX	#$84	;Compare size (<01><FE><128 bytes><CRCH><CRCL>)
  1642 00:E803: D0 F5        					BNE	GET_BLK1	;If not done, loop back and continue
  1643 00:E805: 67 FE        					RMB6	XMFLAG	;Reset Xmodem xfer bit (allows break)
  1644                        ;
  1645 00:E807: AD 7C 03     					LDA	RBUFF	;Get block number from buffer
  1646 00:E80A: C5 DC        					CMP	BLKNO	;Compare to expected block number
  1647 00:E80C: D0 07        					BNE	RESTRT	;If not correct, restart the block
  1648 00:E80E: 49 FF        					EOR	#$FF	;one's complement of block number
  1649 00:E810: CD 7D 03     					CMP	RBUFF+1	;Compare with expected one's complement of block num
                    ber
  1650 00:E813: F0 07        					BEQ	BLK_OKAY	;Branch if compare is good
  1651                        ;
  1652 00:E815: A9 15        RESTRT		LDA	#NAK	;Get NAK character
  1653 00:E817: 20 19 F8     RESTRT2		JSR	CHROUT	;Send to xfer program
  1654 00:E81A: 80 C8        					BRA	STRT_BLK	;Restart block transfer
  1655                        ;
  1656 00:E81C: A9 0A        BLK_OKAY	LDA	#$0A	;Set retry value to 10
  1657 00:E81E: 85 D9        					STA	CRCCNT	;Save it to CRC retry count
  1658 00:E820: 64 D8        					STZ	CRCLO	;Reset the CRC value by (3)
  1659 00:E822: 64 D7        					STZ	CRCHI	;putting all bits off (3)
  1660 00:E824: A0 00        					LDY #$00	Set index for data offset (2)
  1661 00:E826: B9 7E 03     CALCCRC		LDA	RBUFF+2,Y	;Get first data byte (4)
  1662 00:E829: 08           					PHP	;Save status reg (3)
  1663 00:E82A: A2 08        					LDX	#$08	;Load index for 8 bits (2)
  1664 00:E82C: 45 D7        					EOR	CRCHI	;XOR High CRC byte
  1665 00:E82E: 06 D8        CRCLOOP		ASL	CRCLO	;Shift carry to CRC low byte (4)
  1666 00:E830: 2A           					ROL	A	;Shift bit to carry flag (2)
  1667 00:E831: 90 0A        					BCC	CRCLP1	;Branch if MSB is 1 (2/3)
  1668 00:E833: 49 10        					EOR	#$10	;Exclusive OR with polynomial (2)
  1669 00:E835: 48           					PHA	;Save result on stack (3)
  1670 00:E836: A5 D8        					LDA	CRCLO	;Get CRC low byte (3)
  1671 00:E838: 49 21        					EOR	#$21	;Exclusive OR with polynomial (2)
  1672 00:E83A: 85 D8        					STA	CRCLO	;Save it back (3)
  1673 00:E83C: 68           					PLA	;Get previous result (4)
  1674 00:E83D: CA           CRCLP1		DEX	;Decrement index (2)
  1675 00:E83E: D0 EE        					BNE	CRCLOOP	;Loop back for all 8 bits (2/3)
  1676 00:E840: 85 D7        					STA	CRCHI	;Update CRC high byte (3)
  1677 00:E842: 28           					PLP ;Restore status reg (4)
  1678 00:E843: C8           					INY	;Increment index to the next data byte (2)
  1679 00:E844: 10 E0        					BPL	CALCCRC	;Branch back until all 128 fed to CRC routine (2/3)
  1680 00:E846: B9 7E 03     					LDA	RBUFF+2,Y	;Get received CRC hi byte (4)
  1681 00:E849: C5 D7        					CMP	CRCHI	;Compare against calculated CRC hi byte (3)
  1682 00:E84B: D0 07        					BNE	BADCRC	;If bad CRC, handle error (2/3)
  1683 00:E84D: B9 7F 03     					LDA	RBUFF+3,Y	;Get CRC lo byte (4)
  1684 00:E850: C5 D8        					CMP	CRCLO	;Compare against calculated CRC lo byte (3)
  1685 00:E852: F0 15        					BEQ	GOODCRC	;If good, go move frame to memory (2/3)
  1686                        ;
  Sun Mar  3 2019 23:01                                                                                                    Page 28


  1687                        ;CRC was bad... need to retry and receive the last frame again
  1688                        ;Decrement the CRC retry count, send a NAK and try again
  1689                        ;Count allows up to 10 retries, then cancels the transfer
  1690                        ;
  1691 00:E854: C6 D9        BADCRC		DEC	CRCCNT	;Decrement retry count
  1692 00:E856: D0 0C        					BNE	CRCRTRY	;Retry again if count not zero
  1693 00:E858: A9 18        STRT_ERR	LDA	#CAN	;Else get Cancel code
  1694 00:E85A: 20 19 F8     					JSR	CHROUT	;Send it to terminal program
  1695 00:E85D: A0 08        					LDY	#$08	;Set delay multiplier
  1696 00:E85F: A9 29        					LDA	#$29	;Get message for receive error
  1697 00:E861: 4C BA E7     					JMP	FLSH_DLY	;Do a flush, delay and exit
  1698 00:E864: 20 18 E2     CRCRTRY		JSR	NOLOOPS	;Zero Input buffer pointers
  1699 00:E867: 80 AC        					BRA	RESTRT	;Send NAK and retry
  1700                        ;
  1701                        ;Block has been received, check for S19 record transfer
  1702 00:E869: FF FE 2D     GOODCRC		BBS7	XMFLAG,XFER_S19	;Branch if bit 7 set (active S-record)
  1703 00:E86C: A5 DC        					LDA	BLKNO	;Else, check current block number
  1704 00:E86E: 3A           					DEC	A	;Check for block 1 only (first time thru)
  1705 00:E86F: F0 16        					BEQ	TEST_S19	;If yes, test for S19 record
  1706                        ;
  1707 00:E871: A2 00        MOVE_BLK	LDX	#$00	;Zero index offset to data
  1708 00:E873: BD 7E 03     COPYBLK		LDA	RBUFF+2,X	;Get data byte from buffer
  1709 00:E876: 92 DA        					STA	(PTRL)	;Store to target address
  1710 00:E878: E6 DA        					INC	PTRL	;Incrememnt low address byte
  1711 00:E87A: D0 02        					BNE	COPYBLK2	;Check for hi byte loop
  1712 00:E87C: E6 DB        					INC	PTRH	;Increment hi byte address
  1713 00:E87E: E8           COPYBLK2	INX	;Point to next data byte
  1714 00:E87F: 10 F2        					BPL	COPYBLK	;Loop back until done (128)
  1715 00:E881: E6 DC        INCBLK		INC	BLKNO	;Increment block number
  1716 00:E883: A9 06        					LDA	#ACK	;Get ACK character
  1717 00:E885: 80 90        					BRA	RESTRT2	;Send ACK and continue xfer
  1718                        ;
  1719 00:E887: AD 7E 03     TEST_S19	LDA	RBUFF+2	;Get first character
  1720 00:E88A: C9 53        					CMP	#"S"	;Check for S character
  1721 00:E88C: D0 E3        					BNE	MOVE_BLK	;If not equal, no S-record, move block
  1722 00:E88E: AD 7F 03     					LDA	RBUFF+3	;Get second character
  1723 00:E891: C9 31        					CMP	#"1"	;Check for 1 character
  1724 00:E893: D0 DC        					BNE	MOVE_BLK	;If not equal, no S-record, move block
  1725 00:E895: F7 FE        					SMB7	XMFLAG	;Set bit 7 for S-record xfer
  1726 00:E897: 64 D1        					STZ	IDY	;Zero index for SRBUFF
  1727                        ;
  1728                        ; S-record transfer routine
  1729                        ;	Xmodem is a 128 byte data block, S-record is variable, up to 44 byte block
  1730                        ;	need to move a record at a time to the SRBUFF based on length, check as valid,
  1731                        ;	then calculate address and transfer to that location
  1732                        ;	once the Xmodem buffer is empty, loop back to get the next frame
  1733                        ;	and continue processing S-records until completed
  1734                        ;
  1735                        ;At first entry here, pointer IDY is zero
  1736                        ;At all entries here, a 128 byte block has been received
  1737                        ;The S-record length needs to be calculated, then the proper count moved
  1738                        ;to the SRBUFF location and both pointers (IDX/IDY) updated
  1739                        ;
  1740 00:E899: 64 D0        XFER_S19	STZ	IDX	;Zero offset to RBUFF
  1741 00:E89B: A6 D0        S19_LOOP2	LDX	IDX	;Load current offset to RBUFF
  1742 00:E89D: A4 D1        					LDY	IDY	;Get S-Record offset
  1743 00:E89F: BD 7E 03     S19_LOOP	LDA	RBUFF+2,X	;Get S-Record data
  1744 00:E8A2: 99 50 03     					STA	SRBUFF,Y	;Save it to the S-record buffer
  1745 00:E8A5: E8           					INX	;Increment offset to RBUFF
  1746 00:E8A6: E0 81        					CPX	#$81	;Check for end of RBUFF data
  1747 00:E8A8: F0 0E        					BEQ	NXT_FRAME	;If yes, go back and get another frame
  1748 00:E8AA: C8           					INY	;Increment S-Rec size
  1749 00:E8AB: C0 2C        					CPY	#$2C	;Check for size match
  Sun Mar  3 2019 23:01                                                                                                    Page 29


  1750 00:E8AD: D0 F0        					BNE	S19_LOOP	;Branch back until done
  1751 00:E8AF: 86 D0        					STX	IDX	;Update running offset to RBUFF
  1752 00:E8B1: 64 D1        					STZ	IDY	;Reset SRBUFF index pointer
  1753 00:E8B3: 20 BC E8     					JSR	SREC_PROC	;Process the S-Record and store in memory
  1754 00:E8B6: 80 E3        					BRA	S19_LOOP2	;Branch back and get another record
  1755 00:E8B8: 84 D1        NXT_FRAME	STY	IDY	;Save SRBUFF offset
  1756 00:E8BA: 80 C5        INCBLK2		BRA	INCBLK	;Increment block and get next frame
  1757                        ;
  1758 00:E8BC: AD 51 03     SREC_PROC	LDA	SRBUFF+1	;Get the Record type character
  1759 00:E8BF: C9 31        					CMP	#"1"	;Check for S1 record
  1760 00:E8C1: F0 6A        					BEQ	S1_PROC	;Process a S1 record
  1761 00:E8C3: C9 39        					CMP	#"9"	;Check for S9 (final) record
  1762 00:E8C5: F0 55        					BEQ	S9_PROC	;Process a S9 record
  1763 00:E8C7: 68           SREC_ERR	PLA	;Else, pull return address
  1764 00:E8C8: 68           					PLA	;of two bytes from stack
  1765 00:E8C9: 80 8D        					BRA	STRT_ERR	;Branch to Xmodem error/exit routine
  1766                        ;
  1767 00:E8CB: AC 53 03     SR_PROC		LDY	SRBUFF+3	;Get record length LS character
  1768 00:E8CE: AD 52 03     					LDA	SRBUFF+2	;Get record length MS character
  1769 00:E8D1: 20 2E E0     					JSR	ASC2BIN	;Convert to single byte for length
  1770 00:E8D4: 1A           					INC	A	;Add one to length to include checksum
  1771 00:E8D5: 85 D4        					STA	TEMP3	;Save record length
  1772                        ;
  1773                        ; If record length is less, than the difference needs to be subtracted from IDX
  1774                        ; which reflects either the last record (S9) or a S1 record of a lesser length
  1775                        ;
  1776 00:E8D7: 38           					SEC	;Set carry for subtract
  1777 00:E8D8: A9 14        					LDA	#20	;Get default count
  1778 00:E8DA: E5 D4        					SBC	TEMP3	;Subtract actual length
  1779 00:E8DC: 0A           					ASL	A	;Multiply by two for characters pairs
  1780 00:E8DD: 85 D3        					STA	TEMP2	;Save it to temp
  1781                        ;
  1782 00:E8DF: 38           					SEC	;Set carry for subtract
  1783 00:E8E0: A5 D0        					LDA	IDX	;Get RBUFF index
  1784 00:E8E2: E5 D3        					SBC	TEMP2	;Subtract difference
  1785 00:E8E4: 85 D0        					STA	IDX	;Update IDX
  1786                        ;
  1787 00:E8E6: A2 00        SR_COMP		LDX	#$00	;Zero Index
  1788 00:E8E8: A0 00        					LDY	#$00	;Zero Index
  1789 00:E8EA: 5A           SR_CMPLP	PHY	;Save Y reg index
  1790 00:E8EB: BC 53 03     					LDY	SRBUFF+3,X	;get LS character
  1791 00:E8EE: BD 52 03     					LDA	SRBUFF+2,X	;Get MS character
  1792 00:E8F1: 20 2E E0     					JSR	ASC2BIN	;Convert two ASCII characters to HEX byte
  1793 00:E8F4: 7A           					PLY	;Restore Y reg index
  1794 00:E8F5: 99 50 03     					STA	SRBUFF,Y	;Store in SRBUFF starting at front
  1795 00:E8F8: E8           					INX	;Increment X reg twice
  1796 00:E8F9: E8           					INX	;points to next character pair
  1797 00:E8FA: C8           					INY	;Increment Y reg once for offset to SRBUFF
  1798 00:E8FB: C6 D4        					DEC	TEMP3	;Decrement character count
  1799 00:E8FD: D0 EB        					BNE	SR_CMPLP	;Branch back until done
  1800                        ;
  1801                        ; SRBUFF now has the compressed HEX data, which is:
  1802                        ; 1 byte for length, 2 bytes for the load address,
  1803                        ; up to 16 bytes for data and 1 byte checksum
  1804                        ; Now calculate the checksum and ensure valid S-record content
  1805                        ;
  1806 00:E8FF: 64 D8        					STZ	CRCLO	;Zero Checksum location
  1807 00:E901: AE 50 03     					LDX	SRBUFF	;Load index with record length
  1808 00:E904: A0 00        					LDY	#$00	;Zero index
  1809 00:E906: 18           SR_CHKSM	CLC	;Clear carry for add
  1810 00:E907: B9 50 03     					LDA	SRBUFF,Y	;Get Srec byte
  1811 00:E90A: 65 D8        					ADC	CRCLO	;Add in checksum Temp
  1812 00:E90C: 85 D8        					STA	CRCLO	:Update checksum Temp
  Sun Mar  3 2019 23:01                                                                                                    Page 30


  1813 00:E90E: C8           					INY	;Increment offset
  1814 00:E90F: CA           					DEX	;Decrement count
  1815 00:E910: D0 F4        					BNE	SR_CHKSM	;Branch back until done
  1816                        ;
  1817 00:E912: A9 FF        					LDA	#$FF	;Get all bits on
  1818 00:E914: 45 D8        					EOR	CRCLO	;Exclusive OR TEMP for one's complement
  1819 00:E916: D9 50 03     					CMP	SRBUFF,Y	;Compare to last byte (which is checksum)
  1820 00:E919: D0 AC        					BNE	SREC_ERR	;If bad, exit out
  1821 00:E91B: 60           					RTS	;Return to caller
  1822                        ;
  1823 00:E91C: 20 CB E8     S9_PROC		JSR	SR_PROC	;Process the S-Record and checksum
  1824 00:E91F: AD 51 03     					LDA	SRBUFF+1	;Get MSB load address
  1825 00:E922: 85 BF        					STA	COMHI	;Store to execution pointer
  1826 00:E924: AD 52 03     					LDA	SRBUFF+2	;Get LSB load address
  1827 00:E927: 85 BE        					STA	COMLO	;Store to execution pointer
  1828 00:E929: 68           					PLA	;Pull return address
  1829 00:E92A: 68           					PLA	;second byte
  1830 00:E92B: 80 8D        					BRA	INCBLK2	;Branch back to close out transfer
  1831                        ;
  1832 00:E92D: 20 CB E8     S1_PROC		JSR	SR_PROC	;Process the S-Record and checksum
  1833                        ;
  1834                        ; Valid binary S-Record decoded at SRBUFF
  1835                        ; Calculate offset from input, add to specified load address
  1836                        ; and store into memory, then loop back until done
  1837                        ;
  1838                        ; Offset is stored in PTR L/H from initial input
  1839                        ; if no input entered, BUFIDX is zero and PTR L/H is preset to $0800
  1840                        ; so checking for BUFIDX being zero bypasses adding the offset,
  1841                        ; if BUFIDX is non zero, then PTR L/H contains the offset address
  1842                        ; which is added to TGT L/H moving the S-record data to memory
  1843                        ;
  1844 00:E930: AD 51 03     					LDA	SRBUFF+1	;Get MS load address
  1845 00:E933: 85 CB        					STA	TGTH	;Store to target pointer
  1846 00:E935: AD 52 03     					LDA	SRBUFF+2	;Get LS load address
  1847 00:E938: 85 CA        					STA	TGTL	;Store to target pointer
  1848 00:E93A: A5 CE        					LDA	BUFIDX	;Check input count for offset required
  1849 00:E93C: F0 11        					BEQ	NO_OFFSET	;If Zero, no offset was entered
  1850                        ;
  1851                        ; Add in offset contained at PTR L/H to TGT L/H
  1852                        ;
  1853 00:E93E: 18           					CLC	;Clear carry for add
  1854 00:E93F: A5 DA        					LDA	PTRL	;Get LS offset
  1855 00:E941: 65 CA        					ADC	TGTL	;Add to TGTL address
  1856 00:E943: 90 02        					BCC	SKIP_HB	;Skip increment HB if no carry
  1857 00:E945: E6 CB        					INC	TGTH	;Else increment TGTH by one
  1858 00:E947: 85 CA        SKIP_HB		STA	TGTL	;Save TGTL
  1859 00:E949: A5 DB        					LDA	PTRH	;Get MS offset
  1860 00:E94B: 65 CB        					ADC	TGTH	;Add to TGTH
  1861 00:E94D: 85 CB        					STA	TGTH	;Save it
  1862                        ;
  1863                        ; Check for first Block and load SRC H/L with load address
  1864                        ;
  1865 00:E94F: A5 DC        NO_OFFSET	LDA	BLKNO	;Get Block number
  1866 00:E951: 3A           					DEC	A	;Decrement to test for block one
  1867 00:E952: D0 0E        					BNE	NO_OFFST2	;If not first block, skip around
  1868 00:E954: A5 D0        					LDA	IDX	;Get running count for first block
  1869 00:E956: C9 2C        					CMP	#$2C	;First S-record?
  1870 00:E958: D0 08        					BNE	NO_OFFST2	;If yes, setup load address pointer
  1871 00:E95A: A5 CA        					LDA	TGTL	;Get starting address Lo byte
  1872 00:E95C: 85 C8        					STA	SRCL	;Save it as Source Lo byte
  1873 00:E95E: A5 CB        					LDA	TGTH	;Get starting address Hi byte
  1874 00:E960: 85 C9        					STA	SRCH	;Save it as Source Hi byte
  1875                        ;
  Sun Mar  3 2019 23:01                                                                                                    Page 31


  1876 00:E962: AE 50 03     NO_OFFST2	LDX	SRBUFF	;Get record length
  1877 00:E965: CA           					DEX	;Decrement by 3
  1878 00:E966: CA           					DEX	; to only transfer the data
  1879 00:E967: CA           					DEX	; and not the count and load address
  1880 00:E968: A0 00        					LDY	#$00	;Zero index
  1881 00:E96A: B9 53 03     MVE_SREC	LDA	SRBUFF+3,Y	;Get offset to data in record
  1882 00:E96D: 91 CA        					STA	(TGTL),Y	;Store it to memory
  1883 00:E96F: C8           					INY	;Increment index
  1884 00:E970: CA           					DEX	;Decrement record count
  1885 00:E971: D0 F7        					BNE	MVE_SREC	;Branch back until done
  1886 00:E973: 60           					RTS	;Return to caller
  1887                        ;
  1888                        ;[CNTL-R]	Reset System command: Resets system by calling Coldstart routine
  1889                        ;	Page zero is cleared, vectors and config data re-initialized from ROM
  1890                        ;	All I/O devices reset from initial ROM parameters, Monitor cold start entered
  1891                        ;
  1892 00:E974: A9 20        SYS_RST		LDA	#$20	;Get msg "Reset System"
  1893 00:E976: 87 D5        					SMB0	CMDFLAG	;Set bit zero
  1894 00:E978: 80 02        					BRA	RST_ONLY	;Branch below and handle reset
  1895                        ;
  1896                        ;[CNTL-Z] Zero command: zero RAM from $0100-$7FFF and Reset
  1897 00:E97A: A9 1F        ZERO			LDA	#$1F	;Get msg "Zero RAM/Reset System"
  1898 00:E97C: 20 35 E7     RST_ONLY	JSR	PROMPT	;Send to terminal
  1899 00:E97F: 20 BA E1     					JSR	CONTINUE	;Prompt for Continue
  1900 00:E982: 8F D5 12     					BBS0	CMDFLAG,DO_COLD	;Branch if reset only
  1901 00:E985: 78           					SEI	;Disable IRQs
  1902 00:E986: A9 01        					LDA	#$01	;Initialize address pointer to $0100
  1903 00:E988: 85 01        					STA	$01	;Store to pointer high byte
  1904 00:E98A: 64 00        					STZ	$00	;Zero address low byte
  1905 00:E98C: 3A           					DEC	A	;LDA #$00
  1906 00:E98D: 92 00        ZEROLOOP	STA	($00)	;Write $00 to current address
  1907 00:E98F: E6 00        					INC	$00	;Increment address pointer
  1908 00:E991: D0 FA        					BNE	ZEROLOOP
  1909 00:E993: E6 01        					INC	$01
  1910 00:E995: 10 F6        					BPL	ZEROLOOP	;LOOP back IF address pointer < $8000
  1911 00:E997: 4C 78 FF     DO_COLD		JMP	COLDSTRT	;Jump to coldstart vector
  1912                        ;
  1913                        ;END OF MONITOR CODE
  1914                        ;******************************************************************************
  1915                        ;
  1916                        ;******************************************************************************
  1917                        ;START OF MONITOR DATA
  1918                        ;******************************************************************************
  1919                        ;
  1920                        ;* Monitor command & jump table *
  1921                        ;
  1922                        ;There are two parts to the monitor command and jump table;
  1923                        ; first is the list of commands, which are one byte each. Alpha command characters are upper case
  1924                        ; second is the 16-bit address table that correspond to the command routines for each command characte
                    r
  1925                        ;
  1926 00:E99A: 02           MONCMD		.DB $02 ;[CNTRL-B] Enter EhBasic
  1927 00:E99B: 04           					.DB	$04	;[CNTRL-D]	Disassembler
  1928 00:E99C: 0C           					.DB	$0C	;[CNTRL-L]	Xmodem/CRC Loader
  1929 00:E99D: 10           					.DB	$10	;[CNTRL-P]	Program EEPROM
  1930 00:E99E: 11           					.DB	$11	;[CNTRL-Q]	Query Monitor Commands
  1931 00:E99F: 12           					.DB	$12	;[CNTRL-R]	Reset - same as power up
  1932 00:E9A0: 14           					.DB	$14	;[CNTRL-T]	Uptime display since reset
  1933 00:E9A1: 16           					.DB	$16	;[CNTRL-V]	Display Monitor Version
  1934 00:E9A2: 1A           					.DB	$1A	;[CNTRL-Z]	Zero Memory - calls reset
  1935 00:E9A3: 28           					.DB	$28	;(	Init Macro
  1936 00:E9A4: 29           					.DB	$29	;)	Run Macro
  1937 00:E9A5: 2C           					.DB	$2C	;,	Setup Delay parameters	
  Sun Mar  3 2019 23:01                                                                                                    Page 32


  1938 00:E9A6: 2E           					.DB	$2E	;.	Execute Millisecond Delay
  1939 00:E9A7: 2F           					.DB	$2F	;/	Execute Long Delay
  1940 00:E9A8: 5C           					.DB	$5C	;\	Load and Go Extra Long Delay
  1941 00:E9A9: 41           					.DB	$41	;A	Display/Edit A register
  1942 00:E9AA: 43           					.DB	$43	;C	Compare memory block
  1943 00:E9AB: 44           					.DB	$44	;D	Display Memory contents in HEX/TEXT
  1944 00:E9AC: 45           					.DB	$45	;E	Examine/Edit memory
  1945 00:E9AD: 46           					.DB	$46	;F	Fill memory block
  1946 00:E9AE: 47           					.DB	$47	;G	Go execute to <addr>
  1947 00:E9AF: 48           					.DB	$48	;H	Hex byte string search
  1948 00:E9B0: 49           					.DB	$49	;I	Input Text string
  1949 00:E9B1: 4D           					.DB	$4D	;M	Move memory block
  1950 00:E9B2: 50           					.DB	$50	;P	Display/Edit CPU status reg
  1951 00:E9B3: 52           					.DB	$52	;R	Display Registers
  1952 00:E9B4: 53           					.DB	$53	;S	Display/Edit stack pointer
  1953 00:E9B5: 54           					.DB	$54	;T	Text character string search
  1954 00:E9B6: 58           					.DB	$58	;X	Display/Edit X register
  1955 00:E9B7: 59           					.DB	$59	;Y	Display/Edit Y register
  1956                        ;
  1957 00:E9B8: 6E E5        MONTAB		.DW EHBASIC ;[CNTRL-B] $02 Start EhBasic
  1958 00:E9BA: 89 E5        					.DW	DSSMBLR	;[CNTRL-D] $04	Disassembler
  1959 00:E9BC: 79 E7        					.DW	XMODEM	;[CNTL-L]	$0C	Xmodem download, use send fr
                    om terminal program
  1960 00:E9BE: 64 E2        					.DW	PROGEE ;[CNTL-P]	$10	Program the EEPROM
  1961 00:E9C0: 33 E7        					.DW	QUERY	;[CNTL-Q]	$11	Query Monitor Commands
  1962 00:E9C2: 74 E9        					.DW	SYS_RST	;[CNTL-R]	$12	Reset CO2Monitor
  1963 00:E9C4: 50 E7        					.DW	UPTIME	;[CNTL-T]	$14	System uptime from Reset - s
                    ec/min/hr/days
  1964 00:E9C6: 24 E7        					.DW	VER	;[CNTL-V]	$16	Display Monitor Version leve
                    l
  1965 00:E9C8: 7A E9        					.DW	ZERO	;[CNTL-Z]	$1A	Zero memory ($0100-$7FFF) th
                    en Reset
  1966 00:E9CA: F6 E1        					.DW	INIMACRO	; (	$28	Clear keystroke input buffer
                    , reset buffer pointer
  1967 00:E9CC: 1F E2        					.DW	RUNMACRO	; )	$29	Run keystroke macro from sta
                    rt of keystroke buffer
  1968 00:E9CE: D6 E1        					.DW	SET_DELAY	; .	$2C	Setup Delay Parameters
  1969 00:E9D0: 37 F8        					.DW	EXE_MSDLY	; ,	$2E	Perform Millisecond Delay
  1970 00:E9D2: 49 F8        					.DW	EXE_LGDLY	;	/	$2F Execute Long Delay
  1971 00:E9D4: E7 E1        					.DW	SET_XLDLY	;	\	$5C Load and Go Extra Long D
                    elay
  1972 00:E9D6: D2 E4        					.DW	ARG	; A	$41	Examine/change ACCUMULATOR preset/re
                    sult
  1973 00:E9D8: 57 E2        					.DW	CPMVFL	; C	$43	Compare command - new
  1974 00:E9DA: 52 E3        					.DW	MDUMP	; D	$44	HEX/TEXT dump from specified memory 
                    address
  1975 00:E9DC: CE E3        					.DW	CHANGE	; E	$45	Examine/change a memory location's c
                    ontents
  1976 00:E9DE: 57 E2        					.DW	CPMVFL	; F	$46	Fill a specified memory range with a
                     specified value
  1977 00:E9E0: EF E3        					.DW	GO	; G	$47	Begin program code execution at a sp
                    ecified address
  1978 00:E9E2: 45 E4        					.DW	SRCHBYT	; H	$48	Search memory for a specified byte s
                    tring
  1979 00:E9E4: 1B E5        					.DW	TEXT	; I	$49 Input text string into memory
  1980 00:E9E6: 57 E2        					.DW	CPMVFL	; M	$4D	Copy a specified memory range to a s
                    pecified target address
  1981 00:E9E8: C2 E4        					.DW	PRG	; P	$50	Examine/change PROCESSOR STATUS REGI
                    STER preset/result
  1982 00:E9EA: E8 E4        					.DW	PRSTAT	; R	$52	Display all preset/result contents
  1983 00:E9EC: C6 E4        					.DW	SRG	; S	$53	Examine/change STACK POINTER preset/
                    result
  1984 00:E9EE: 19 E4        					.DW	SRCHTXT	; T	$54	Search memory for a specified text s
  Sun Mar  3 2019 23:01                                                                                                    Page 33


                    tring
  1985 00:E9F0: CE E4        					.DW	XRG	; X	$58	Examine/change X-REGISTER preset/res
                    ult
  1986 00:E9F2: CA E4        					.DW	YRG	; Y	$59	Examine/change Y-REGISTER preset/res
                    ult
  1987                        ;
  1988                        ;******************************************************************************
  1989                        ;C02Monitor message strings used with PROMPT routine, terminated with $00
  1990                        ;
  1991 00:E9F4: 20 63 6F 6E  MSG_00		.DB " cont?"
       00:E9F8: 74 3F 
  1992 00:E9FA: 28 79 2F 6E  MSG_01		.DB	"(y/n)"
       00:E9FE: 29 
  1993 00:E9FF: 00           					.DB $00
  1994 00:EA00: 0D 0A        MSG_02		.DB $0D,$0A
  1995 00:EA02: 20 20 20     					.DB	"   "
  1996 00:EA05: 20 61 64 64  MSG_03		.DB	" addr:"
       00:EA09: 72 3A 
  1997 00:EA0B: 00           					.DB $00
  1998 00:EA0C: 20 6C 65 6E  MSG_04		.DB " len:"
       00:EA10: 3A 
  1999 00:EA11: 00           					.DB $00
  2000 00:EA12: 20 76 61 6C  MSG_05		.DB " val:"
       00:EA16: 3A 
  2001 00:EA17: 00           					.DB $00
  2002 00:EA18: 20 73 72 63  MSG_06		.DB " src:"
       00:EA1C: 3A 
  2003 00:EA1D: 00           					.DB $00
  2004 00:EA1E: 20 74 67 74  MSG_07		.DB " tgt:"
       00:EA22: 3A 
  2005 00:EA23: 00           					.DB $00
  2006 00:EA24: 20 66 69 6E  MSG_08		.DB " find txt:"
       00:EA28: 64 20 74 78 
       00:EA2C: 74 3A 
  2007 00:EA2E: 00           					.DB $00
  2008 00:EA2F: 20 66 69 6E  MSG_09		.DB " find bin:"
       00:EA33: 64 20 62 69 
       00:EA37: 6E 3A 
  2009 00:EA39: 00           					.DB $00
  2010 00:EA3A: 6E 6F 74 20  MSG_0A		.DB "not "
  2011 00:EA3E: 66 6F 75 6E  MSG_0B		.DB "found"
       00:EA42: 64 
  2012 00:EA43: 00           					.DB $00
  2013 00:EA44: 0D 0A        MSG_0C		.DB $0D,$0A
  2014 00:EA46: 73 65 61 72  					.DB "search- "
       00:EA4A: 63 68 2D 20 
  2015 00:EA4E: 00           					.DB $00
  2016 00:EA4F: 0D 0A        MSG_0D		.DB $0D,$0A
  2017 00:EA51: 28 6E 29 65  					.DB "(n)ext? "
       00:EA55: 78 74 3F 20 
  2018 00:EA59: 00           					.DB $00
  2019 00:EA5A: 53 52 3A 24  MSG_0E		.DB "SR:$"
  2020 00:EA5E: 00           					.DB $00
  2021 00:EA5F: 53 50 3A 24  MSG_0F		.DB "SP:$"
  2022 00:EA63: 00           					.DB $00
  2023 00:EA64: 59 52 3A 24  MSG_10		.DB "YR:$"
  2024 00:EA68: 00           					.DB $00
  2025 00:EA69: 58 52 3A 24  MSG_11		.DB "XR:$"
  2026 00:EA6D: 00           					.DB $00
  2027 00:EA6E: 41 43 3A 24  MSG_12		.DB "AC:$"
  2028 00:EA72: 00           					.DB $00
  2029 00:EA73: 0D 0A        MSG_13		.DB	$0D,$0A
  2030 00:EA75: 20 20 20 50  					.DB "   PC  AC XR YR SP NV-BDIZC",$0D,$0A
  Sun Mar  3 2019 23:01                                                                                                    Page 34


       00:EA79: 43 20 20 41 
       00:EA7D: 43 20 58 52 
       00:EA81: 20 59 52 20 
       00:EA85: 53 50 20 4E 
       00:EA89: 56 2D 42 44 
       00:EA8D: 49 5A 43 0D 
       00:EA91: 0A 
  2031 00:EA92: 3B 20        					.DB "; "
  2032 00:EA94: 00           					.DB $00
  2033 00:EA95: 0D 0A        MSG_14		.DB $0D,$0A
  2034 00:EA97: 43 30 32 4D  					.DB "C02Monitor (c)2016 K.E.Maier",$07
       00:EA9B: 6F 6E 69 74 
       00:EA9F: 6F 72 20 28 
       00:EAA3: 63 29 32 30 
       00:EAA7: 31 36 20 4B 
       00:EAAB: 2E 45 2E 4D 
       00:EAAF: 61 69 65 72 
       00:EAB3: 07 
  2035 00:EAB4: 0D 0A        MSG_15		.DB $0D,$0A
  2036 00:EAB6: 56 65 72 73  					.DB "Version 1.4"
       00:EABA: 69 6F 6E 20 
       00:EABE: 31 2E 34 
  2037 00:EAC1: 00           					.DB $00
  2038 00:EAC2: 0D 0A        MSG_16		.DB $0D,$0A
  2039 00:EAC4: 3B 2D        					.DB ";-"
  2040 00:EAC6: 00           					.DB $00
  2041 00:EAC7: 20 64 65 6C  MSG_17		.DB	" delay ms:"
       00:EACB: 61 79 20 6D 
       00:EACF: 73 3A 
  2042 00:EAD1: 00           					.DB	$00
  2043 00:EAD2: 20 6D 75 6C  MSG_18		.DB	" mult:"
       00:EAD6: 74 3A 
  2044 00:EAD8: 00           					.DB	$00
  2045 00:EAD9: 20 64 65 6C  MSG_19		.DB	" delay xl:"
       00:EADD: 61 79 20 78 
       00:EAE1: 6C 3A 
  2046 00:EAE3: 00           					.DB	$00
  2047 00:EAE4: 55 70 74 69  MSG_1A		.DB	"Uptime: "
       00:EAE8: 6D 65 3A 20 
  2048 00:EAEC: 00           					.DB	$00
  2049 00:EAED: 20 44 61 79  MSG_1B		.DB	" Days, "
       00:EAF1: 73 2C 20 
  2050 00:EAF4: 00           					.DB	$00
  2051 00:EAF5: 20 48 6F 75  MSG_1C		.DB	" Hours, "
       00:EAF9: 72 73 2C 20 
  2052 00:EAFD: 00           					.DB	$00
  2053 00:EAFE: 20 4D 69 6E  MSG_1D		.DB	" Minutes, "
       00:EB02: 75 74 65 73 
       00:EB06: 2C 20 
  2054 00:EB08: 00           					.DB	$00
  2055 00:EB09: 20 53 65 63  MSG_1E		.DB	" Seconds"
       00:EB0D: 6F 6E 64 73 
  2056 00:EB11: 00           					.DB	$00
  2057 00:EB12: 5A 65 72 6F  MSG_1F		.DB "Zero RAM/"
       00:EB16: 20 52 41 4D 
       00:EB1A: 2F 
  2058 00:EB1B: 52 65 73 65  MSG_20		.DB	"Reset,"
       00:EB1F: 74 2C 
  2059 00:EB21: 00           					.DB	$00
  2060 00:EB22: 50 72 6F 67  MSG_21		.DB	"Program EEPROM",$0D,$0A
       00:EB26: 72 61 6D 20 
       00:EB2A: 45 45 50 52 
       00:EB2E: 4F 4D 0D 0A 
  Sun Mar  3 2019 23:01                                                                                                    Page 35


  2061 00:EB32: 00           					.DB	$00
  2062 00:EB33: 0D 0A        MSG_22		.DB	$0D,$0A
  2063 00:EB35: 41 72 65 20  					.DB	"Are you sure? "
       00:EB39: 79 6F 75 20 
       00:EB3D: 73 75 72 65 
       00:EB41: 3F 20 
  2064 00:EB43: 00           					.DB	$00
  2065 00:EB44: 0D 0A        MSG_23		.DB	$0D,$0A
  2066 00:EB46: 57 72 69 74  					.DB	"Writing EEPROM."
       00:EB4A: 69 6E 67 20 
       00:EB4E: 45 45 50 52 
       00:EB52: 4F 4D 2E 
  2067 00:EB55: 00           					.DB	$00
  2068 00:EB56: 0D 0A        MSG_24		.DB	$0D,$0A
  2069 00:EB58: 45 45 50 52  					.DB	"EEPROM Write Complete!"
       00:EB5C: 4F 4D 20 57 
       00:EB60: 72 69 74 65 
       00:EB64: 20 43 6F 6D 
       00:EB68: 70 6C 65 74 
       00:EB6C: 65 21 
  2070 00:EB6E: 00           					.DB	$00
  2071 00:EB6F: 0D 0A        MSG_25		.DB	$0D,$0A
  2072 00:EB71: 45 45 50 52  					.DB	"EEPROM Write Failed!",$0D,$0A
       00:EB75: 4F 4D 20 57 
       00:EB79: 72 69 74 65 
       00:EB7D: 20 46 61 69 
       00:EB81: 6C 65 64 21 
       00:EB85: 0D 0A 
  2073 00:EB87: 48 61 72 64  					.DB	"Hardware or EEPROM jumper!"
       00:EB8B: 77 61 72 65 
       00:EB8F: 20 6F 72 20 
       00:EB93: 45 45 50 52 
       00:EB97: 4F 4D 20 6A 
       00:EB9B: 75 6D 70 65 
       00:EB9F: 72 21 
  2074 00:EBA1: 0D 0A        MSG_26		.DB	$0D,$0A
  2075 00:EBA3: 52 54 43 20  					.DB	"RTC time error, check/reset!"
       00:EBA7: 74 69 6D 65 
       00:EBAB: 20 65 72 72 
       00:EBAF: 6F 72 2C 20 
       00:EBB3: 63 68 65 63 
       00:EBB7: 6B 2F 72 65 
       00:EBBB: 73 65 74 21 
  2076 00:EBBF: 00           					.DB	$00
  2077 00:EBC0: 58 4D 4F 44  MSG_27		.DB	"XMODEM Loader, <Esc> to abort, or",$0D,$0A
       00:EBC4: 45 4D 20 4C 
       00:EBC8: 6F 61 64 65 
       00:EBCC: 72 2C 20 3C 
       00:EBD0: 45 73 63 3E 
       00:EBD4: 20 74 6F 20 
       00:EBD8: 61 62 6F 72 
       00:EBDC: 74 2C 20 6F 
       00:EBE0: 72 0D 0A 
  2078 00:EBE3: 4C 6F 61 64  					.DB	"Load Address/S-Record Offset:"
       00:EBE7: 20 41 64 64 
       00:EBEB: 72 65 73 73 
       00:EBEF: 2F 53 2D 52 
       00:EBF3: 65 63 6F 72 
       00:EBF7: 64 20 4F 66 
       00:EBFB: 66 73 65 74 
       00:EBFF: 3A 
  2079 00:EC00: 00           					.DB	$00
  2080 00:EC01: 0D 0A        MSG_28		.DB	$0D,$0A
  Sun Mar  3 2019 23:01                                                                                                    Page 36


  2081 00:EC03: 44 6F 77 6E  					.DB	"Download Complete!",$0A
       00:EC07: 6C 6F 61 64 
       00:EC0B: 20 43 6F 6D 
       00:EC0F: 70 6C 65 74 
       00:EC13: 65 21 0A 
  2082 00:EC16: 00           					.DB	$00
  2083 00:EC17: 0D 0A        MSG_29		.DB	$0D,$0A
  2084 00:EC19: 44 6F 77 6E  					.DB	"Download Error!",$0A
       00:EC1D: 6C 6F 61 64 
       00:EC21: 20 45 72 72 
       00:EC25: 6F 72 21 0A 
  2085 00:EC29: 00           					.DB	$00
  2086 00:EC2A: 0D 0A        MSG_2A		.DB $0D,$0A
  2087 00:EC2C: 53 2D 52 65  					.DB "S-Record load at:$"
       00:EC30: 63 6F 72 64 
       00:EC34: 20 6C 6F 61 
       00:EC38: 64 20 61 74 
       00:EC3C: 3A 24 
  2088 00:EC3E: 00           					.DB $00
  2089 00:EC3F: 0D 0A        MSG_2B		.DB	$0D,$0A
  2090 00:EC41: 44 69 73 61  					.DB	"Disassembly from"
       00:EC45: 73 73 65 6D 
       00:EC49: 62 6C 79 20 
       00:EC4D: 66 72 6F 6D 
  2091 00:EC51: 00           					.DB	$00
  2092 00:EC52: 0D 0A 0A     MSG_2C		.DB	$0D,$0A,$0A
  2093 00:EC55: 4D 65 6D 6F  					.DB	"Memory Ops: "
       00:EC59: 72 79 20 4F 
       00:EC5D: 70 73 3A 20 
  2094 00:EC61: 5B 43 5D 6F  					.DB	"[C]ompare, "
       00:EC65: 6D 70 61 72 
       00:EC69: 65 2C 20 
  2095 00:EC6C: 5B 44 5D 69  					.DB	"[D]isplay, "
       00:EC70: 73 70 6C 61 
       00:EC74: 79 2C 20 
  2096 00:EC77: 5B 45 5D 64  					.DB	"[E]dit, "
       00:EC7B: 69 74 2C 20 
  2097 00:EC7F: 5B 46 5D 69  					.DB	"[F]ill, "
       00:EC83: 6C 6C 2C 20 
  2098 00:EC87: 5B 47 5D 6F  					.DB	"[G]o Exec,",$0D,$0A
       00:EC8B: 20 45 78 65 
       00:EC8F: 63 2C 0D 0A 
  2099 00:EC93: 5B 48 5D 65  					.DB	"[H]ex Find, "
       00:EC97: 78 20 46 69 
       00:EC9B: 6E 64 2C 20 
  2100 00:EC9F: 5B 49 5D 6E  					.DB	"[I]nput Text, "
       00:ECA3: 70 75 74 20 
       00:ECA7: 54 65 78 74 
       00:ECAB: 2C 20 
  2101 00:ECAD: 5B 4D 5D 6F  					.DB	"[M]ove, "
       00:ECB1: 76 65 2C 20 
  2102 00:ECB5: 5B 54 5D 65  					.DB	"[T]ext Find",$0D,$0A,$0A
       00:ECB9: 78 74 20 46 
       00:ECBD: 69 6E 64 0D 
       00:ECC1: 0A 0A 
  2103 00:ECC3: 52 65 67 69  					.DB	"Registers: "
       00:ECC7: 73 74 65 72 
       00:ECCB: 73 3A 20 
  2104 00:ECCE: 52 2C 41 2C  					.DB	"R,A,X,Y,S,P",$0D,$0A,$0A
       00:ECD2: 58 2C 59 2C 
       00:ECD6: 53 2C 50 0D 
       00:ECDA: 0A 0A 
  2105 00:ECDC: 54 69 6D 65  					.DB	"Timer: "
  Sun Mar  3 2019 23:01                                                                                                    Page 37


       00:ECE0: 72 3A 20 
  2106 00:ECE3: 2C 3D 20 73  					.DB	",= set ms|mult, "
       00:ECE7: 65 74 20 6D 
       00:ECEB: 73 7C 6D 75 
       00:ECEF: 6C 74 2C 20 
  2107 00:ECF3: 2E 3D 20 65  					.DB	".= exe ms, "
       00:ECF7: 78 65 20 6D 
       00:ECFB: 73 2C 20 
  2108 00:ECFE: 2F 3D 20 65  					.DB	"/= exe ms*mult, "
       00:ED02: 78 65 20 6D 
       00:ED06: 73 2A 6D 75 
       00:ED0A: 6C 74 2C 20 
  2109 00:ED0E: 5C 3D 20 65  					.DB	"\= exe (?)*ms*mult",$0D,$0A,$0A
       00:ED12: 78 65 20 28 
       00:ED16: 3F 29 2A 6D 
       00:ED1A: 73 2A 6D 75 
       00:ED1E: 6C 74 0D 0A 
       00:ED22: 0A 
  2110 00:ED23: 4D 61 63 72  					.DB	"Macro: "
       00:ED27: 6F 3A 20 
  2111 00:ED2A: 28 3D 20 49  					.DB	"(= Init "
       00:ED2E: 6E 69 74 20 
  2112 00:ED32: 29 3D 20 52  					.DB	")= Run",$0D,$0A,$0A
       00:ED36: 75 6E 0D 0A 
       00:ED3A: 0A 
  2113 00:ED3B: 43 54 52 4C  					.DB	"CTRL[?]: "
       00:ED3F: 5B 3F 5D 3A 
       00:ED43: 20 
  2114 00:ED44: 5B 44 5D 69  					.DB	"[D]isassemble, "
       00:ED48: 73 61 73 73 
       00:ED4C: 65 6D 62 6C 
       00:ED50: 65 2C 20 
  2115 00:ED53: 5B 4C 5D 6F  					.DB	"[L]oader, "
       00:ED57: 61 64 65 72 
       00:ED5B: 2C 20 
  2116 00:ED5D: 5B 50 5D 72  					.DB	"[P]rogram, "
       00:ED61: 6F 67 72 61 
       00:ED65: 6D 2C 20 
  2117 00:ED68: 5B 51 5D 75  					.DB	"[Q]uery Cmds,",$0D,$0A
       00:ED6C: 65 72 79 20 
       00:ED70: 43 6D 64 73 
       00:ED74: 2C 0D 0A 
  2118 00:ED77: 5B 52 5D 65  					.DB	"[R]eset, "
       00:ED7B: 73 65 74 2C 
       00:ED7F: 20 
  2119 00:ED80: 5B 54 5D 69  					.DB	"[T]ime up, "
       00:ED84: 6D 65 20 75 
       00:ED88: 70 2C 20 
  2120 00:ED8B: 5B 56 5D 65  					.DB	"[V]ersion, "
       00:ED8F: 72 73 69 6F 
       00:ED93: 6E 2C 20 
  2121 00:ED96: 5B 5A 5D 65  					.DB	"[Z]ero RAM",$0A
       00:ED9A: 72 6F 20 52 
       00:ED9E: 41 4D 0A 
  2122 00:EDA1: 00           					.DB	$00
  2123 00:EDA2: 0D 0A        MSG_2D		.DB	$0D,$0A
  2124 00:EDA4: 53 68 6F 77  					.DB	"Show Loop count "
       00:EDA8: 20 4C 6F 6F 
       00:EDAC: 70 20 63 6F 
       00:EDB0: 75 6E 74 20 
  2125 00:EDB4: 00           					.DB	$00
  2126 00:EDB5: 0D 0A        MSG_2E		.DB	$0D,$0A
  2127 00:EDB7: 4C 6F 6F 70  					.DB	"Loops: "
  Sun Mar  3 2019 23:01                                                                                                    Page 38


       00:EDBB: 73 3A 20 
  2128 00:EDBE: 00           					.DB	$00
  2129 00:EDBF: 0D 0A        MSG_2F  .DB     $0D,$0A
  2130 00:EDC1: 36 35 43 30          .DB     "65C02 Enhanced BASIC Version 2.22p4C"
       00:EDC5: 32 20 45 6E 
       00:EDC9: 68 61 6E 63 
       00:EDCD: 65 64 20 42 
       00:EDD1: 41 53 49 43 
       00:EDD5: 20 56 65 72 
       00:EDD9: 73 69 6F 6E 
       00:EDDD: 20 32 2E 32 
       00:EDE1: 32 70 34 43 
  2131 00:EDE5: 0D 0A                .DB     $0D,$0A
  2132 00:EDE7: 20 5B 43 5D          .DB     " [C]old/[W]arm start?"
       00:EDEB: 6F 6C 64 2F 
       00:EDEF: 5B 57 5D 61 
       00:EDF3: 72 6D 20 73 
       00:EDF7: 74 61 72 74 
       00:EDFB: 3F 
  2133 00:EDFC: 00                   .DB     $00
  2134                        ;
  2135                        MSG_TABLE	;Message table - contains addresses as words of each message sent via the PROMPT routine
  2136 00:EDFD: F4 E9        					.DW MSG_00
  2137 00:EDFF: FA E9        					.DW	MSG_01
  2138 00:EE01: 00 EA        					.DW	MSG_02
  2139 00:EE03: 05 EA        					.DW	MSG_03
  2140 00:EE05: 0C EA        					.DW	MSG_04
  2141 00:EE07: 12 EA        					.DW	MSG_05
  2142 00:EE09: 18 EA        					.DW	MSG_06
  2143 00:EE0B: 1E EA        					.DW	MSG_07
  2144 00:EE0D: 24 EA        					.DW	MSG_08
  2145 00:EE0F: 2F EA        					.DW	MSG_09
  2146 00:EE11: 3A EA        					.DW	MSG_0A
  2147 00:EE13: 3E EA        					.DW	MSG_0B
  2148 00:EE15: 44 EA        					.DW	MSG_0C
  2149 00:EE17: 4F EA        					.DW	MSG_0D
  2150 00:EE19: 5A EA        					.DW	MSG_0E
  2151 00:EE1B: 5F EA        					.DW	MSG_0F
  2152 00:EE1D: 64 EA        					.DW	MSG_10
  2153 00:EE1F: 69 EA        					.DW	MSG_11
  2154 00:EE21: 6E EA        					.DW	MSG_12
  2155 00:EE23: 73 EA        					.DW	MSG_13
  2156 00:EE25: 95 EA        					.DW	MSG_14
  2157 00:EE27: B4 EA        					.DW	MSG_15
  2158 00:EE29: C2 EA        					.DW	MSG_16
  2159 00:EE2B: C7 EA        					.DW	MSG_17
  2160 00:EE2D: D2 EA        					.DW	MSG_18
  2161 00:EE2F: D9 EA        					.DW	MSG_19
  2162 00:EE31: E4 EA        					.DW	MSG_1A
  2163 00:EE33: ED EA        					.DW	MSG_1B
  2164 00:EE35: F5 EA        					.DW	MSG_1C
  2165 00:EE37: FE EA        					.DW	MSG_1D
  2166 00:EE39: 09 EB        					.DW	MSG_1E
  2167 00:EE3B: 12 EB        					.DW	MSG_1F
  2168 00:EE3D: 1B EB        					.DW	MSG_20
  2169 00:EE3F: 22 EB        					.DW	MSG_21
  2170 00:EE41: 33 EB        					.DW	MSG_22
  2171 00:EE43: 44 EB        					.DW	MSG_23
  2172 00:EE45: 56 EB        					.DW	MSG_24
  2173 00:EE47: 6F EB        					.DW	MSG_25
  2174 00:EE49: A1 EB        					.DW	MSG_26
  2175 00:EE4B: C0 EB        					.DW	MSG_27
  2176 00:EE4D: 01 EC        					.DW	MSG_28
  Sun Mar  3 2019 23:01                                                                                                    Page 39


  2177 00:EE4F: 17 EC        					.DW	MSG_29					
  2178 00:EE51: 2A EC        					.DW	MSG_2A
  2179 00:EE53: 3F EC        					.DW	MSG_2B
  2180 00:EE55: 52 EC        					.DW	MSG_2C
  2181 00:EE57: A2 ED        					.DW	MSG_2D
  2182 00:EE59: B5 ED        					.DW	MSG_2E
  2183 00:EE5B: BF ED        					.DW	MSG_2F
  2184                        ;
  2185                        ;******************************************************************************
  2186                        ;START OF DISASSEMBLER DATA
  2187                        ;
  2188                        ;Pointer for address mode handlers.
  2189                        ;Each byte contains handler pointer for two opcodes;
  2190                        ;Upper nibble for odd, lower nibble for even
  2191 00:EE5D: 26 00 33 3E  HDLR_IDX	.DB	$26,$00,$33,$3E,$02,$10,$88,$8F
       00:EE61: 02 10 88 8F 
  2192 00:EE65: C7 B0 34 4E  					.DB	$C7,$B0,$34,$4E,$0A,$10,$89,$9F
       00:EE69: 0A 10 89 9F 
  2193 00:EE6D: 86 00 33 3E  					.DB	$86,$00,$33,$3E,$02,$10,$88,$8F
       00:EE71: 02 10 88 8F 
  2194 00:EE75: C7 B0 44 4E  					.DB	$C7,$B0,$44,$4E,$0A,$10,$99,$9F
       00:EE79: 0A 10 99 9F 
  2195 00:EE7D: 06 00 03 3E  					.DB	$06,$00,$03,$3E,$02,$10,$88,$8F
       00:EE81: 02 10 88 8F 
  2196 00:EE85: C7 B0 04 4E  					.DB	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:EE89: 0A 00 09 9F 
  2197 00:EE8D: 06 00 33 3E  					.DB	$06,$00,$33,$3E,$02,$10,$B8,$8F
       00:EE91: 02 10 B8 8F 
  2198 00:EE95: C7 B0 44 4E  					.DB	$C7,$B0,$44,$4E,$0A,$00,$D9,$9F
       00:EE99: 0A 00 D9 9F 
  2199 00:EE9D: C6 00 33 3E  					.DB	$C6,$00,$33,$3E,$02,$00,$88,$8F
       00:EEA1: 02 00 88 8F 
  2200 00:EEA5: C7 B0 44 5E  					.DB	$C7,$B0,$44,$5E,$0A,$00,$89,$9F
       00:EEA9: 0A 00 89 9F 
  2201 00:EEAD: 26 20 33 3E  					.DB	$26,$20,$33,$3E,$02,$00,$88,$8F
       00:EEB1: 02 00 88 8F 
  2202 00:EEB5: C7 B0 44 5E  					.DB	$C7,$B0,$44,$5E,$0A,$00,$99,$AF
       00:EEB9: 0A 00 99 AF 
  2203 00:EEBD: 26 00 33 3E  					.DB	$26,$00,$33,$3E,$02,$00,$88,$8F
       00:EEC1: 02 00 88 8F 
  2204 00:EEC5: C7 B0 04 4E  					.DB	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:EEC9: 0A 00 09 9F 
  2205 00:EECD: 26 00 33 3E  					.DB	$26,$00,$33,$3E,$02,$00,$88,$8F
       00:EED1: 02 00 88 8F 
  2206 00:EED5: C7 B0 04 4E  					.DB	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:EED9: 0A 00 09 9F 
  2207                        ;
  2208                        ;Disassembler handler table:
  2209                        ;Handler address index: (referenced in table HDLR_IDX)
  2210 00:EEDD: EE E5        HDLR_TAB	.DW	IMPLIED	;$00
  2211 00:EEDF: 35 E6        					.DW	ACC_MODE	;$01   
  2212 00:EEE1: 2B E6        					.DW	ZP_IMED	;$02
  2213 00:EEE3: 4D E6        					.DW	ZP_ABS	;$03
  2214 00:EEE5: 75 E6        					.DW	ZP_ABS_X	;$04
  2215 00:EEE7: 81 E6        					.DW	ZP_ABS_Y	;$05
  2216 00:EEE9: 9A E6        					.DW	ZP_IND_X	;$06
  2217 00:EEEB: A2 E6        					.DW	ZP_IND_Y	;$07
  2218 00:EEED: 3D E6        					.DW	ABSOLUTE	;$08
  2219 00:EEEF: 8F E6        					.DW	ABS_X	;$09
  2220 00:EEF1: 8D E6        					.DW	ABS_Y	;$0A
  2221 00:EEF3: 55 E6        					.DW	INDIRECT	;$0B
  2222 00:EEF5: E1 E6        					.DW	REL_BRA	;$0C
  2223 00:EEF7: AA E6        					.DW	IND_ABS_X	;$0D
  Sun Mar  3 2019 23:01                                                                                                    Page 40


  2224 00:EEF9: B8 E6        					.DW	ZP_XMB	;$0E
  2225 00:EEFB: CC E6        					.DW	ZP_BBX	;$0F
  2226                        ;
  2227                        ;Disassembler mnemonic pointer table. This is indexed by the instruction opcode
  2228                        ; The values in this table are an index to the mnemonic data used to print: 
  2229                        MNE_PTAB	;Mnemonic pointer index table
  2230 00:EEFD: 1C 4C 00 00  					.DB	$1C,$4C,$00,$00,$82,$4C,$06,$5E,$50,$4C,$06,$00,$82,$4C,$06,
                    $08
       00:EF01: 82 4C 06 5E 
       00:EF05: 50 4C 06 00 
       00:EF09: 82 4C 06 08 
  2231 00:EF0D: 18 4C 4C 00  					.DB	$18,$4C,$4C,$00,$80,$4C,$06,$5E,$22,$4C,$38,$00,$80,$4C,$06,
                    $08
       00:EF11: 80 4C 06 5E 
       00:EF15: 22 4C 38 00 
       00:EF19: 80 4C 06 08 
  2232 00:EF1D: 40 04 00 00  					.DB	$40,$04,$00,$00,$12,$04,$60,$5E,$58,$04,$60,$00,$12,$04,$60,
                    $08
       00:EF21: 12 04 60 5E 
       00:EF25: 58 04 60 00 
       00:EF29: 12 04 60 08 
  2233 00:EF2D: 14 04 04 00  					.DB	$14,$04,$04,$00,$12,$04,$60,$5E,$6A,$04,$30,$00,$12,$04,$60,
                    $08
       00:EF31: 12 04 60 5E 
       00:EF35: 6A 04 30 00 
       00:EF39: 12 04 60 08 
  2234 00:EF3D: 64 36 00 00  					.DB	$64,$36,$00,$00,$00,$36,$48,$5E,$4E,$36,$48,$00,$3E,$36,$48,
                    $08
       00:EF41: 00 36 48 5E 
       00:EF45: 4E 36 48 00 
       00:EF49: 3E 36 48 08 
  2235 00:EF4D: 1E 36 36 00  					.DB	$1E,$36,$36,$00,$00,$36,$48,$5E,$26,$36,$54,$00,$00,$36,$48,
                    $08
       00:EF51: 00 36 48 5E 
       00:EF55: 26 36 54 00 
       00:EF59: 00 36 48 08 
  2236 00:EF5D: 66 02 00 00  					.DB	$66,$02,$00,$00,$7A,$02,$62,$5E,$56,$02,$62,$00,$3E,$02,$62,
                    $08
       00:EF61: 7A 02 62 5E 
       00:EF65: 56 02 62 00 
       00:EF69: 3E 02 62 08 
  2237 00:EF6D: 20 02 02 00  					.DB	$20,$02,$02,$00,$7A,$02,$62,$5E,$6E,$02,$5C,$00,$3E,$02,$62,
                    $08
       00:EF71: 7A 02 62 5E 
       00:EF75: 6E 02 5C 00 
       00:EF79: 3E 02 62 08 
  2238 00:EF7D: 1A 72 00 00  					.DB	$1A,$72,$00,$00,$78,$72,$76,$70,$34,$12,$86,$00,$78,$72,$76,
                    $0A
       00:EF81: 78 72 76 70 
       00:EF85: 34 12 86 00 
       00:EF89: 78 72 76 0A 
  2239 00:EF8D: 0C 72 72 00  					.DB	$0C,$72,$72,$00,$78,$72,$76,$70,$8A,$72,$88,$00,$7A,$72,$7A,
                    $0A
       00:EF91: 78 72 76 70 
       00:EF95: 8A 72 88 00 
       00:EF99: 7A 72 7A 0A 
  2240 00:EF9D: 46 42 44 00  					.DB	$46,$42,$44,$00,$46,$42,$44,$70,$7E,$42,$7C,$00,$46,$42,$44,
                    $0A
       00:EFA1: 46 42 44 70 
       00:EFA5: 7E 42 7C 00 
       00:EFA9: 46 42 44 0A 
  2241 00:EFAD: 0E 42 42 00  					.DB	$0E,$42,$42,$00,$46,$42,$44,$70,$28,$42,$84,$00,$46,$42,$44,
                    $0A
  Sun Mar  3 2019 23:01                                                                                                    Page 41


       00:EFB1: 46 42 44 70 
       00:EFB5: 28 42 84 00 
       00:EFB9: 46 42 44 0A 
  2242 00:EFBD: 2E 2A 00 00  					.DB	$2E,$2A,$00,$00,$2E,$2A,$30,$70,$3C,$2A,$32,$8C,$2E,$2A,$30,
                    $0A
       00:EFC1: 2E 2A 30 70 
       00:EFC5: 3C 2A 32 8C 
       00:EFC9: 2E 2A 30 0A 
  2243 00:EFCD: 16 2A 2A 00  					.DB	$16,$2A,$2A,$00,$00,$2A,$30,$70,$24,$2A,$52,$74,$00,$2A,$30,
                    $0A
       00:EFD1: 00 2A 30 70 
       00:EFD5: 24 2A 52 74 
       00:EFD9: 00 2A 30 0A 
  2244 00:EFDD: 2C 68 00 00  					.DB	$2C,$68,$00,$00,$2C,$68,$38,$70,$3A,$68,$4A,$00,$2C,$68,$38,
                    $0A
       00:EFE1: 2C 68 38 70 
       00:EFE5: 3A 68 4A 00 
       00:EFE9: 2C 68 38 0A 
  2245 00:EFED: 10 68 68 00  					.DB	$10,$68,$68,$00,$00,$68,$38,$70,$6C,$68,$5A,$00,$00,$68,$38,
                    $0A
       00:EFF1: 00 68 38 70 
       00:EFF5: 6C 68 5A 00 
       00:EFF9: 00 68 38 0A 
  2246                        ;
  2247                        DIS_NMEM	;Mnemonic compressed table
  2248                        ;	Uses two bytes per 3-character Mnemonic. 5-bits per character uses 15-bit total
  2249                        ;	Characters are left to right. 5-bits shifted into A reg, add in $3F and print
  2250                        ;	"?" starts with "00000", "A" starts with "00010", "B" starts with "00011", etc.
  2251                        ;
  2252                        ; A	00010		B	00011		C	00100		D	00101		E	
                    00110		F	00111		G	01000		H	01001
  2253                        ;	I	01010		J	01011		K	01100		L	01101		M	
                    01110		N	01111		O	10000		P	10001
  2254                        ;	Q	10010		R	10011		S	10100		T	10101		U	
                    10110		V	10111		W	11000		X	11001
  2255                        ;	Y	11010		Z	11011
  2256                        ;
  2257 00:EFFD: 00 00        					.DBYTE	%0000000000000000	;???	$00
  2258 00:EFFF: 11 48        					.DBYTE	%0001000101001000	;ADC	$02
  2259 00:F001: 13 CA        					.DBYTE	%0001001111001010	;AND	$04
  2260 00:F003: 15 1A        					.DBYTE	%0001010100011010	;ASL	$06
  2261 00:F005: 18 E6        					.DBYTE	%0001100011100110	;BBR	$08
  2262 00:F007: 18 E8        					.DBYTE	%0001100011101000	;BBS	$0A
  2263 00:F009: 19 08        					.DBYTE	%0001100100001000	;BCC	$0C
  2264 00:F00B: 19 28        					.DBYTE	%0001100100101000	;BCS	$0E
  2265 00:F00D: 19 A4        					.DBYTE	%0001100110100100	;BEQ	$10
  2266 00:F00F: 1A AA        					.DBYTE	%0001101010101010	;BIT	$12
  2267 00:F011: 1B 94        					.DBYTE	%0001101110010100	;BMI	$14
  2268 00:F013: 1B CC        					.DBYTE	%0001101111001100	;BNE	$16
  2269 00:F015: 1C 5A        					.DBYTE	%0001110001011010	;BPL	$18
  2270 00:F017: 1C C4        					.DBYTE	%0001110011000100	;BRA	$1A
  2271 00:F019: 1C D8        					.DBYTE	%0001110011011000	;BRK	$1C
  2272 00:F01B: 1D C8        					.DBYTE	%0001110111001000	;BVC	$1E
  2273 00:F01D: 1D E8        					.DBYTE	%0001110111101000	;BVS	$20
  2274 00:F01F: 23 48        					.DBYTE	%0010001101001000	;CLC	$22
  2275 00:F021: 23 4A        					.DBYTE	%0010001101001010	;CLD	$24
  2276 00:F023: 23 54        					.DBYTE	%0010001101010100	;CLI	$26
  2277 00:F025: 23 6E        					.DBYTE	%0010001101101110	;CLV	$28
  2278 00:F027: 23 A2        					.DBYTE	%0010001110100010	;CMP	$2A
  2279 00:F029: 24 72        					.DBYTE	%0010010001110010	;CPX	$2C
  2280 00:F02B: 24 74        					.DBYTE	%0010010001110100	;CPY	$2E
  2281 00:F02D: 29 88        					.DBYTE	%0010100110001000	;DEC	$30
  2282 00:F02F: 29 B2        					.DBYTE	%0010100110110010	;DEX	$32
  Sun Mar  3 2019 23:01                                                                                                    Page 42


  2283 00:F031: 29 B4        					.DBYTE	%0010100110110100	;DEY	$34
  2284 00:F033: 34 26        					.DBYTE	%0011010000100110	;EOR	$36
  2285 00:F035: 53 C8        					.DBYTE	%0101001111001000	;INC	$38
  2286 00:F037: 53 F2        					.DBYTE	%0101001111110010	;INX	$3A
  2287 00:F039: 53 F4        					.DBYTE	%0101001111110100	;INY	$3C
  2288 00:F03B: 5B A2        					.DBYTE	%0101101110100010	;JMP	$3E
  2289 00:F03D: 5D 26        					.DBYTE	%0101110100100110	;JSR	$40
  2290 00:F03F: 69 44        					.DBYTE	%0110100101000100	;LDA	$42
  2291 00:F041: 69 72        					.DBYTE	%0110100101110010	;LDX	$44
  2292 00:F043: 69 74        					.DBYTE	%0110100101110100	;LDY	$46
  2293 00:F045: 6D 26        					.DBYTE	%0110110100100110	;LSR	$48
  2294 00:F047: 7C 22        					.DBYTE	%0111110000100010	;NOP	$4A
  2295 00:F049: 84 C4        					.DBYTE	%1000010011000100	;ORA	$4C
  2296 00:F04B: 8A 44        					.DBYTE	%1000101001000100	;PHA	$4E
  2297 00:F04D: 8A 62        					.DBYTE	%1000101001100010	;PHP	$50
  2298 00:F04F: 8A 72        					.DBYTE	%1000101001110010	;PHX	$52
  2299 00:F051: 8A 74        					.DBYTE	%1000101001110100	;PHY	$54
  2300 00:F053: 8B 44        					.DBYTE	%1000101101000100	;PLA	$56
  2301 00:F055: 8B 62        					.DBYTE	%1000101101100010	;PLP	$58
  2302 00:F057: 8B 72        					.DBYTE	%1000101101110010	;PLX	$5A
  2303 00:F059: 8B 74        					.DBYTE	%1000101101110100	;PLY	$5C
  2304 00:F05B: 9B 86        					.DBYTE	%1001101110000110	;RMB	$5E
  2305 00:F05D: 9C 1A        					.DBYTE	%1001110000011010	;ROL	$60
  2306 00:F05F: 9C 26        					.DBYTE	%1001110000100110	;ROR	$62
  2307 00:F061: 9D 54        					.DBYTE	%1001110101010100	;RTI	$64
  2308 00:F063: 9D 68        					.DBYTE	%1001110101101000	;RTS	$66
  2309 00:F065: A0 C8        					.DBYTE	%1010000011001000	;SBC	$68
  2310 00:F067: A1 88        					.DBYTE	%1010000110001000	;SEC	$6A
  2311 00:F069: A1 8A        					.DBYTE	%1010000110001010	;SED	$6C
  2312 00:F06B: A1 94        					.DBYTE	%1010000110010100	;SEI	$6E
  2313 00:F06D: A3 86        					.DBYTE	%1010001110000110	;SMB	$70
  2314 00:F06F: A5 44        					.DBYTE	%1010010101000100	;STA	$72
  2315 00:F071: A5 62        					.DBYTE	%1010010101100010	;STP	$74
  2316 00:F073: A5 72        					.DBYTE	%1010010101110010	;STX	$76
  2317 00:F075: A5 74        					.DBYTE	%1010010101110100	;STY	$78
  2318 00:F077: A5 76        					.DBYTE	%1010010101110110	;STZ	$7A
  2319 00:F079: A8 B2        					.DBYTE	%1010100010110010	;TAX	$7C
  2320 00:F07B: A8 B4        					.DBYTE	%1010100010110100	;TAY	$7E
  2321 00:F07D: AC E8        					.DBYTE	%1010110011101000	;TRB	$80
  2322 00:F07F: AD 06        					.DBYTE	%1010110100000110	;TSB	$82
  2323 00:F081: AD 32        					.DBYTE	%1010110100110010	;TSX	$84
  2324 00:F083: AE 44        					.DBYTE	%1010111001000100	;TXA	$86
  2325 00:F085: AE 68        					.DBYTE	%1010111001101000	;TXS	$88
  2326 00:F087: AE 84        					.DBYTE	%1010111010000100	;TYA	$8A
  2327 00:F089: C0 94        					.DBYTE	%1100000010010100	;WAI	$8C
  2328                        ;
  2329                        ;END OF DISASSEMBLER DATA
  2330                        ;******************************************************************************
  2331                        ;END OF MONITOR DATA
  2332                        ;******************************************************************************
  2333                        ;
  2334                        ;******************************************************************************
  2335                        				.org	$F800	;2KB reserved for BIOS, I/O device selects (256 bytes)
  2336                        ;******************************************************************************
  2337                        ;START OF BIOS CODE
  2338                        ;******************************************************************************
  2339                        ; C02BIOS version used here is 1.4
  2340                        ;
  2341                        ; Contains the base BIOS routines in top 1KB of EEPROM
  2342                        ; - Pages $F8/$F9 512 bytes for BIOS (65C51/65C22), NMI Panic routine
  2343                        ; - Pages $FA-$FD reserved for BIOS expansion
  2344                        ; - Page $FE reserved for HW (8-I/O devices, 32 bytes wide)
  2345                        ; - Page ($FF) JMP table, CPU startup, 64 bytes Soft Vectors and HW Config data
  Sun Mar  3 2019 23:01                                                                                                    Page 43


  2346                        ;		- does I/O init and handles NMI/BRK/IRQ pre-/post-processing routines
  2347                        ;		- sends BIOS message string to console
  2348                        ;	- Additional code added to handle XMODEM transfers
  2349                        ;		- allows a null character to be received into the buffer
  2350                        ;		- CRC bytes can be zero, original code would invoke BRK routine
  2351                        ;		- Uses the XMFLAG flag which is set/cleared during Xmodem xfers
  2352                        ;		- Now uses BBR instruction to check XMFLAG - saves a byte
  2353                        ;		-	Now uses BBR instruction to check BRK condition - saves a byte
  2354                        ; - BEEP moved to main monitor code, JMP entry replaced with CHRIN_NW
  2355                        ; - Input/Feedback from "BDD" - modified CHR-I/O routines - saves 12 bytes
  2356                        ;******************************************************************************
  2357                        ;	The following 16 functions are provided by BIOS and available via the JMP
  2358                        ;	Table as the last 16 entries from $FF48 - $FF75 as:
  2359                        ;	$FF48 CHRIN_NW (character input from console, no waiting, set carry if none)
  2360                        ;	$FF4B CHRIN (character input from console)
  2361                        ;	$FF4E CHROUT (character output to console)
  2362                        ;	$FF51 SETDLY (set delay value for milliseconds and 16-bit counter)
  2363                        ;	$FF54 MSDELAY (execute millisecond delay 1-256 milliseconds)
  2364                        ;	$FF57 LGDELAY (execute long delay; millisecond delay * 16-bit count)
  2365                        ;	$FF5A XLDELAY (execute extra long delay; 8-bit count * long delay)
  2366                        ;	$FF5D SETPORT (set VIA port A or B for input or output)
  2367                        ;	$FF60 RDPORT (read from VIA port A or B)
  2368                        ;	$FF63 WRPORT (write to VIA port A or B)
  2369                        ;	$FF66 INITVEC (initialize soft vectors at $0300 from ROM)
  2370                        ;	$FF69 INITCFG (initialize soft config values at $0320 from ROM)
  2371                        ;	$FF6C INITCON (initialize 65C51 console 19.2K, 8-N-1 RTS/CTS)
  2372                        ;	$FF6F INITVIA (initialize 65C22 default port, timers and interrupts)
  2373                        ;	$FF72 MONWARM (warm start Monitor - jumps to page $03)
  2374                        ;	$FF75 MONCOLD (cold start Monitor - jumps to page $03)
  2375                        ;******************************************************************************
  2376                        ; Character In and Out routines for Console I/O buffer
  2377                        ;******************************************************************************
  2378                        ;
  2379                        ;CHRIN routines
  2380                        ;CHRIN_NW uses CHRIN, returns if a character is not available from the buffer
  2381                        ; with carry flag clear, else returns with character in A reg and carry flag set
  2382                        ;CHRIN waitd for a character to be in the buffer, then returns with carry flag set
  2383                        ;	receive is IRQ driven / buffered with a fixed size of 128 bytes
  2384                        ;
  2385 00:F800: 18           CHRIN_NW	CLC	:Clear Carry flag for no character (2)
  2386 00:F801: A5 E7        					LDA	ICNT	;Get character count (3)
  2387 00:F803: D0 05        					BNE	GET_CH	;Branch if buffer is not empty (2/3)
  2388 00:F805: 60           					RTS	;and return to caller (6)
  2389                        ;
  2390                        ;CHRIN waits for a character and retuns with it in the A reg
  2391                        ;
  2392 00:F806: A5 E7        CHRIN			LDA	ICNT	;Get character count (3)
  2393 00:F808: F0 FC        					BEQ	CHRIN	;If zero (no character, loop back) (2/3)
  2394                        ;
  2395 00:F80A: 5A           GET_CH		PHY	;Save Y reg (3)
  2396 00:F80B: A4 E8        					LDY	IHEAD	;Get the buffer head pointer (3)
  2397 00:F80D: B9 00 02     					LDA	IBUF,Y	;Get the character from the buffer (4)
  2398                        ;
  2399 00:F810: E6 E8        					INC	IHEAD	;Increment head pointer (5)
  2400 00:F812: 77 E8        					RMB7	IHEAD	;Strip off bit 7, 128 bytes only (5)
  2401                        ;
  2402 00:F814: C6 E7        					DEC	ICNT	;Decrement the buffer count (5)
  2403 00:F816: 7A           					PLY	;Restore Y Reg (4)
  2404 00:F817: 38           					SEC	;Set Carry flag for character available (2)
  2405 00:F818: 60           					RTS	;Return to caller with character in A reg (6)
  2406                        ;
  2407                        ;CHROUT routine: takes the character in the A reg and places it in the xmit buffer
  2408                        ; the character sent in the A reg is preserved on exit
  Sun Mar  3 2019 23:01                                                                                                    Page 44


  2409                        ;	transmit is IRQ driven / buffered with a fixed size of 128 bytes
  2410                        ;
  2411                        ;	- 8/10/2014 - modified this routine to always set the Xmit interrupt active with each
  2412                        ;	character placed into the output buffer. There appears to be a highly intermittant bug
  2413                        ;	in both the 6551 and 65C51 where the Xmit interrupt turns itself off, the code itself
  2414                        ;	is not doing it as the OIE flag was never reset and this only happens in the IRQ routine
  2415                        ;	The I/O and service routines now appear to work in a stable manner on all 6551 and 65C51
  2416                        ;	Note: OIE flag no longer needed/used due to bug workaround
  2417                        ;
  2418 00:F819: 5A           CHROUT		PHY	;save Y reg	(3)
  2419 00:F81A: A4 EA        OUTCH			LDY	OCNT	;get character output count in buffer	(3)
  2420 00:F81C: 30 FC        					BMI	OUTCH	;check against limit, loop back if full	(2/3)
  2421                        ;
  2422 00:F81E: A4 EC        					LDY	OTAIL	;Get the buffer tail pointer	(3)
  2423 00:F820: 99 80 02     					STA	OBUF,Y	;Place character in the buffer	(5)
  2424                        ;
  2425 00:F823: E6 EC        					INC	OTAIL	;Increment Tail pointer (5)
  2426 00:F825: 77 EC        					RMB7	OTAIL	;Strip off bit 7, 128 bytes only (5)
  2427 00:F827: E6 EA        					INC	OCNT	;Increment character count	(5)
  2428                        ;
  2429 00:F829: A0 05        					LDY	#$05	;Get mask for xmit on	(2)
  2430 00:F82B: 8C 22 FE     					STY	SIOCOM	;Turn on xmit irq	(4)
  2431                        ;
  2432 00:F82E: 7A           OUTC2			PLY	;Restore Y reg	(4)
  2433 00:F82F: 60           					RTS	;Return	to caller (6)
  2434                        ;
  2435                        ;******************************************************************************
  2436                        ;SET DELAY routine
  2437                        ; This routine sets up the MSDELAY values and can also set the Long Delay variable
  2438                        ; On entry, A reg = millisecond count, X reg = High multipler, Y reg = Low multipler
  2439                        ;	these values are used by the EXE_MSDLY and EXE_LGDLY routines
  2440                        ;	values for MSDELAY are $00-$FF ($00 = 256 times)
  2441                        ;	values for Long Delay are $0000-$FFFF (0-65535 times)
  2442                        ;	longest delay is 65,535*256*1ms = 16,776,960 * 0.001 = 16,776.960 seconds
  2443                        ;
  2444 00:F830: 85 F6        SET_DLY		STA	SETIM	;Save millisecond count (3)
  2445 00:F832: 84 F7        					STY	DELLO	;Save Low multipler (3)
  2446 00:F834: 86 F8        					STX	DELHI	;Save High Multipler (3)
  2447 00:F836: 60           					RTS	;Return to caller (6)
  2448                        ;
  2449                        ;EXE MSDELAY routine
  2450                        ;	This routine is the core delay routine
  2451                        ;	It sets the count value from SETIM variable, enables the MATCH flag, then starts
  2452                        ;	Timer 2 and waits for the IRQ routine to decrement to zero and clear the MATCH flag
  2453                        ;	note: 3 clock cycles (JMP table) to get here on a standard call
  2454                        ;	- 11 clock cycles to start T2, 15 clock cycles to return after MATCH cleared
  2455                        ;	- starting T2 first to help normalize overall delay time
  2456                        ;	- total of 37 clock cycles overhead in this routine
  2457                        ;
  2458 00:F837: 48           EXE_MSDLY	PHA	;Save A Reg (3)
  2459 00:F838: AD 29 03     					LDA	LOAD_6522+$07	;Get T2H value (4)
  2460 00:F83B: 8D 09 FE     					STA	Via1T2CH	;Reload T2 and enable interrupt (4)
  2461 00:F83E: F7 F5        					SMB7	MATCH	;Set MATCH flag bit (5)
  2462 00:F840: A5 F6        					LDA	SETIM	;Get delay seed value (3)
  2463 00:F842: 85 F4        					STA	MSDELAY	;Set MS delay value (3)
  2464                        ;
  2465 00:F844: FF F5 FD     MATCH_LP	BBS7	MATCH,MATCH_LP	;Test MATCH flag, loop until cleared (5)
  2466 00:F847: 68           					PLA	;Restore A Reg (4)
  2467 00:F848: 60           					RTS	;Return to caller (6)
  2468                        ;
  2469                        ;EXE LONG Delay routine
  2470                        ;	This routine is the 16-bit multiplier for the MS DELAY routine
  2471                        ;	It loads the 16-bit count from DELLO/DELHI, then loops the MSDELAY
  Sun Mar  3 2019 23:01                                                                                                    Page 45


  2472                        ;	routine until the 16-bit count is decremented to zero
  2473                        ;
  2474 00:F849: DA           EXE_LGDLY	PHX	;Save X Reg (4)
  2475 00:F84A: 5A           					PHY	;Save Y Reg (4)
  2476 00:F84B: A6 F8        					LDX	DELHI	;Get high byte count (3)
  2477 00:F84D: E8           					INX	;Increment by one (checks for $00 vs $FF) (2)
  2478 00:F84E: A4 F7        					LDY	DELLO	;Get low byte count (3)
  2479 00:F850: F0 06        					BEQ	SKP_DLL	;If zero, skip to high count (2/3)
  2480 00:F852: 20 37 F8     DO_DLL		JSR	EXE_MSDLY	;Call millisecond delay (6)
  2481 00:F855: 88           					DEY	;Decrement low count (2)
  2482 00:F856: D0 FA        					BNE	DO_DLL	;Branch back until done (2/3)
  2483                        ;
  2484 00:F858: CA           SKP_DLL		DEX	;Decrement high byte index (2)
  2485 00:F859: D0 F7        					BNE	DO_DLL	;Loop back to DLL (will run 256 times) (2/3)
  2486 00:F85B: 7A           					PLY	;Restore Y Reg (3)
  2487 00:F85C: FA           					PLX	;Restore X Reg (3)
  2488 00:F85D: 60           					RTS	;Return to caller (6)
  2489                        ;
  2490                        ;EXE EXTRA LONG Delay routine
  2491                        ;	This routine uses XDL variable as an 8-bit count
  2492                        ;	and calls the EXE LONG Delay routine XDL times
  2493                        ;	- On entry, XDL contains the number of interations
  2494 00:F85E: 20 49 F8     EXE_XLDLY	JSR	EXE_LGDLY	;Call the Long Delay routine (6)
  2495 00:F861: C6 F9        					DEC	XDL	;Decrement count (5)
  2496 00:F863: D0 F9        					BNE	EXE_XLDLY	;Loop back until XDL times out (2/3)
  2497 00:F865: 60           					RTS	;Done, return to caller (6)
  2498                        ;	
  2499                        ;******************************************************************************
  2500                        ; I/O PORT routines for 6522
  2501                        ;	- Allows port A or B setup for input or output
  2502                        ;	- Allows data to be read from Port A or B
  2503                        ;	- Allows data to be written to Port A or B
  2504                        ;	- Routines are Non-buffered and no HW handshaking
  2505                        ;	- Page zero variables are used: IO_DIR, IO_IN, IO_OUT
  2506                        ;
  2507                        ;	6522 Port Config routine
  2508                        ;	- Allows Port A or B to be configured for input or output
  2509                        ;	- On entry, X reg contains port number (1=A, 0=B)
  2510                        ;	- A reg contains config mask; bit=0 for Input, bit=1 for Output
  2511                        ;	- on exit, A reg contain Port DDR value, X reg contains port #
  2512                        ;	- Carry set if error, cleared if OK
  2513                        ;
  2514 00:F866: 9D 02 FE     SET_PORT	STA	Via1DDRB,X	;Store config Mask to the correct port (5)
  2515 00:F869: 85 FB        					STA	IO_DIR	;Save Mask for compare (3)
  2516 00:F86B: BD 02 FE     					LDA	Via1DDRB,X	;Load config Mask back from port (4)
  2517 00:F86E: C5 FB        					CMP	IO_DIR	;Compare to config MASK (3)
  2518 00:F870: B0 02        					BCS	PORT_OK	;Branch if same (2/3)
  2519 00:F872: 38           					SEC	;Set Carry for bad compare (2)
  2520 00:F873: 60           					RTS	;Return to caller (6)
  2521 00:F874: 18           PORT_OK		CLC	;Clear Carry flag for no error (2)
  2522 00:F875: 60           					RTS	;Return to caller (6)
  2523                        ;
  2524                        ;	Port Input routine
  2525                        ;	- On entry, X reg contains port number (1=A, 0=B)
  2526                        ;	- On exit, A reg contains read data, X reg contains port #
  2527                        ;	- Carry set if error on read, cleared if OK
  2528                        ;	- Requested Port is read twice and compared for error,
  2529                        ;	- this implies port data input does not change too quickly
  2530                        ;
  2531 00:F876: BD 00 FE     IN_PORT		LDA	Via1PRB,X	;Read Port data (4)
  2532 00:F879: 85 FC        					STA	IO_IN	;Save Read data (3)
  2533 00:F87B: BD 00 FE     					LDA	Via1PRB,X	;Read Port a second time (4)
  2534 00:F87E: C5 FC        					CMP	IO_IN	;Compare against previous read (3)
  Sun Mar  3 2019 23:01                                                                                                    Page 46


  2535 00:F880: B0 F2        					BCS	PORT_OK	;Branch if same (2/3)
  2536 00:F882: 38           					SEC	;Set Carry for bad compare (2)
  2537 00:F883: 60           					RTS	;Return to caller (6)
  2538                        ;
  2539                        ;	Port Output routine
  2540                        ;	- On entry, X reg contains port number (1=A, 0=B)
  2541                        ;	- A reg contain data to write to port
  2542                        ;	- On exit, A reg contains Port data, X reg contains port #
  2543                        ;	- Carry set if error on write, cleared if OK
  2544                        ;
  2545 00:F884: 9D 00 FE     OUT_PORT	STA	Via1PRB,X	;Write Port data (5)
  2546 00:F887: 85 FD        					STA	IO_OUT	;Save data to output to port (3)
  2547 00:F889: BD 00 FE     					LDA	Via1PRB,X	;Read Port data back (4)
  2548 00:F88C: C5 FD        					CMP	IO_OUT	;Compare against previous read (3)
  2549 00:F88E: B0 E4        					BCS	PORT_OK	;Branch if same (2/3)
  2550 00:F890: 38           					SEC	;Set Carry for bad compare (2)
  2551 00:F891: 60           					RTS	;Return to caller (6)
  2552                        ;
  2553                        ;******************************************************************************
  2554                        ;
  2555                        ;START OF PANIC ROUTINE
  2556                        ; The Panic routine is for debug of system problems, i.e., a crash
  2557                        ; The design requires a debounced NMI trigger button which is manually operated
  2558                        ; when the system crashes or malfunctions, press the NMI (panic) button
  2559                        ; The NMI vectored routine will perform the following tasks:
  2560                        ; 1- Save registers in page $00
  2561                        ; 2- Save pages $00, $01, $02 and $03 at location $0400-$07FF
  2562                        ; 3- Overlay the I/O page ($FE) at location $0780
  2563                        ; 4- Zero I/O buffer pointers
  2564                        ; Call the ROM routines to init the vectors and config data (page $03)
  2565                        ; Call ROM routines to init the 6551 and 6522 devices
  2566                        ; Restart the Monitor via warm start vector
  2567                        ; No memory is cleared except the required pointers to restore the system
  2568                        ;	- suggest invoking the Register command afterwards to get the details saved
  2569                        ;
  2570                        NMI_VECTOR	;This is the ROM start for NMI Panic handler
  2571 00:F892: 85 E6        					STA	AREG	;Save A Reg (3)
  2572 00:F894: 86 E5        					STX	XREG	;Save X Reg (3)
  2573 00:F896: 84 E4        					STY	YREG	;Save Y Reg (3)
  2574 00:F898: 68           					PLA	;Get Processor Status 	      (3)   
  2575 00:F899: 85 E2        					STA	PREG	;Save in PROCESSOR STATUS preset/result (3)
  2576 00:F89B: BA           					TSX	;Get Stack pointer (2)
  2577 00:F89C: 86 E3        					STX	SREG	;Save STACK POINTER (3)
  2578 00:F89E: 68           					PLA	;Pull RETURN address from STACK (3)
  2579 00:F89F: 85 E0        					STA	PCL	;Store Low byte (3)
  2580 00:F8A1: 68           					PLA	;Pull high byte (3)
  2581 00:F8A2: 85 E1        					STA	PCH	;Store High byte (3)
  2582                        ;
  2583 00:F8A4: A0 00        					LDY	#$00	;Zero Y reg (2)
  2584 00:F8A6: A2 04        					LDX	#$04	;Set index to 4 pages (2)
  2585 00:F8A8: 86 03        					STX	$03	;Set to high order (3)
  2586 00:F8AA: 64 02        					STZ	$02	;Zero remaining pointers (3)
  2587 00:F8AC: 64 01        					STZ	$01 ;(3)
  2588 00:F8AE: 64 00        					STZ	$00 ;(3)
  2589                        ;
  2590 00:F8B0: B1 00        PLP0			LDA	($00),Y	;get byte (4)
  2591 00:F8B2: 91 02        					STA	($02),Y	;store byte (6)
  2592 00:F8B4: 88           					DEY	;Decrement index (2)
  2593 00:F8B5: D0 F9        					BNE	PLP0	;Loop back till done (2/3)
  2594                        ;
  2595 00:F8B7: E6 03        					INC	$03	;Increment page address (5)
  2596 00:F8B9: E6 01        					INC	$01	;Increment page address (5)
  2597 00:F8BB: CA           					DEX	;Decrement page index (2)
  Sun Mar  3 2019 23:01                                                                                                    Page 47


  2598 00:F8BC: D0 F2        					BNE	PLP0	;Branch back and do next page (2/3)
  2599                        ;					
  2600 00:F8BE: BD 00 FE     IO_LOOP		LDA	$FE00,X	;Get I/O Page (X reg already at #$00) (4)
  2601 00:F8C1: 9D 80 07     					STA	$0780,X	;Overlay I/O page to Vector Save (5)
  2602 00:F8C4: E8           					INX	;Increment index (2)
  2603 00:F8C5: 10 F7        					BPL	IO_LOOP	;Loop back until done (128 bytes) (2/3)
  2604                        ;
  2605 00:F8C7: A2 06        					LDX	#$06	;Get count of 6 (2)
  2606 00:F8C9: 74 E6        PAN_LP1		STZ	ICNT-1,X	;Zero out console I/O pointers (4)
  2607 00:F8CB: CA           					DEX	;Decrement index (2)
  2608 00:F8CC: D0 FB        					BNE	PAN_LP1	;Branch back till done (2/3)
  2609                        ;
  2610 00:F8CE: 20 B2 F9     					JSR	INIT_PG03	;Xfer default Vectors/HW Config to $0300 (6)
  2611 00:F8D1: 20 DD F9     					JSR	INIT_IO	;Init I/O - Console, Timers, Ports (6)
  2612                        ;
  2613 00:F8D4: 6C 06 03     					JMP	(NMIRTVEC0)	;Jump to Monitor Warm Start Vector (5)
  2614                        ;
  2615                        ;*************************************
  2616                        ;* BRK/IRQ Interrupt service routine *
  2617                        ;*************************************
  2618                        ;
  2619                        ;The pre-process routine located in page $FF soft-vectors to here:
  2620                        ;	The following routines handle BRK and IRQ
  2621                        ;	The BRK handler saves CPU details for register display
  2622                        ;	- A Monitor can provide a disassembly of the last executed instruction
  2623                        ;	- An ASCII null character ($00) is also handled here
  2624                        ;
  2625                        ;6551 handler
  2626                        ;	The 6551 IRQ routine handles both transmit and receive via IRQ
  2627                        ;	- each has it's own 128 circular buffer
  2628                        ;	- Xmit IRQ is controlled by the handler and the CHROUT routine
  2629                        ;
  2630                        ;6522 handler
  2631                        ; The 6522 IRQ routine handles Timer1 interrupts used for a RTC
  2632                        ;	- resolution is set for 4ms (250 interrupts per second)
  2633                        ;	- recommended CPU clock rate is 2MHz minimum
  2634                        ; Timer2 provides an accurate delay with resolution to 1ms
  2635                        ;	- timer service/match routine are IRQ driven with dedicated handler
  2636                        ;
  2637 00:F8D7: 58           BREAKEY		CLI	;Enable IRQ (2)
  2638                        ;
  2639 00:F8D8: 7A           BRKINSTR0	PLY	;Restore Y reg (4)
  2640 00:F8D9: FA           					PLX	;Restore X Reg (4)
  2641 00:F8DA: 68           					PLA	;Restore A Reg (4)
  2642 00:F8DB: 85 E6        					STA	AREG	;Save A Reg (3)
  2643 00:F8DD: 86 E5        					STX	XREG	;Save X Reg (3)
  2644 00:F8DF: 84 E4        					STY	YREG	;Save Y Reg (3)
  2645 00:F8E1: 68           					PLA	;Get Processor Status (4)	        
  2646 00:F8E2: 85 E2        					STA	PREG	;Save in PROCESSOR STATUS preset/result (2)
  2647 00:F8E4: BA           					TSX	;Xfrer STACK pointer to X reg (2)
  2648 00:F8E5: 86 E3        					STX	SREG	;Save STACK pointer (4)
  2649                        ;
  2650 00:F8E7: FA           					PLX	;Pull Low RETURN address from STACK then save it (4)
  2651 00:F8E8: 86 E0        					STX	PCL	;Store program counter Low byte (3)
  2652 00:F8EA: 86 C0        					STX	INDEXL	;Seed Indexl for DIS_LINE (3)
  2653 00:F8EC: 7A           					PLY	;Pull High RETURN address from STACK then save it (4)
  2654 00:F8ED: 84 E1        					STY	PCH	;Store program counter High byte (3)
  2655 00:F8EF: 84 C1        					STY	INDEXH	;Seed Indexh for DIS_LINE (3)
  2656 00:F8F1: 4F E2 09     					BBR4	PREG,DO_NULL	;Check for BRK bit set (5)
  2657                        ;
  2658                        ; The following three subroutines are contained in the base Monitor code
  2659                        ; These calls do a register display and disassembles the line of code
  2660                        ; that caused the BRK to occur. Other code can be added if required
  Sun Mar  3 2019 23:01                                                                                                    Page 48


  2661                        ;	- if replaced with new code, either replace or remove this routine
  2662                        ;
  2663 00:F8F4: 20 EB E4     					JSR	PRSTAT1	;Display CPU status (6)
  2664 00:F8F7: 20 EE E0     					JSR	DECINDEX	;Decrement Index location (point to BRK ID B
                    yte) (6)
  2665 00:F8FA: 20 B0 E5     					JSR	DIS_LINE	;Disassemble current instruction (6)
  2666                        ;
  2667 00:F8FD: A9 00        DO_NULL		LDA	#$00	;Clear all PROCESSOR STATUS REGISTER bits (2)
  2668 00:F8FF: 48           					PHA	; (3)
  2669 00:F900: 28           					PLP	; (4)
  2670 00:F901: 64 E9        					STZ	ITAIL	;Zero out input buffer / reset pointers (3)
  2671 00:F903: 64 E8        					STZ	IHEAD	; (3)
  2672 00:F905: 64 E7        					STZ	ICNT	; (3)
  2673 00:F907: 6C 08 03     					JMP	(BRKRTVEC0)	;Done BRK service process, re-enter monitor 
                    (3)
  2674                        ;
  2675                        ;new full duplex IRQ handler (54 clock cycles overhead to this point - includes return)
  2676                        ;
  2677 00:F90A: AD 21 FE     INTERUPT0	LDA	SIOSTAT	;Get status register, xfer irq bit to n flag (4)
  2678 00:F90D: 10 0C        					BPL	REGEXT	;if clear no 6551 irq, exit, else (2/3) (7 clock cyc
                    les to exit - take branch)
  2679                        ;
  2680 00:F90F: 89 08        ASYNC			BIT #%00001000	;check receive bit (2)
  2681 00:F911: D0 0F        					BNE RCVCHR	;get received character (2/3) (11 clock cycles to ju
                    mp to RCV)
  2682 00:F913: 89 10        					BIT #%00010000	;check xmit bit (2)
  2683 00:F915: D0 29        					BNE XMTCHR	;send xmit character (2/3) (15 clock cycles to jump 
                    to XMIT)
  2684                        ;no bits on means CTS went high
  2685 00:F917: 09 10        					ORA #%00010000 ;add CTS high mask to current status (2)
  2686 00:F919: 85 ED        IRQEXT		STA STTVAL ;update status value (3) (19 clock cycles to here for CTS fallout)
  2687                        ;
  2688 00:F91B: 6C 0A 03     REGEXT		JMP	(IRQRTVEC0) ;handle next irq (5)
  2689                        ;
  2690 00:F91E: A9 0C        BUFFUL		LDA #%00001100 ;buffer overflow flag (2)
  2691 00:F920: 80 F7        					BRA IRQEXT ;branch to exit (3)
  2692                        ;
  2693 00:F922: AD 20 FE     RCVCHR		LDA SIODAT	;get character from 6551 (4)
  2694 00:F925: D0 03        					BNE	RCV0	;If not a null character, handle as usual and put in
                    to buffer	(2/3)
  2695 00:F927: 6F FE AD     					BBR6	XMFLAG,BREAKEY	;If Xmodem not active, handle BRK (5)
  2696                        ;
  2697 00:F92A: A4 E7        RCV0			LDY ICNT	;get buffer counter (3)
  2698 00:F92C: 30 F0        					BMI	BUFFUL	;check against limit, branch if full (2/3)
  2699                        ;
  2700 00:F92E: A4 E9        					LDY ITAIL ;room in buffer (3)
  2701 00:F930: 99 00 02     					STA IBUF,Y ;store into buffer (5)
  2702 00:F933: E6 E9        					INC	ITAIL	;Increment tail pointer (5)
  2703 00:F935: 77 E9        					RMB7	ITAIL	;Strip off bit 7, 128 bytes only (5)
  2704 00:F937: E6 E7        					INC ICNT ;increment character count (5)
  2705                        ;	
  2706 00:F939: AD 21 FE     					LDA SIOSTAT ;get 6551 status reg (4)
  2707 00:F93C: 29 10        					AND #%00010000 ;check for xmit (2)
  2708 00:F93E: F0 DB        					BEQ REGEXT	;exit (2/3) (40 if exit, else 39 and drop to XMT)
  2709                        ;
  2710 00:F940: A5 EA        XMTCHR		LDA OCNT ;any characters to xmit? (3)
  2711 00:F942: F0 10        					BEQ NODATA ;no, turn off xmit (2/3)
  2712                        ;
  2713 00:F944: A4 EB        OUTDAT		LDY OHEAD ;get pointer to buffer (3)
  2714 00:F946: B9 80 02     					LDA OBUF,Y ;get the next character (4)
  2715 00:F949: 8D 20 FE     					STA SIODAT ;send the data (4)
  2716                        ;
  2717 00:F94C: E6 EB        					INC	OHEAD	;Increment Head pointer (5)
  Sun Mar  3 2019 23:01                                                                                                    Page 49


  2718 00:F94E: 77 EB        					RMB7	OHEAD	;Strip off bit 7, 128 bytes only (5)
  2719 00:F950: C6 EA        					DEC OCNT ;decrement counter (5)
  2720 00:F952: D0 C7        					BNE	REGEXT	;If not zero, exit and continue normal stuff (2/3) (
                    31 if branch, 30 if continue)
  2721                        ;
  2722 00:F954: A0 09        NODATA		LDY	#$09	;get mask for xmit off / rcv on (2)
  2723 00:F956: 8C 22 FE     					STY SIOCOM ;turn off xmit irq bits (5)
  2724 00:F959: 80 C0        					BRA REGEXT ;exit (3) (13 clock cycles added for turning off xmt)
  2725                        ;
  2726                        ;******************************************************************************
  2727                        ;
  2728                        ;Start of the 6522 BIOS code. Supports basic timer function
  2729                        ; A time of day clock is implemented with a resolution of 4ms
  2730                        ; Timer ticks is set at 250 ticks per second. Page zero holds
  2731                        ; all variables for ticks, seconds, minutes, hours, days
  2732                        ; To keep things simple, days is two bytes so can handle 0-65535 days,
  2733                        ; which is about 179 years. Additional calculations can be made if
  2734                        ; required for a particular application
  2735                        ;
  2736                        ;	Timer Delay Match routine:
  2737                        ;	This provides an accurate and consistent time delay
  2738                        ; using Timer 2 of the 6522. It is configured as a one-shot timer
  2739                        ;	set for 1 millisecond based on clock rate (see config table)
  2740                        ;	It uses an 8-bit value for countdown to reset a MATCH flag on timeout
  2741                        ;	Value can be 1-256 milliseconds ($00 = 256)
  2742                        ;	This routine must also reset the counter if MSDELAY has not decremented
  2743                        ;	to zero, which completes the timer delay
  2744                        ; The delay routine sets the MSDELAY value and MATCH flag to $80,
  2745                        ; then monitors the MATCH flag which is cleared after the delay
  2746                        ;
  2747                        ;	Note that each Timer has it's own exit vector. By default they point to the
  2748                        ;	following IRQ vector (6551 service routine). This allows either timer to be
  2749                        ;	used as a refresh routine by inserting additional code in either loop. The RTC
  2750                        ;	should not be changed, but Timer2 can be provided the user track it's use versus
  2751                        ;	the standard delay routines which also use Timer2
  2752                        ;	NOTE: 24 clock cycles via IRQ vector to get here
  2753                        ;
  2754                        ;Basic use of timer services includes:
  2755                        ;		RTC - time (relative timestamp)
  2756                        ;		Internal delay and timing routines
  2757                        ;		Background refresh tasks
  2758                        ;
  2759 00:F95B: AD 0D FE     INTERUPT1	LDA	Via1IFR	;Get IRQ flag register, xfer irq bit to n flag (4)
  2760 00:F95E: 10 4F        					BPL	REGEXT1	;if set, 6522 caused irq,(do not branch) (2/3) (7 cl
                    ock cycles to exit - take branch)
  2761 00:F960: 89 20        					BIT	#%00100000	;check T2 interrupt bit (2)
  2762 00:F962: D0 08        					BNE	DECMSD	;If active, handle T2 timer (MS delay) (2/3)
  2763 00:F964: 89 40        					BIT #%01000000	;check T1 interrupt bit (2)
  2764 00:F966: D0 18        					BNE	INCRTC	;If active, handle T1 timer (RTC) (2/3)
  2765 00:F968: 85 FA        					STA	STVVAL	;Save in status before exit (3)
  2766 00:F96A: 80 43        					BRA REGEXT1	;branch to next IRQ source, exit (3)
  2767                        ;
  2768 00:F96C: 2C 08 FE     DECMSD		BIT	Via1T2CL	;Clear interrupt for T2 (4)
  2769 00:F96F: C6 F4        					DEC	MSDELAY	;Decrement 1ms millisecond delay count (5)
  2770 00:F971: D0 05        					BNE	RESET_T2	;If not zero, re-enable T2 and exit (2/3)
  2771 00:F973: 64 F5        					STZ	MATCH	;Else, clear match flag (3) (25 clock cycles to clea
                    r MATCH)
  2772 00:F975: 6C 12 03     REGEXT2		JMP	(VECINSRT1)	;Done with timer handler, exit (5) 
  2773                        ;
  2774 00:F978: AD 29 03     RESET_T2	LDA	LOAD_6522+$07	;Get T2H value (4)
  2775 00:F97B: 8D 09 FE     					STA	Via1T2CH	;Reload T2 and re-enable interrupt (4) (31 c
                    lock cycles to restart T2)
  2776 00:F97E: 80 F5        					BRA	REGEXT2	;Done with timer handler, exit (3)
  Sun Mar  3 2019 23:01                                                                                                    Page 50


  2777                        ;
  2778 00:F980: 2C 04 FE     INCRTC		BIT	Via1T1CL	;Clear interrupt for T1 (4)
  2779 00:F983: C6 EE        					DEC	TICKS	;Decrement RTC tick count (5)
  2780 00:F985: D0 28        					BNE	REGEXT1	;Exit if not zero (2/3)
  2781 00:F987: A9 FA        					LDA	#DF_TICKS ;Get default tick count (2)
  2782 00:F989: 85 EE        					STA	TICKS	;Reset Tick count (3)
  2783                        ;
  2784 00:F98B: E6 EF        					INC	SECS	;Increment seconds (5)
  2785 00:F98D: A5 EF        					LDA	SECS	;Load it to Areg (3)
  2786 00:F98F: C9 3C        					CMP	#60	;Check for 60 seconds (2)
  2787 00:F991: 90 1C        					BCC	REGEXT1	;If not, exit (2/3)
  2788 00:F993: 64 EF        					STZ	SECS	;Else, reset seconds, inc Minutes (3)
  2789                        ;
  2790 00:F995: E6 F0        					INC	MINS	;Increment Minutes (5)
  2791 00:F997: A5 F0        					LDA	MINS	;Load it to Areg (3)
  2792 00:F999: C9 3C        					CMP	#60	;Check for 60 minutes (2)
  2793 00:F99B: 90 12        					BCC	REGEXT1	;If not, exit (2/3)
  2794 00:F99D: 64 F0        					STZ	MINS	;Else, reset Minutes, inc Hours (3)
  2795                        ;
  2796 00:F99F: E6 F1        					INC	HOURS	;Increment Hours (5)
  2797 00:F9A1: A5 F1        					LDA	HOURS	;Get it to Areg (3)
  2798 00:F9A3: C9 18        					CMP	#24	;Check for 24 hours (2)
  2799 00:F9A5: 90 08        					BCC	REGEXT1	;If not, exit (2/3)
  2800 00:F9A7: 64 F1        					STZ	HOURS	;Else, reset hours, inc Days (3)
  2801                        ;
  2802 00:F9A9: E6 F2        					INC	DAYSL	;Increment low-order Days (5)
  2803 00:F9AB: D0 02        					BNE	REGEXT1	;If not zero, exit (2/3)
  2804 00:F9AD: E6 F3        					INC	DAYSH	;Else increment high-order Days (5)
  2805                        ;
  2806 00:F9AF: 6C 10 03     REGEXT1		JMP	(VECINSRT0) ;handle next irq (5)
  2807                        ;
  2808 00:F9B2: 20 B9 F9     INIT_PG03	JSR	INIT_VEC	;Init the Vectors first (6)
  2809                        ;
  2810 00:F9B5: A0 40        INIT_CFG	LDY	#$40	;Get offset to data (2)
  2811 00:F9B7: 80 02        					BRA	DATA_XFER	;Go move the data to page $03 (3)
  2812 00:F9B9: A0 20        INIT_VEC	LDY	#$20	;Get offset to data (2)
  2813                        ;
  2814 00:F9BB: 78           DATA_XFER	SEI	;Disable Interrupts, can be called via JMP table (2)
  2815 00:F9BC: A2 20        					LDX	#$20	;Set count for 32 bytes (2)
  2816                        DATA_XFLP
  2817 00:F9BE: B9 A8 FF     					LDA	VEC_TABLE-1,Y	;Get ROM table data (4)
  2818 00:F9C1: 99 FF 02     					STA	SOFTVEC-1,Y	;Store in Soft table location (5)
  2819 00:F9C4: 88           					DEY	;Decrement index (2)
  2820 00:F9C5: CA           					DEX	;Decrement count (2)
  2821 00:F9C6: D0 F6        					BNE	DATA_XFLP	;Loop back till done (2/3)
  2822 00:F9C8: 58           					CLI	;re-enable interupts (2)
  2823 00:F9C9: 60           					RTS	;Return to caller (6)
  2824                        ;
  2825                        INIT_6551
  2826                        ;Init the 65C51
  2827 00:F9CA: 78           					SEI	;Disable Interrupts (2)
  2828 00:F9CB: 9C 21 FE     					STZ	SIOSTAT	;write to status reg, reset 6551 (3)
  2829 00:F9CE: 64 ED        					STZ	STTVAL	;zero status pointer (3)
  2830 00:F9D0: A2 02        					LDX	#$02	;Get count of 2 (2)
  2831                        INIT_6551L
  2832 00:F9D2: BD 1F 03     					LDA	LOAD_6551-1,X	;Get Current 6551 config parameters (4)
  2833 00:F9D5: 9D 21 FE     					STA	SIOBase+1,X	;Write to current 6551 device (5)
  2834 00:F9D8: CA           					DEX	;Decrement count (2)
  2835 00:F9D9: D0 F7        					BNE	INIT_6551L	;Loop back until done (2/3)
  2836 00:F9DB: 58           					CLI	;Re-enable Interrupts (2)
  2837 00:F9DC: 60           					RTS	;Return to caller (6)
  2838                        ;
  2839 00:F9DD: 20 CA F9     INIT_IO		JSR	INIT_6551	;Init the Console first (6)
  Sun Mar  3 2019 23:01                                                                                                    Page 51


  2840                        ;
  2841                        INIT_6522
  2842                        ;Init the 65C22
  2843 00:F9E0: 78           					SEI	;Disable Interrupts (2)
  2844 00:F9E1: 64 FA        					STZ	STVVAL	;zero status pointer (3)
  2845 00:F9E3: A2 0D        					LDX  #$0D	;Get Count of 13 (2)
  2846                        INIT_6522L
  2847 00:F9E5: BD 21 03     					LDA	LOAD_6522-1,X	;Get soft parameters (4)
  2848 00:F9E8: 9D 01 FE     					STA	Via1Base+1,X	;Load into 6522 chip (5)
  2849 00:F9EB: CA           					DEX	;Decrement to next parameter (2)
  2850 00:F9EC: D0 F7        					BNE	INIT_6522L	;Branch back till all are loaded (2/3)
  2851 00:F9EE: 58           					CLI	;Re-enable IRQ (2)
  2852 00:F9EF: 60           RET				RTS	;Return to caller (6)
  2853                        ;
  2854                        ;END OF BIOS CODE
  2855                        ;
  2856                        ;******************************************************************************
  2857                        				.ORG	$FE00	;Reserved for I/O page - do NOT put code here
  2858                        ;******************************************************************************
  2859                        ;
  2860                        ;START OF TOP PAGE - DO NOT MOVE FROM THIS ADDRESS!!
  2861                        ; 
  2862                        				.ORG	$FF00	;JMP Table, HW Vectors, Cold Init and Vector handlers
  2863                        ;
  2864                        ;JUMP Table starts here:
  2865                        ;	- BIOS calls are from the top down - total of 16
  2866                        ;	- Monitor calls are from the bottom up
  2867                        ;	- Reserved calls are in the shrinking middle
  2868                        ;
  2869 00:FF00: 4C 6C E1     					JMP	RDLINE
  2870 00:FF03: 4C B0 E1     					JMP	RDCHAR
  2871 00:FF06: 4C A6 E0     					JMP	HEXIN2
  2872 00:FF09: 4C 99 E0     					JMP	HEXIN4
  2873 00:FF0C: 4C 5E E0     					JMP	HEX2ASC
  2874 00:FF0F: 4C 48 E0     					JMP	BIN2ASC
  2875 00:FF12: 4C 2E E0     					JMP	ASC2BIN
  2876 00:FF15: 4C 21 E1     					JMP	DOLLAR
  2877 00:FF18: 4C 4E E1     					JMP	PRBYTE
  2878 00:FF1B: 4C 64 E1     					JMP	PRWORD
  2879 00:FF1E: 4C 41 E1     					JMP	PRASC
  2880 00:FF21: 4C 35 E7     					JMP	PROMPT
  2881 00:FF24: 4C 2D E7     					JMP	PROMPTR
  2882 00:FF27: 4C BA E1     					JMP	CONTINUE
  2883 00:FF2A: 4C 29 E1     					JMP	CROUT
  2884 00:FF2D: 4C 1C E1     					JMP	SPC
  2885 00:FF30: 4C 50 E7     					JMP	UPTIME
  2886 00:FF33: 4C EF F9     					JMP	RET
  2887 00:FF36: 4C EF F9     					JMP	RET
  2888 00:FF39: 4C EF F9     					JMP	RET
  2889 00:FF3C: 4C EF F9     					JMP	RET
  2890 00:FF3F: 4C EF F9     					JMP	RET
  2891 00:FF42: 4C EF F9     					JMP	RET
  2892 00:FF45: 4C EF F9     					JMP	RET
  2893 00:FF48: 4C 00 F8     					JMP	CHRIN_NW
  2894 00:FF4B: 4C 06 F8     					JMP	CHRIN
  2895 00:FF4E: 4C 19 F8     					JMP	CHROUT
  2896 00:FF51: 4C 30 F8     					JMP	SET_DLY
  2897 00:FF54: 4C 37 F8     					JMP	EXE_MSDLY
  2898 00:FF57: 4C 49 F8     					JMP	EXE_LGDLY
  2899 00:FF5A: 4C 5E F8     					JMP	EXE_XLDLY
  2900 00:FF5D: 4C 66 F8     					JMP	SET_PORT
  2901 00:FF60: 4C 76 F8     					JMP	IN_PORT
  2902 00:FF63: 4C 84 F8     					JMP	OUT_PORT
  Sun Mar  3 2019 23:01                                                                                                    Page 52


  2903 00:FF66: 4C B9 F9     					JMP	INIT_VEC
  2904 00:FF69: 4C B5 F9     					JMP	INIT_CFG
  2905 00:FF6C: 4C CA F9     					JMP	INIT_6551
  2906 00:FF6F: 4C E0 F9     					JMP	INIT_6522
  2907 00:FF72: 6C 0E 03     					JMP	(WRMMNVEC0)
  2908 00:FF75: 6C 0C 03     CMBV			JMP	(CLDMNVEC0)
  2909                        ;
  2910 00:FF78: D8           COLDSTRT	CLD	;Clear decimal mode in case of software call (Zero Ram calls this) (2)
  2911 00:FF79: 78           					SEI	;Disable Interrupt for same reason as above (2)
  2912 00:FF7A: A2 00        					LDX	#$00	;Index for length of page (2)
  2913 00:FF7C: 74 00        PAGE0_LP	STZ	$00,X	;Zero out Page Zero (4)
  2914 00:FF7E: CA           					DEX	;Decrement index (2)
  2915 00:FF7F: D0 FB        					BNE	PAGE0_LP	;Loop back till done (2/3)
  2916 00:FF81: CA           					DEX	;LDX #$FF ;-) (2)
  2917 00:FF82: 9A           					TXS	;Set Stack Pointer (2)
  2918                        ;
  2919 00:FF83: 20 B2 F9     					JSR	INIT_PG03	;Xfer default Vectors/HW Config to $0300 (6)
  2920 00:FF86: 20 DD F9     					JSR	INIT_IO	;Init I/O - Console, Timers, Ports (6)
  2921                        ;
  2922                        ; Send BIOS init msg to console
  2923                        ;	- note: X reg is zero on return from INIT_IO
  2924 00:FF89: BD E9 FF     BMSG_LP		LDA	BIOS_MSG,X	;Get BIOS init msg (4)
  2925 00:FF8C: F0 E7        					BEQ	CMBV	;If zero, msg done, goto cold start monitor (2/3)
  2926 00:FF8E: 20 19 F8     					JSR	CHROUT	;Send to console (6)
  2927 00:FF91: E8           					INX	;Increment Index (2)
  2928 00:FF92: 80 F5        					BRA	BMSG_LP	;Loop back until done (3)
  2929                        ;
  2930                        IRQ_VECTOR	;This is the ROM start for the BRK/IRQ handler
  2931 00:FF94: 48           					PHA	;Save A Reg (3)
  2932 00:FF95: DA           					PHX	;Save X Reg (3)
  2933 00:FF96: 5A           					PHY	;Save Y Reg (3)
  2934 00:FF97: BA           					TSX	;Get Stack pointer (2)
  2935 00:FF98: BD 04 01     					LDA	$0100+4,X	;Get Status Register (4)
  2936 00:FF9B: 29 10        					AND	#$10	;Mask for BRK bit set (2)
  2937 00:FF9D: D0 03        					BNE	DO_BRK	;If set, handle BRK (2/3)
  2938 00:FF9F: 6C 04 03     					JMP	(IRQVEC0)	;Jump to Soft vectored IRQ Handler (5) (24 c
                    lock cycles to vector routine)
  2939 00:FFA2: 6C 02 03     DO_BRK		JMP	(BRKVEC0)	;Jump to Soft vectored BRK Handler (5) (25 clock cycles to v
                    ector routine)
  2940                        ;
  2941                        IRQ_EXIT0	;This is the standard return for the IRQ/BRK handler routines
  2942 00:FFA5: 7A           					PLY	;Restore Y Reg (4)
  2943 00:FFA6: FA           					PLX	;Restore X Reg (4)
  2944 00:FFA7: 68           					PLA	;Restore A Reg (4)
  2945 00:FFA8: 40           					RTI	;Return from IRQ/BRK routine (6) (18 clock cycles from vecto
                    r jump to IRQ end)
  2946                        ;
  2947                        ;******************************************************************************
  2948                        ;
  2949                        ;START OF BIOS DEFAULT VECTOR DATA AND HARDWARE CONFIGURATION DATA
  2950                        ;
  2951                        ;The default location for the NMI/BRK/IRQ Vector data is at location $0300
  2952                        ; details of the layout are listed at the top of the source file
  2953                        ;	there are 8 main vectors and 8 vector inserts, one is used for the 6522
  2954                        ;
  2955                        ;The default location for the hardware configuration data is at location $0320
  2956                        ; it is mostly a freeform table which gets copied from ROM to page $03
  2957                        ; the default size for the config table is 32 bytes, 17 bytes are free
  2958                        ;
  2959                        VEC_TABLE	;Vector table data for default ROM handlers
  2960                        ;Vector set 0
  2961 00:FFA9: 92 F8        					.DW	NMI_VECTOR	;NMI Location in ROM
  2962 00:FFAB: D8 F8        					.DW	BRKINSTR0	;BRK Location in ROM
  Sun Mar  3 2019 23:01                                                                                                    Page 53


  2963 00:FFAD: 5B F9        					.DW	INTERUPT1	;IRQ Location in ROM
  2964                        ;
  2965 00:FFAF: 05 E0        					.DW	WRM_MON	;NMI return handler in ROM
  2966 00:FFB1: 05 E0        					.DW	WRM_MON	;BRK return handler in ROM
  2967 00:FFB3: A5 FF        					.DW	IRQ_EXIT0	;IRQ return handler in ROM
  2968                        ;
  2969 00:FFB5: 00 E0        					.DW	MONITOR	;Monitor Cold start
  2970 00:FFB7: 05 E0        					.DW	WRM_MON	;Monitor Warm start
  2971                        ;
  2972                        ;Vector Inserts (total of 8)
  2973                        ; these can be used as required, one is used by default for the 6522
  2974                        ; as NMI/BRK/IRQ and the Monitor are vectored, all can be extended
  2975                        ; by using these reserved vectors. 
  2976 00:FFB9: 0A F9        					.DW	INTERUPT0	;Insert 0 Location - for 6522 timer1
  2977 00:FFBB: 0A F9        					.DW	INTERUPT0	;Insert 1 Location - for 6522 timer2
  2978 00:FFBD: FF FF        					.DW	$FFFF	;Insert 2 Location
  2979 00:FFBF: FF FF        					.DW	$FFFF	;Insert 3 Location
  2980 00:FFC1: FF FF        					.DW	$FFFF	;Insert 4 Location
  2981 00:FFC3: FF FF        					.DW	$FFFF	;Insert 5 Location
  2982 00:FFC5: FF FF        					.DW	$FFFF	;Insert 6 Location
  2983 00:FFC7: FF FF        					.DW	$FFFF	;Insert 7 Location
  2984                        ;
  2985                        CFG_TABLE	;Configuration table for hardware devices
  2986                        ;
  2987                        CFG_6551	;2 bytes required for 6551
  2988                        ; Command Register bit definitions:
  2989                        ; Bit 7/6	= Parity Control: 0,0 = Odd Parity
  2990                        ; Bit 5		= Parity enable: 0 = No Parity
  2991                        ; Bit 4		= Receiver Echo mode: 0 = Normal 
  2992                        ; Bit 3/2	= Transmitter Interrupt Control: 
  2993                        ; Bit 1		= Receiver Interrupt Control: 0 = Enabled / 1 = Disabled
  2994                        ; Bit 0		= DTR Control: 1 = DTR Ready
  2995                        ;
  2996                        ; Default for setup:		%00001001 ($09)
  2997                        ; Default for transmit:	%00000101 ($05)
  2998 00:FFC9: 09           					.DB	$09	;Default 65C51 Command register, transmit/receiver I
                    RQ output enabled)
  2999                        ;
  3000                        ; Baud Select Register:
  3001                        ; Bit 7		= Stop Bit: 0 = 1 Stop Bit
  3002                        ; Bit 6/5	= Word Length: 00 = 8 bits
  3003                        ; Bit 4		= Receiver Clock Source: 0 = External Clk 1 = Baud Rate Gen
  3004                        ; Bit 3-0	= Baud Rate Table: 1111 = 19.2K Baud (default)
  3005                        ;
  3006                        ; Default for setup:		%00011111 ($1F) - 19.2K, 8 data, 1 stop)
  3007 00:FFCA: 1F           					.DB	$1F	;Default 65C51 Control register, (115.2K,no parity,8
                     data bits,1 stop bit)
  3008                        ;
  3009                        CFG_6522	;13 bytes required for 6522
  3010                        ;Timer 1 load value is based on CPU clock frequency for 4 milliseconds - RTC use
  3011                        ; Note that 2 needs to be subtracted from the count value, i.e., 16000 needs to be 15998, etc.
  3012                        ; This corresponds to the W65C22 datasheet showing N+2 between interrupts in continuous mode
  3013                        ; 16MHz = 63998, 10MHz = 39998, 8MHz = 31998, 6MHz = 23998, 5MHz = 19998, 4MHz = 15998, 2MHz = 7998
  3014                        ; 16MHz = $F9FE, 10MHz = $9C3E, 8MHz = $7CFE, 6MHz = $5DBE, 5MHz = $4E1E, 4MHz = $3E7E, 2MHz = $1F3E
  3015                        ;
  3016                        ;Timer 2 load value is based on CPU clock frequency for 1 millisecond - delay use
  3017                        ;	- Timer 2 value needs to be adjusted to compensate for the time to respond to the interrupt
  3018                        ;	- and reset the timer for another 1ms countdown, which is 55 clock cycles
  3019                        ;	- As Timer 2 counts clock cycles, each of the values should be adjusted by subtracting 55+2
  3020                        ;	16MHz = 15943,	10MHz = 9943,		8MHz = 7943,	6MHz = 5943,	5MHz = 4943,	4MHz = 3943,
                    	2MHz = 1943
  3021                        ; 16MHz = $3E47,	10MHz = $26D7,	8MHz = $1F07,	6MHz = $1737,	5MHz = $134F,	4MHz = $0F67,	2MHz
                     = $0797
  Sun Mar  3 2019 23:01                                                                                                    Page 54


  3022                        ;
  3023                        ; only the ports that are needed for config are shown below:
  3024                        ;
  3025 00:FFCB: 00           					.DB	$00	;Data Direction register Port B
  3026 00:FFCC: 00           					.DB	$00	;Data Direction register Port A
  3027 00:FFCD: 7E           					.DB	$7E	;T1CL - set for CPU clock as above - $04
  3028 00:FFCE: 3E           					.DB	$3E	;T1CH - to 4ms (250 interupts per second) - $05
  3029 00:FFCF: 00           					.DB	$00	;T1LL - T1 counter latch low
  3030 00:FFD0: 00           					.DB	$00	;T1LH - T1 counter latch high
  3031 00:FFD1: 67           					.DB	$67	;T2CL - T2 counter low count - set for 1ms (adjusted
                    )
  3032 00:FFD2: 0F           					.DB	$0F	;T2CH - T2 counter high count - used for delay timer
  3033 00:FFD3: 00           					.DB	$00	;SR - Shift register
  3034 00:FFD4: 40           					.DB	$40	;ACR - Aux control register
  3035 00:FFD5: 00           					.DB	$00	;PCR - Peripheral control register
  3036 00:FFD6: 7F           					.DB	$7F	;IFR - Interrupt flag register (clear all)
  3037 00:FFD7: E0           					.DB	$E0	;IER - Interrupt enable register (enable T1/T2)
  3038 00:FFD8: FF           					.DB	$FF	;Free config byte
  3039                        ;
  3040                        ;Reserved for additional I/O devices (16 bytes total)
  3041 00:FFD9: FF FF FF FF  					.DB	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
       00:FFDD: FF FF FF FF 
  3042 00:FFE1: FF FF FF FF  					.DB	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
       00:FFE5: FF FF FF FF 
  3043                        ;
  3044                        ;END OF BIOS VECTOR DATA AND HARDWARE DEFAULT CONFIGURATION DATA
  3045                        ;******************************************************************************
  3046                        ;
  3047                        ;BIOS init message - sent before jumping to the monitor coldstart vector
  3048 00:FFE9: 0D 0A        BIOS_MSG	.DB	$0D,$0A
  3049 00:FFEB: 42 49 4F 53  					.DB	"BIOS 1.4 "
       00:FFEF: 20 31 2E 34 
       00:FFF3: 20 
  3050 00:FFF4: 34 4D 48 7A  					.DB	"4MHz"
  3051 00:FFF8: 00           					.DB	$00	;Terminate string
  3052                        ;
  3053                        ;65C02 Vectors:
  3054                        					.ORG	$FFFA
  3055 00:FFFA: 00 03        					.DW	NMIVEC0	;NMI
  3056 00:FFFC: 78 FF        					.DW	COLDSTRT	;RESET
  3057 00:FFFE: 94 FF        					.DW	IRQ_VECTOR	;IRQ
  3058                        					.END


      Lines assembled: 3058
      Errors: 0
